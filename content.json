[{"title":"浏览器的协商缓存与强缓存","date":"2017-02-28T08:50:31.000Z","path":"2017/02/28/http-cache/","text":"什么是浏览器缓存浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。 浏览器缓存的优点有： 减少了冗余的数据传输，节省了网费 减少了服务器的负担，大大提升了网站的性能 加快了客户端加载网页的速度 浏览器缓存的分类浏览器缓存主要有两类：缓存协商和彻底缓存，也有称之为协商缓存和强缓存。 浏览器在第一次请求发生后，再次请求时： 浏览器会先获取该资源缓存的 header 信息，根据其中的 expires 和 cahe-control 判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的 header 信息，本次请求不会与服务器进行通信； 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的 header 字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match），由服务器根据请求中的相关 header 信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应 header 信息更新缓存中的对应 header 信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。 强缓存强缓存是利用 http 的返回头中的 Expires 或者 Cache-Control 两个字段来控制的，用来表示资源的缓存时间。 Expires 该字段是 http1.0 时的规范，它的值为一个绝对时间的 GMT 格式的时间字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。 Cache-Control Cache-Control 是 http1.1 时出现的 header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值： no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。 Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。 协商缓存协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组 header 字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified 或者 Etag），则后续请求则会带上对应的请求字段（If-Modified-Since 或者 If-None-Match），若响应头没有 Last-Modified 或者 Etag 字段，则请求头也不会有对应的字段。 Last-Modify/If-Modify-Since 浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间，例如 Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。 当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。 如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回 Last-Modify。 ETag/If-None-Match 与 Last-Modify/If-Modify-Since 不同的是，Etag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If-None-Match 值来判断是否命中缓存。 与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。 为什么要有 Etag 你可能会觉得使用 Last-Modified 已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要 Etag 呢？HTTP1.1 中 Etag 的出现主要是为了解决几个 Last-Modified 比较难解决的问题： 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET； 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，If-Modified-Since 能检查到的粒度是s级的，这种修改无法判断(或者说 UNIX 记录 MTIME 只能精确到秒)； 某些服务器不能精确的得到文件的最后修改时间。 Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。 强缓存与协商缓存的区别可以用下表来表示： 缓存类型 获取资源形式 状态码 发送请求到服务器 强缓存 从缓存取 200（from cache） 否，直接从缓存取 协商缓存 从缓存取 304（Not Modified） 否，通过服务器来告知缓存是否可用 用户行为对缓存的影响 用户操作 Expires/Cache-Control Last-Modied/Etag 地址栏回车 有效 有效 页面链接跳转 有效 有效 新开窗口 有效 有效 前进回退 有效 有效 F5刷新 无效 有效 Ctrl+F5强制刷新 无效 无效 参考资料： 浏览器缓存机制剖析","tags":[{"name":"http","slug":"http","permalink":"http://zqianduan.com/tags/http/"},{"name":"cache","slug":"cache","permalink":"http://zqianduan.com/tags/cache/"},{"name":"browser","slug":"browser","permalink":"http://zqianduan.com/tags/browser/"}]},{"title":"开发机 samba 安装指南","date":"2017-01-04T04:03:44.000Z","path":"2017/01/04/dev-server-samba/","text":"简介：Samba 是在 Linux 和 UNIX 系统上实现 SMB 协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。 注意：要安装samba必须有 root 权限，没有权限可以找相关同学申请。 安装 下载 samba-3.5.8.tar.gz 到 /home/work/(此处可以用自己指定 path) wget &quot;http://hetu.baidu.com:80/api/tool/getFile?toolId=1145&amp;fileId=925&quot; -O &quot;samba-3.5.8.tar.gz&quot; 解压 tar zxvf samba-3.5.8.tar.gz 执行 cd samba-3.5.8/source3 执行 ./configure &amp;&amp; make -j 4 执行 make install 配置 执行 cd /usr/local/samba/ (默认安装到该路径下) 执行 vi lib/smb.conf (将下面内容粘贴到 smb.conf) 1234567891011121314151617[global]diplay charset = utf8unix charset = gbkdos charset = gbkworkgroup = worknetbios name = workserver string = ucsecurity = user[aswork]comment = ucpath = /home/workcreate mask = 0664directory mask = 0775writable = yesvalid users = work // 用户登录名称browseable = yes 配置项说明： [global]: 标识全局配置，前三行是对编码的配置 workgroup: 设置服务器所要加入的工作组的名称，会在 Windows 的”网上邻居”中能看到 work 工作组，可以在此设置所需要的工作组的名称。 netbios name: 设置出现在”网上邻居”中的主机名，默认情况下，则使用真正的主机名。 server string: 设置服务器主机的说明信息，当在 Windows 的”网上邻居”中打开 Samba 上设置的工作组时，在 Windows 的资源管理器窗口，会列出”名称”和”备注”栏，其中”名称”栏会显示出 Samba 服务器的 NetBios 名称，而”备注”栏则显示出此处设置的”Samba Server”。当然，可以修改默认的”Sambe Server”，使用自己的描述信息。 security: 设置 Samba 服务器的安全等级，默认情况下，使用 user 等级。 Samba服务器一共有四种安全等级： (1) share: 使用此等级，用户不需要帐号及密码可以登陆Samba服务器。 (2) user: 使用此等级，由提供服务的Samba服务器检查用户帐号及密码。 (3) server: 使用此等级，检查帐号及密码的工作可指定另一台Samba服务器负责。 (4) domain: 使用此等级，需要指定一台 Windows NT/2000/XP 服务器（通常为域控制器），以验证用户输入的帐号及密码。 [aswork]: 标识 Samba 文件共享配置（中括号中名称任意）。 comment: 针对共享资源所作的说明、注释部分。 path: 若共享资源是目录，则指定目录的位置；若为打印机，则指定打印机队列的位置。 create mask: 设置文件的访问权限，默认值为0744。 directory mask: 设置目录的访问权限，默认值为0755。 writeable: 设置共享的资源是否可以写入。若共享资源是打印机，则不需设置此参数。 valid users: 设置合法用户名。 browseable: 设置用户是否可以看到此共享资源。默认值为 yes，若将此参数设置为 no，用户虽然看不到此资源，但是拥有权限的用户仍可直接输入该资源的网址来访问该资源。 启动和使用 Samba 执行 vi ~/.bash_profile （在文件里添加如下内容） export LD_LIBRARY_PATH=/usr/local/samba/lib:$LD_LIBRARY_PATH 保存退出； 执行 . ~/.bash_profile 执行 ./bin/smbpasswd -a work (设置work的密码) 执行 cd /usr/local/samba/sbin 执行 ./smbd -D (启动samba) ps auxf | grep smbd 查看进程是否启动，netstat -npl 查看 samba 端口号，默认会使用139、445两个端口号 Windows 下 win+r 运行框中输入 \\\\{IP} 地址 (Mac 下 cmd+k 输入 smb://{IP})，输入配置的用户名、密码即可访问（windows 下可将目录映射为网络驱动器） 修改配置后需重启 Samba 服务 /usr/local/samba/sbin/smbd restart","tags":[{"name":"samba","slug":"samba","permalink":"http://zqianduan.com/tags/samba/"}]},{"title":"Javascript this 解析","date":"2016-12-19T14:42:18.000Z","path":"2016/12/19/javascript-this/","text":"在 Javascript 里，函数被调用的时候，除了接受声明时定义的形式参数，每一个函数还接受两个附加的参数: this 和 arguments。随着函数使用场合的不同，this 的值会发生变化。但是有一个总的原则，那就是 this 指的是，调用函数的那个对象。下面分四种情况，具体讨论 this 的用法： 对象方法调用模式 12345678window.name= 'window'; var object = &#123; name: 'object', run: function() &#123; console.log(this.name); &#125;&#125;;object.run(); // 'object' 分析：当一个函数被保存为对象的一个属性时，我们称它为一个方法。当方法被调用时(通过 . 表达式或 object[fun] 下标表达式)，this 绑定到该对象 函数调用模式 当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的，以此模式调用函数时，this 被绑定到全局对象（ECMAScript6 的箭头函数（注意只是箭头函数）基本纠正了这个设计）： 1234567891011121314151617181920window.name= 'window'; var object = &#123; name: 'object', run: function() &#123; innerFun(); function innerFun() &#123; console.log(this.name); &#125; return function () &#123; console.log(this.name); &#125; &#125;&#125;;object.run()();// =&gt;// 'window'// 'window' 分析：从上面可以看出，不管外部环境的 this 是不是 window，通过函数调用模式调用的函数，this 指向 window. 来看看 ES6 的 this: 1234567891011121314window.name= 'window'; var object = &#123; name: 'object', run: function() &#123; return () =&gt; &#123; console.log(this.name); &#125; &#125;&#125;;var o = &#123; name: 'test_o' &#125;;object.run()(); // 'object'object.run().apply(o); // 'object' 如果这么写： 123456789101112window.name= 'window'; var object = &#123; name: 'object', run: () =&gt; &#123; console.log(this.name); &#125;&#125;;var o = &#123; name: 'test_o' &#125;;object.run(); // 'window'object.run.apply(o); // 'window' 分析：箭头函数和普通函数之间有一个重要的差别 - 箭头函数没有自己的 this 值，其 this 值是继承外域的 this 值。所以箭头函数不仅仅是从外观上简化了函数的写法，更解决了普通函数中 this 的 hack 问题。 构造函数调用模式 当一个函数被作为一个构造函数来使用（使用new关键字），它的 this 与即将被创建的新对象绑定。 1234567891011121314function C()&#123; this.a = 37;&#125;var o = new C();console.log(o.a); // 37function C2()&#123; this.a = 37; return &#123;a:38&#125;;&#125;o = new C2();console.log(o.a); // 38 注意：当构造器返回的默认值是一个 this 引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回 this。 call, apply, bind 调用 call, apply 方法的用途都是在特定的作用域中调用函数。apply 方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是 arguments 对象。call 方法与 apply 方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call 方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数 123456789101112var a = 1;function test() &#123; console.log(this.a);&#125;var o = &#123;&#125;;o.a = 2;o.fun = test;o.fun.apply(o); // 1o.fun.call(o); // 1 ECMAScript 5 引入了 Function.prototype.bind。调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。 123456789function f()&#123; return this.a;&#125;var g = f.bind(&#123;a:\"azerty\"&#125;);console.log(g()); // azertyvar o = &#123;a:37, f:f, g:g&#125;;console.log(o.f(), o.g()); // 37, azerty this 容易误用的情况 内联式绑定 Dom 元素的事件处理函数 1234567&lt;script type=\"text/javascript\"&gt; function hello() &#123; console.log(this.tagName); &#125; &lt;/script&gt;&lt;input id=\"btnTest\" type=\"button\" value=\"点击我\" onclick=\"hello()\"&gt; 运行结果是 undefined, 此时的 this 指针并不是指向 input 元素，使用内联式绑定 Dom 元素的事件处理函数时，实际 上相当于执行了以下代码： 1234567891011&lt;script type=\"text/javascript\"&gt; function hello() &#123; console.log(this.tagName); &#125; document.getElementById(\"btnTest\").onclick = function () &#123; hello(); &#125;;&lt;/script&gt;&lt;input id=\"btnTest\" type=\"button\" value=\"点击我\"&gt; 这种情况下 hello 函数对象的所有权并没有发生转移，还是属于 window 对象所有。因为还是 window 对象在调用 hello 方法 解决方案：把 this 作为参数传入函数，或者直接把方法作为对象的一个属性，这样方法中的 this 直接指定的是当前对象 1234567&lt;script type=\"text/javascript\"&gt; function hello(el) &#123; console.log(el.tagName); &#125; &lt;/script&gt;&lt;input id=\"btnTest\" type=\"button\" value=\"点击我\" onclick=\"hello(this)\"&gt; 或： 123456789&lt;script type=\"text/javascript\"&gt; function hello() &#123; console.log(this.tagName); &#125; document.getElementById(\"btnTest\").onclick = hello;&lt;/script&gt;&lt;input id=\"btnTest\" type=\"button\" value=\"点击我\"&gt; 临时变量导致的 this 指针丢失 123456789101112131415window.name= 'window'; var object = &#123; name: 'object', run: function() &#123; console.log(this.name); &#125;&#125;;function runTest() &#123; var tmpRun = object.run; tmpRun();&#125;runTest(); // 'window' 此时 object.run 被赋值给了临时变量 tmpRun, 而临时变量是属于 window 对象的（只不过外界不能直接引用，只对 Javascript 引擎可见），于是在 run 函数内部的 this 指针指向的就是 window 对象了。 解决方案： 不引入临时变量，每次使用均使用 object.run() 进行调用 run 函数内部使用 object.name 显式引用 name 属性，而不通过 this 指针隐式引用 使用 apply/call 函数指定 this 指针 函数传参导致 this 丢失 123456789window.name= 'window'; var object = &#123; name: 'object', run: function() &#123; console.log(this.name); &#125;&#125;;setTimeout(object.run, 100); // 'window' 其实这个问题和上一个示例中的问题是类似的，都是因为临时变量而导致的问题。当我 们执行函数的时候，如果函数带有参数，那么这个时候 Javascript 引擎会创建一个临时变量， 并将传入的参数复制（注意，Javascript 里面都是值传递的，没有引用传递的概念）给此临时变量。也就是说，整个过程就跟上面我们定义了一个 tmpRun 的临时变量，再将 object.run 赋值给这个临时变量一样。只不过在这个示例中，容易忽视临时变量导致的 bug。 参考资料： MDN this","tags":[{"name":"javascript","slug":"javascript","permalink":"http://zqianduan.com/tags/javascript/"},{"name":"this","slug":"this","permalink":"http://zqianduan.com/tags/this/"}]},{"title":"SSL 证书简介","date":"2016-09-29T05:40:28.000Z","path":"2016/09/29/ssl-certificate/","text":"相关概念SSL证书：在应用HTTPS之前，用户应先配置SSL证书。SSL证书是由证书授权中心（CA）签发的对用户公钥的认证。证书的内容包括：电子签证机关的信息、公钥用户信息、公钥、权威机构的签字和有效期等。目前，证书的格式和验证方法普遍遵循X.509 国际标准。 HTTPS：Hyper Text Transfer Protocol over Secure Socket Layer。HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。 SSL：Secure Sockets Layer。SSL是一个安全协议，它提供使用 TCP/IP 的通信应用程序间的隐私与完整性。因特网的超文本传输协议（HTTP）使用 SSL 来实现安全的通信。 TLS：Transport Layer Security Protocol。TLS是IETF制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。TLS也经常用SSL来指代。 CA：即证书授权中心（CA, Certificate Authority）。CA是负责签发证书、认证证书、管理已颁发证书的机关。用户向CA提出申请后，CA负责审核用户信息，然后对关键信息利用私钥进行”签名”，并公开对应的公钥。客户端可以利用公钥验证签名。 非对称加密：即常见的RSA、DH、EC等算法，算法特点是密钥成对出现，一般称为公钥（公开）和私钥（保密），公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。公钥对外公开，私钥由服务器保存。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。 CSR：CSR是Certificate Signing Request的英文缩写，即证书请求文件，也就是证书申请者在申请数字证书时由CSP（加密服务提供者）在生成私钥的同时所生成的证书请求文件。证书申请者只要把CSR文件提交给证书颁发机构后，证书颁发机构使用其根证书私钥签名就生成了证书公钥文件，也就是颁发给用户的证书。 PEM：Openssl所使用的文档格式。RFC 1421-1424。 创建证书可以使用OpenSSL来创建CSR，并通过相关机构（例如：沃通）申请证书，具体操作方法如下： 前置任务在申请证书前，用户应先获取并安装相关工具。 Linux：建议使用OpenSSL。OpenSSL是一个强大的SLL密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。 Windows：可供选择的工具包括：IIS Manager，SelfSSL，OpenSSL和Windows PowerShell cmdlets等。 使用OpenSSL创建证书提交证书申请前，用户需在本地生成私钥和证书请求文件（CSR）；然后用户可以将CSR提交至CA进行签名认证，也可以通过自签名的方式进行本地测试。具体操作方法如以下示例所示（本示例中使用的工具为OpenSSL）。 (1) 执行命令 openssl genrsa -out my-private-key.pem 2048，通过RSA算法生成私钥，并保存在 my-private-key.pem 文件中。百度开放云支持1024、2048和4096 bits长度的私钥，建议使用2048 bits长度。 注意：请妥善保管私钥，避免遗失和泄露。 查看私钥文件的具体内容如下： 12345678910111213-----BEGIN RSA PRIVATE KEY-----MIIEowIBAAKCAQEAtp7N1PA57N6cA73X9WyupkjZYx1bYHZA35gTrGa6ojd8oURW8cqXD46P0dccfiJ34s1eEMquuMsFTtezVNmMH9elADnKVIRBg/NfwehhLx++eeJ0CuOT08QB373Lyzud93BefhHfYB295DI42IF8NuC60jWVlfmZG7cBSAPSt24Lya1lPzvEULnDSXgMVyDcOW4v82hcztLhfliFUmrf5Vz/uRJNwBKuMrRIBGu4u8pxplzg......9z+Rm0fnFhc3/945EIic9sUCgYA0ZoqfXOkQ07UnIPwvFKNIIQRTJfY67V6sZt4tl3pbT+BlM2ihS4G4MlSfw4l6lFSPOCsF16RbftOlUPT/ieWWROBFR2tZ1RLNTfmo3T5w9tyjjYFOxL56sPh5MmTTq9JhtfMn+xxsaPwgASDLbj58x4dRj4y7jHqOMbCE15QNOQKBgADt2m46ZRnFZNL78Xl93/D0TOXowmjiOtgBhEwsuRnlPuDNMUSF4+OZCWm17VfZRQSeN81v3N+0jeJkl3GFemC0Zt49pce4H9paZuv9qBvBXzEaOqiJXwE1Q/92Nt5ldSLaEtuMOqxv8pdRv7jIFox2mnimFxpGpjpyPqRK5YC1-----END RSA PRIVATE KEY----- (2) 执行命令 openssl req -sha256 -new -key my-private-key.pem -out csr.pem，根据系统提示输入相关配置信息，生成CSR文件。其中，-key my-private-key.pem 用来指定步骤1中生成的私钥文件；-out csr.pem 用来指定CSR文件的名称。 12345678910111213141516171819You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:BeijingLocality Name (eg, city) []:BeijingOrganization Name (eg, company) [Internet Widgits Pty Ltd]:My CompanyOrganizational Unit Name (eg, section) []:.Common Name (e.g. server FQDN or YOUR name) []:www.mycompany.comEmail Address []:example@mycompany.comPlease enter the following 'extra' attributesto be sent with your certificate requestA challenge password []:.An optional company name []:. 查看CSR文件具体内容如下： 12345678910-----BEGIN CERTIFICATE REQUEST-----MIICuzCCAaMCAQAwdjELMAkGA1UEBhMCQ04xEDAOBgNVBAgMB0JlaWppbmcxEDAOBgNVBAcMB0JlaWppbmcxDjAMBgNVBAoMBUppbWNvMQ4wDAYDVQQDDAVKaW1jbzEjMCEGCSqGSIb3DQEJARYUY2FveW91bmdAZm94bWFpbC5jb20wggEiMA0GCSqGSIb3......9Dbyxk5csKIR8BHzOaIndEX37fqbw5EGeSQkfGVpoeJXF39jyobMFlrW6vgywgCe2/8Jnw/oditEdX4c2kY8JzQYHADNoXxG9SR7ZGypd+LeF6utURQk+ol7K1MwzEvXQUsm4FKVeG6ACENqUZrHzwaDAMALxnHz6UHkpoEpmif+exs/cjROmy8w96fmytQvaes433mU7TA9XznzpS28YwBaNDNtBWzgPZ2gTbTY5Q==-----END CERTIFICATE REQUEST----- 执行以上命令时所需填写的内容解释如下表所示： 字段 描述 Country Name 公司/组织所在国家ISO代码，中国代码为CN，其它国家代码可参考ISO Code State or Province Name 公司/组织所在的省/州名称 Locality Name 公司/组织所在城市名称 Organization Name 公司/组织的名称，此处应该出完整全称 Organizational Unit Name 产品或分支机构名称，可选 Common Name 公司/组织的完全限定域名（FQDN，Fully-Qualified Domain Name），例如： www.mycompany.com Email Address 管理员的Email地址 A challenge password 加密证书请求的密码 An optional company name 可选公司/组织名称 (3) 向CA中心提交数字证书认证申请。用户可选择 VeriSign、GeoTrust 等第三方认证机构。 用户也可以执行命令 openssl x509 -req -days 365 -in csr.pem -signkey my-private-key.pem -out my-certificate.pem，对证书进行自签名，用于网站的测试。其中，-days 365 代表证书有效期为365天；-in csr.pem 用来指定步骤2生成CSR文件；-signkey my-private-key.pem 用来指定用于对CSR进行签名的私钥，本示例中使用步骤1生成的私钥进行签名；-out my-certificate.pem 用来指定生成的证书名称。 查看生成的证书文件内容如下： 1234567891011121314-----BEGIN CERTIFICATE-----MIIDaDCCAlACCQCNYeeikeNQ0TANBgkqhkiG9w0BAQUFADB2MQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpamluZzEQMA4GA1UEBwwHQmVpamluZzEOMAwGA1UECgwFSmltY28xDjAMBgNVBAMMBUppbWNvMSMwIQYJKoZIhvcNAQkBFhRjYW95b3VuZ0Bmb3htYWlsLmNvbTAeFw0xNjA5MjkwNjA1NDVaFw0xNzA5MjkwNjA1NDVaMHYxCzAJ......YZZ54dCkVQybjSy8O/tGLi6MDwIDAQABMA0GCSqGSIb3DQEBBQUAA4IBAQAhhOVep1yRWvbiag/ObWtxFuhOpWpvVsrYwlbgusoCfulJUtavD33ZCVzp5/Zg6QdhlDi1XPvmoXfj3HG9tjvyZnAqi8+vyozL6QTCo1mNDGCQyLqwU8b5J0nGe1lpayDF97wLUBQh+685ILSLZA4LnNvsqfVG8CxlJK8nvIWXbW0waMsnglsf1Gj7FcdRFcYeMtSYpniTCET/TtiwDk2+0YTehD8gWiscp/W87sNwpGVKEFD4aGBFTWDG5lYgslJHi/I36j4ov3PyZWKVIFWncxFPAtFFDnu7ZnXUxggXIEvYMKYaDcHwssLSuwAqWvhEClifmvIHZCCc1FYI9bNa-----END CERTIFICATE----- 证书格式要求上传证书前，用户需要确保： 证书（包括：服务器证书、私钥、证书链）格式符合PEM格式要求。如果用户从CA收到的证书不是PEM格式的，需要转换成PEM格式。具体要求如下： 证书以 -----BEGIN CERTIFICATE----- 开头，-----END CERTIFICATE----- 结尾； 每行64字符，最后一行不超过64字符。 如果用户从CA收到的证书不是PEM格式的，需要转换成PEM格式，几种常见的证书格式转换为PEM格式的方法如下： DER -&gt; PEM: 证书：openssl x509 -inform der -in my-certificate.cer -out my-certificate.pem 私钥：openssl rsa -inform DER -outform PEM -in my-private-key.der -out my-private-key.pem P7B -&gt; PEM: 证书：openssl pkcs7 -print_certs -in my-certificate.p7b -out my-certificate.pem 私钥：无私钥 PFX -&gt; PEM: 证书：openssl pkcs12 -in certname.pfx -nokeys -out my-certificate.pem 私钥：openssl pkcs12 -in certname.pfx -nocerts -out my-private-key.pem -nodes 服务器证书需要在有效期内（证书开始时间 &lt;= 当前时间 &lt;= 证书失效时间）。 私钥不能加密，即执行生成私钥命令时不能添加密码参数。 服务器证书只能包含一个证书。 私钥需要和服务器证书里的公钥匹配。可以通过以下两条命令生成私钥和证书的MD5值，如果二者一致，则可认为私钥与证书里的公钥匹配。 openssl x509 -noout -modulus -in my-certificate.pem | openssl md5 openssl rsa -noout -modulus -in my-private-key.pem | openssl md5 证书链完整，即通过证书链可以对应到可信根证书。具体要求如下： 证书之间不能有空行； 每一份证书遵守第一项中关于证书的格式要求，示例如下： 1234567891011-----BEGIN CERTIFICATE----------END CERTIFICATE----------BEGIN CERTIFICATE----------END CERTIFICATE----------BEGIN CERTIFICATE----------END CERTIFICATE-----","tags":[{"name":"https","slug":"https","permalink":"http://zqianduan.com/tags/https/"},{"name":"ssl","slug":"ssl","permalink":"http://zqianduan.com/tags/ssl/"}]},{"title":"Javascript 按位运算解析","date":"2016-04-25T06:28:34.000Z","path":"2016/04/25/js-bit-operation/","text":"1. 按位非 ~对每一个比特位执行非（NOT）操作。NOT a 结果为 a 的反转（即反码）。 12var num = ~4;console.log(a); // -5 解析： 4 的二进制数为 100，补满32位 00000000000000000000000000000100 按位取反 11111111111111111111111111111011 由于32位开头第一个是 1，所以这是一个负数，将二进制转换成负数，需要先反码 00000000000000000000000000000100 之后，再+1 00000000000000000000000000000101 转换成十进制为 5，加上符号变成负数 -5 2. 按位与 &amp;对每对比特位执行与（AND）操作。只有 a 和 b 都是 1 时，a AND b 才是 1。 12var num = 2 &amp; 3;console.log(num); // 2 解析： 2 的二进制数为 10，3 的二进制数为 11，补满 32 位分别为 2 = 00000000000000000000000000000010 3 = 00000000000000000000000000000011 按位 &amp; 运算，结果为 00000000000000000000000000000010 = 2 3. 按位或 |对每一对比特位执行或（OR）操作。如果 a 或 b 为 1，则 a OR b 结果为 1。 12var num = 2 | 3;console.log(num); // 3 解析： 2 的二进制数为 10，3 的二进制数为 11，补满 32 位分别为 2 = 00000000000000000000000000000010 3 = 00000000000000000000000000000011 按位 | 运算，结果为 00000000000000000000000000000011 = 3 4. 按位异或 ^对每一对比特位执行异或（XOR）操作。当 a 和 b 不相同时，a XOR b 的结果为 1。 12var num = 2^3;console.log(num); // 1 解析： 2 的二进制数为 10，3 的二进制数为 11，补满 32 位分别为 2 = 00000000000000000000000000000010 3 = 00000000000000000000000000000011 按位 ^ 运算，结果为 00000000000000000000000000000001 = 1 5. 左移 &lt;&lt;该操作符会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充。 12var num = 2&lt;&lt;1;console.log(num); // 4 解析： 2 的二进制数为 10，补满 32 位 2 = 00000000000000000000000000000010 左移 1 位，结果为 00000000000000000000000000000100 = 4 注意：左移不会影响操作符的符号位，例如将 -2 左移 5 位就是 -64 6. 有符号右移 &gt;&gt;该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。 12var num = 9&gt;&gt;2;console.log(num); // 2 解析： 2 的二进制数为 10，补满 32 位 9 = 00000000000000000000000000001001 右移 2 位，结果为 00000000000000000000000000000010 = 1 相比之下， -9 &gt;&gt; 2 得到 -3，因为符号被保留了： -9 = 11111111111111111111111111110111 右移 2 位，结果为 11111111111111111111111111111101 = -3 7. 无符号右移 &gt;&gt;&gt;该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（注：即便右移 0 个比特，结果也是非负的。） 12var num = 9&gt;&gt;&gt;2;console.log(num); // 2 解析： 对于非负数，有符号右移和无符号右移总是返回相同的结果。例如， 9 &gt;&gt;&gt; 2 得到 2 和 9 &gt;&gt; 2 相同： 但是对于负数却不尽相同。 -9 &gt;&gt;&gt; 2 产生 1073741821 这和 -9 &gt;&gt; 2 不同： -9 = 11111111111111111111111111110111 无符号右移 2 位： 00111111111111111111111111111101 ＝ 1073741821 参考资料 按位操作符 - MDN","tags":[{"name":"运算符","slug":"运算符","permalink":"http://zqianduan.com/tags/运算符/"},{"name":"二进制","slug":"二进制","permalink":"http://zqianduan.com/tags/二进制/"}]},{"title":"常用排序算法","date":"2016-04-07T07:50:43.000Z","path":"2016/04/07/js-sort-algorithm/","text":"快速排序简介：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 实现： 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 方法一function quickSort(array, left, right) &#123; if(Object.prototype.toString.call(array).slice(8, -1) === 'Array' &amp;&amp; typeof left === 'number' &amp;&amp; typeof right === 'number') &#123; if(left &lt; right) &#123; var x = array[right], i = left - 1, temp; for(var j = left; j &lt;= right; j++) &#123; if(array[j] &lt;= x) &#123; i++; temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; quickSort(array, left, i - 1); quickSort(array, i + 1, right); &#125;; &#125; else &#123; return 'array is not an Array or left or right is not a number!'; &#125;&#125; var aaa = [3, 5, 2, 9, 1];quickSort(aaa, 0, aaa.length - 1);console.log(aaa);// 方法二var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for(var i = 0; i &lt; arr.length; i++)&#123; if(arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;; 插入排序简介：插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 实现： 一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 12345678910111213141516171819function insertionSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; &#125; return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125; 二分插入排序简介：二分插入（Binary-insert-sort)排序是一种在直接插入排序算法上进行小改动的排序算法。其与直接插入排序算法最大的区别在于查找插入位置时使用的是二分查找的方式，在速度上有一定提升。 实现： 一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置； 将新元素插入到该位置后； 重复上述两步。 1234567891011121314151617181920212223242526272829function binaryInsertionSort(array) &#123; if(Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; for(var i = 1; i &lt; array.length; i++) &#123; var key = array[i], left = 0, right = i - 1; while(left &lt;= right) &#123; var middle = parseInt((left + right) / 2); if(key &lt; array[middle]) &#123; right = middle - 1; &#125; else &#123; left = middle + 1; &#125; &#125; for(var j = i - 1; j &gt;= left; j--) &#123; array[j + 1] = array[j]; &#125; array[left] = key; &#125; return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125; 冒泡排序简介：冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 实现： 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 方法一function bubbleSort(array) &#123; if(Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; var len = array.length, temp; for(var i = 0; i &lt; len - 1; i++) &#123; for(var j = len - 1; j &gt;= i; j--) &#123; if(array[j] &lt; array[j - 1]) &#123; temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125; &#125; &#125; return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;// 方法二function bubbleSort(array) &#123; if(Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; var len = array.length - 1, temp; for(var i = 0; i &lt; len; i++) &#123; if(array[i] &gt; array[i+1]) &#123; temp = array[i]; array[i] = array[i+1]; array[i+1] = temp; &#125; if(i == len - 1) &#123; i = -1; len--; &#125; &#125; return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125; 选择排序简介：选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 实现： n 个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第 i 趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为 R[1..i-1] 和 R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录 R 交换，使 R[1..i] 和R [i+1..n) 分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1 趟结束，数组有序化了。 12345678910111213141516171819202122function selectionSort(array) &#123; if(Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; var len = array.length, temp; for(var i = 0; i &lt; len - 1; i++) &#123; var min = array[i]; for(var j = i + 1; j &lt; len; j++) &#123; if (array[j] &lt; min) &#123; temp = min; min = array[j]; array[j] = temp; &#125; &#125; array[i] = min; &#125; return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125; 堆排序简介：堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 实现： 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足 R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 方法说明：堆排序 * @param array 待排序数组 */function heapSort(array) &#123; if(Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; // 建堆 var heapSize = array.length, temp; for(var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123; heapify(array, i, heapSize); &#125; // 堆排序 for(var j = heapSize - 1; j &gt;= 1; j--) &#123; temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); &#125; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;/** * 方法说明：维护堆的性质 * @param arr 数组 * @param x 数组下标 * @param len 堆大小 */function heapify(arr, x, len) &#123; if(Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof x === 'number') &#123; var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp; if(l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if(r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; if(largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); &#125; &#125; else &#123; return 'arr is not an Array or x is not a number!'; &#125;&#125; 归并排序简介：归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 实现： 把长度为 n 的输入序列分成两个长度为 n/2 的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 1234567891011121314151617181920212223242526272829303132333435363738function mergeSort(array, p, r) &#123; if(p &lt; r) &#123; var q = Math.floor((p + r) / 2); mergeSort(array, p, q); mergeSort(array, q + 1, r); merge(array, p, q, r); &#125;&#125;function merge(array, p, q, r) &#123; var n1 = q - p + 1, n2 = r - q, left = [], right = [], m = n = 0; for(var i = 0; i &lt; n1; i++) &#123; left[i] = array[p + i]; &#125; for(var j = 0; j &lt; n2; j++) &#123; right[j] = array[q + 1 + j]; &#125; left[n1] = right[n2] = Number.MAX_VALUE; for(var k = p; k &lt;= r; k++) &#123; if(left[m] &lt;= right[n]) &#123; array[k] = left[m]; m++; &#125; else &#123; array[k] = right[n]; n++; &#125; &#125;&#125; 桶排序简介：桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。 实现： 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 方法说明：桶排序 * @param array 数组 * @param num 桶的数量 */function bucketSort(array, num) &#123; if(array.length &lt;= 1) &#123; return array; &#125; var len = array.length, buckets = [], result = [], min = max = array[0], regex = '/^[1-9]+[0-9]*$/', space, n = 0; num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num: 10); for(var i = 1; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min: array[i]; max = max &gt;= array[i] ? max: array[i]; &#125; space = (max - min + 1) / num; for(var j = 0; j &lt; len; j++) &#123; var index = Math.floor((array[j] - min) / space); if(buckets[index]) &#123; // 非空桶，插入排序 var k = buckets[index].length - 1; while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) &#123; buckets[index][k + 1] = buckets[index][k]; k--; &#125; buckets[index][k + 1] = array[j]; &#125; else &#123; // 空桶，初始化 buckets[index] = []; buckets[index].push(array[j]); &#125; &#125; while(n &lt; num) &#123; result = result.concat(buckets[n]); n++; &#125; return result;&#125; 计数排序简介：计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。 实现： 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 1234567891011121314151617181920212223function countingSort(array) &#123; var len = array.length, B = [], C = [], min = max = array[0]; for(var i = 0; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min: array[i]; max = max &gt;= array[i] ? max: array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; &#125; for(var j = min; j &lt; max; j++) &#123; C[j + 1] = (C[j + 1] || 0) + (C[j] || 0); &#125; for(var k = len - 1; k &gt;= 0; k--) &#123; B[C[array[k]] - 1] = array[k]; C[array[k]]--; &#125; return B;&#125;","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zqianduan.com/tags/algorithm/"}]},{"title":"不用中间变量交换两个数值变量的值","date":"2016-04-05T07:39:10.000Z","path":"2016/04/05/js-swap-algorithm/","text":"加减法 12345678var a = 1, b = 2;a = a + b;b = a - b;a = a - b;console.log(a, b); // 2, 1 该方法可以交换整型和浮点型数值的变量，但在处理浮点型的时候有可能出现精度的损失，例如： 12345678var a = 1.123456789, b = 2.987654321;a = a + b;b = a - b;a = a - b;console.log(a, b); // 2.987654321, 1.1234567889999996 乘除法 12345678var a = 3, b = 4;a = a * b;b = a / b;a = a / b;console.log(a, b); // 4, 3 乘除法更像是加减法向乘除运算的映射，它与加减法类似：可以处理整型和浮点型变量，但在处理浮点型变量时也存在精度损失问题。而且乘除法比加减法要多一条约束：b 必不为 0。 异或法 12345678var a = 5, b = 6;a ^= b; // a = a^b;b ^= a; // b = b^a = b^(a^b) = b^a^b = b^b^a = 0^a = a;a ^= b; // a = a^b = (a^b)^a = a^b^a = a^a^b = 0^b = b;console.log(a, b); // 6, 5 异或法可以完成对整型变量的交换，对于浮点型变量它无法完成交换。","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zqianduan.com/tags/algorithm/"}]},{"title":"Javascript 代码片段笔记","date":"2016-03-30T05:55:44.000Z","path":"2016/03/30/js-snippet-code/","text":"千位分隔符123456789101112function commafy(num) &#123; num = num + ''; var reg = /(-?\\d+)(\\d&#123;3&#125;)/; while(reg.test(num)) &#123; num = num.replace(reg, '$1,$2'); &#125; return num;&#125; jQuery 实现简单 Router12345678910111213141516171819202122232425262728293031323334353637(function($) &#123; var pathname = location.pathname; $.route = function() &#123; $.each(arguments, function(index) &#123; var path = this[\"path\"]; var func = this[\"func\"]; if(path &amp;&amp; func) &#123; if(pathname.match(path)) &#123; $(function() &#123; func.apply(this); &#125;); &#125; &#125; &#125;); &#125;;&#125;)(jQuery);// Example$.route( &#123; // always match // http://example.com/foo/bar/baz.html path: /./, func: function() &#123; console.log(\"always match!\"); &#125; &#125;, &#123; // url contains /sample/index.html // http://example.com/foo/bar/sample/index.html path: /\\/sample\\/index\\.html/, func: function() &#123; console.log(\"sample page!\"); &#125; &#125;); 中文输入法截断解决方案1234567891011121314151617// 利用 compositionstart 和 compositionend 来捕获 IME (input method editor) 的启动和关闭事件$('#text').on('input', function(e)&#123; if($(this).prop('comStart')) return; var value = $(this).val(); console.log('当前输入：' + value); // ....&#125;).on('compositionstart', function(e)&#123; $(this).prop('comStart', true); console.log('中文输入，开始');&#125;).on('compositionend', function(e)&#123; $(this).prop('comStart', false); console.log('中文输入，结束');&#125;); jQuery pub/sub 简单实现1234567891011121314151617(function($) &#123; var o = $(&#123;&#125;); $.subscribe = function() &#123; o.on.apply(o, arguments); &#125;; $.unsubscribe = function() &#123; o.off.apply(o, arguments); &#125;; $.publish = function() &#123; o.trigger.apply(o, arguments); &#125;;&#125;(jQuery)); 观察者模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106var eventSplitter = /\\s+/;var Events = &#123; /** * _callback = &#123; * tail: [Object], * next: &#123; * callback: [Function], * context: [Object], * next: &#123; * callback: [Function], * context: [Object], * next: [Object] * &#125; * &#125; * &#125; * * 1. 事件列表最顶层存储了一个 tail 对象，它是最后一次绑定的回调事件的 next 的引用; * 2. evts 允许指定多个事件名，通过空白字符进行分隔(如空格, 制表符等); * 3. 当事件名称为\"all\"时, 在调用 fire 方法触发任何事件时, * 均会调用\"all\"事件中绑定的所有回调函数; */ on: function(evts, callback, context) &#123; var evt, calls, node, tail, list; if(!callback) return this; evts = evts.split(eventSpliter); calls = this._callbacks || (this._callbacks = &#123;&#125;); while(evt = evts.shift()) &#123; list = calls[evt]; node = list ? list.tail : &#123;&#125;; node.next = tail = &#123;&#125;; node.callback = callback; node.context = context; calls[evt] = &#123; tail: tail, next: list ? list.next : node; &#125; &#125; return this; &#125;, off: function(evts, callback, context) &#123; var evt, calls, node, tail, cb, ctx; if(!(calls = this._callbacks)) return this; if(!(evts || callback || context)) &#123; delete this._callbacks; return this; &#125; evts = evts ? evts.split(eventSpliter) : Object.key(calls); while(evt = evts.shift()) &#123; node = calls[evt]; delete calls[evt]; if(!node || !(callback || context)) continue; tail = node.tail; while((node = node.next) !== tail) &#123; cb = node.callback; ctx = node.context; if((callback &amp;&amp; cb !== callback) || (context &amp;&amp; ctx !== context)) &#123; this.on(evt, cb, ctx); &#125; &#125; &#125; return this; &#125;, fire: function(evts) &#123; var evt, node, calls, tail, args, all, rest; if(!(calls = this._callbacks)) return this; all = calls.all; evts = evts.split(eventSpliter); rest = Array.prototype.slice.call(arguments, 1); while(evt = evts.shift()) &#123; if(node = calls[evt]) &#123; tail = node.tail; while((node = node.next) !== tail) &#123; node.callback.apply(node.context || this, rest); &#125; &#125; if(node = all) &#123; tail = node.tail; args = [evt].concat(rest); while((node = node.next) !== tail) &#123; node.callback.apply(node.context || this, args); &#125; &#125; &#125; return this; &#125; &#125; 短小强悍的 Javascript 异步调用库12345678910111213141516171819202122232425262728var queue = function(funcs, scope) &#123; (function next() &#123; if(funcs.length &gt; 0) &#123; funcs.shift().apply(scope, [next].concat(Array.prototype.slice.call(arguments, 0))); &#125; &#125;)();&#125;// Examplevar obj = &#123; value: null &#125;;queue([ function(callback)&#123; var me = this; setTimeout(function()&#123; me.value = 10; callback(20); &#125;); &#125;, function(callback, add)&#123; console.log(this.value + add); callback(); &#125;, function()&#123; console.log(obj.value); &#125;], obj); 干掉鼠标右键菜单1234567891011121314151617181920212223242526function NoRightClick(pid) &#123; // pid: flash's parentNode id var el = document.getElementById(pid); if(el.addEventListener) &#123; el.addEventListener('mousedown',function(event)&#123; if(event.button == 2)&#123; event.stopPropagation(); // for firefox event.preventDefault(); // for chrome &#125; &#125;,true); &#125; else &#123; el.attachEvent('onmousedown', function() &#123; if(event.button == 2) &#123; el.setCapture(); &#125; &#125;); el.attachEvent('onmouseup', function() &#123; el.releaseCapture(); &#125;); el.oncontextmenu = function() &#123; return false; &#125;; &#125;&#125;; 判断是否是素数function isPrime(num) { return n &lt; 2 ? false : !/^(11+?)\\1+$/.test(Array(num+1).join(1)); }","tags":[{"name":"promise","slug":"promise","permalink":"http://zqianduan.com/tags/promise/"},{"name":"router","slug":"router","permalink":"http://zqianduan.com/tags/router/"},{"name":"event","slug":"event","permalink":"http://zqianduan.com/tags/event/"}]},{"title":"Nginx Rewrite 规则","date":"2016-03-24T11:43:20.000Z","path":"2016/03/24/nginx-rewrite-rule/","text":"Nginx Rewrite 是利用 nginx 提供的全局变量或自己设置的变量，结合正则表达式和标志位实现 url 重写以及重定向。rewrite 只能放在 server{}, location{}, if{} 中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 http://seanlook.com/a/we/index.php?id=1&amp;u=str 只对 /a/we/index.php 重写。语法 rewrite regex replacement [flag]; 如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用 proxy_pass 反向代理。 表面看 rewrite 和 location 功能有点像，都能实现跳转，主要区别在于 rewrite 是在同一域名内更改获取资源的路径，而 location 是对一类路径做控制访问或反向代理，可以 proxy_pass 到其他机器。很多情况下 rewrite 也会写在 location 里，它们的执行顺序是： 执行 server 块的 rewrite 指令 执行 location 匹配 执行选定的 location 中的 rewrite 指令 如果其中某步 URI 被重写，则重新循环执行 1-3，直到找到真实存在的文件；循环超过 10 次，则返回 500 Internal Server Error 错误。 flag 标志位 last: 相当于 Apache的[L] 标记，表示完成 rewrite break: 停止执行当前虚拟主机的后续 rewrite 指令集 redirect: 返回 302 临时重定向，地址栏会显示跳转后的地址 permanent: 返回 301 永久重定向，地址栏会显示跳转后的地址 因为 301 和 302 不能简单的只返回状态码，还必须有重定向的 URL，这就是 return 指令无法返回 301, 302 的原因了。这里 last 和 break 区别有点难以理解： last 一般写在 server 和 if 中，而 break 一般使用在 location 中 last 不终止重写后的 url 匹配，即新的 url 会再从 server 走一遍匹配流程，而 break 终止重写后的匹配 break 和 last 都能组织继续执行后面的 rewrite 指令 if 指令与全局变量if判断指令 语法为 if(condition) {...}，对给定的条件 condition 进行判断。如果为真，大括号内的 rewrite 指令将被执行，if 条件(conditon)可以是如下任何内容： 当表达式只是一个变量时，如果值为空或任何以 0 开头的字符串都会当做 false 直接比较变量和内容时，使用 = 或 != ~ 正则表达式匹配，~* 不区分大小写的匹配，!~ 区分大小写的不匹配 -f 和 !-f 用来判断是否存在文件 -d 和 !-d 用来判断是否存在目录 -e 和 !-e 用来判断是否存在文件或目录 -x 和 !-x 用来判断文件是否可执行 栗子： 1234567891011121314151617181920212223242526272829303132333435363738# 如果UA包含\"MSIE\"，rewrite 请求到 /msid/ 目录下if ($http_user_agent ~ MSIE) &#123; rewrite ^(.*)$ /msie/$1 break;&#125; # 如果 cookie 匹配正则，设置变量 $id 等于正则引用部分if ($http_cookie ~* \"id=([^;]+)(?:;|$)\") &#123; set $id $1;&#125;# 如果提交方法为 POST，则返回状态 405（Method not allowed）。return 不能返回 301, 302if ($request_method = POST) &#123; return 405;&#125;# 限速，$slow 可以通过 set 指令设置if ($slow) &#123; limit_rate 10k;&#125; # 如果请求的文件名不存在，则反向代理到 localhost。这里的 break 也是停止 rewrite 检查if (!-f $request_filename)&#123; break; proxy_pass http://127.0.0.1; &#125; # 如果 query string 中包含\"post=140\"，永久重定向到 example.comif ($args ~ post=140)&#123; rewrite ^ http://example.com/ permanent;&#125;# 防盗链location ~* \\.(gif|jpg|png|swf|flv)$ &#123; valid_referers none blocked www.jefflei.com www.leizhenfang.com; if ($invalid_referer) &#123; return 404; &#125;&#125; 全局变量 下面是可以用作if判断的全局变量： $args: #这个变量等于请求行中的参数，同$query_string $content_length: 请求头中的Content-length字段。 $content_type: 请求头中的Content-Type字段。 $document_root: 当前请求在root指令中指定的值。 $host: 请求主机头字段，否则为服务器名称。 $http_user_agent: 客户端agent信息 $http_cookie: 客户端cookie信息 $limit_rate: 这个变量可以限制连接速率。 $request_method: 客户端请求的动作，通常为GET或POST。 $remote_addr: 客户端的IP地址。 $remote_port: 客户端的端口。 $remote_user: 已经经过Auth Basic Module验证的用户名。 $request_filename: 当前请求的文件路径，由root或alias指令与URI请求生成。 $scheme: HTTP方法（如http，https）。 $server_protocol: 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。 $server_addr: 服务器地址，在完成一次系统调用后可以确定这个值。 $server_name: 服务器名称。 $server_port: 请求到达服务器的端口号。 $request_uri: 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。 $uri: 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。 $document_uri: 与$uri相同。 栗子： 12345678# http://localhost:88/test1/test2/test.php$host = localhost$server_port = 88$request_uri = http://localhost:88/test1/test2/test.php$document_uri = /test1/test2/test.php$document_root = /var/www/html$request_filename = /var/www/html/test1/test2/test.php 常用正则 .: 匹配除换行符以外的任意字符 ?: 重复0次或1次 +: 重复1次或更多次 *: 重复0次或更多次 \\d: 匹配数字 ^: 匹配字符串的开始 $: 匹配字符串的介绍 {n}: 重复n次 {n,}: 重复n次或更多次 [c]: 匹配单个字符c [a-z]: 匹配a-z小写字母的任意一个 小括号 () 之间匹配的内容，可以在后面通过 $1 来引用，$2 表示的是前面第二个 () 里的内容。正则里面容易让人困惑的是 \\ 转义特殊字符。 rewrite 实例 WordPress 伪静态 123456789if (-f $request_filename/index.html) &#123; rewrite (.*) $1/index.html break;&#125;if (-f $request_filename/index.php) &#123; rewrite (.*) $1/index.php;&#125;if (!-f $request_filename) &#123; rewrite (.*) /index.php;&#125; PHPCMS 伪静态 123456rewrite ^/caipu-([0-9]+)-([0-9]+)-([0-9]+).html /index.php?m=content&amp;c=index&amp;a=show&amp;catid=$1&amp;id=$2&amp;page=$3 last;rewrite ^/content-([0-9]+)-([0-9]+)-([0-9]+).html /index.php?m=content&amp;c=index&amp;a=show&amp;catid=$1&amp;id=$2&amp;page=$3 last;rewrite ^/list-([0-9]+)-([0-9]+).html /index.php?m=content&amp;c=index&amp;a=lists&amp;catid=$1&amp;page=$2 last;rewrite ^/tag-([^\\.]*)-([0-9]+)-([0-9]+).html /index.php?m=content&amp;c=tag&amp;catid=$2&amp;tag=$1&amp;page=$3 last;rewrite ^/comment-([0-9]+)-([0-9]+)-([0-9]+).html /index.php?m=comment&amp;c=index&amp;a=init&amp;commentid=content_$1-$2-$3 last;rewrite ^/([^\\.]*).html /index.php?m=member&amp;c=index&amp;a=$1 last; DEDECMS 伪静态 1234567rewrite \"^/index.html$\" /index.php last;rewrite \"^/list-([0-9]+)\\.html$\" /plus/list.php?tid=$1 last;rewrite \"^/list-([0-9]+)-([0-9]+)-([0-9]+)\\.html$\" /plus/list.php?tid=$1&amp;totalresult=$2&amp;PageNo=$3 last;rewrite \"^/view-([0-9]+)-1\\.html$\" /plus/view.php?arcID=$1 last;rewrite \"^/view-([0-9]+)-([0-9]+)\\.html$\" /plus/view.php?aid=$1&amp;pageno=$2 last;rewrite \"^/tags.html$\" /tags.php last;rewrite \"^/tag-([0-9]+)-([0-9]+)\\.html$\" /tags.php?/$1/$2/ last; Discuz7 伪静态 12345rewrite ^/archiver/((fid|tid)-[\\w\\-]+\\.html)$ /archiver/index.php?$1 last;rewrite ^/forum-([0-9]+)-([0-9]+)\\.html$ /forumdisplay.php?fid=$1&amp;page=$2 last;rewrite ^/thread-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ /viewthread.php?tid=$1&amp;extra=page\\%3D$3&amp;page=$2 last;rewrite ^/space-(username|uid)-(.+)\\.html$ /space.php?$1=$2 last;rewrite ^/tag-(.+)\\.html$ /tag.php?name=$1 last; DiscuzX 伪静态 12345678910rewrite ^([^\\.]*)/topic-(.+)\\.html$ $1/portal.php?mod=topic&amp;topic=$2 last;rewrite ^([^\\.]*)/article-([0-9]+)-([0-9]+)\\.html$ $1/portal.php?mod=view&amp;aid=$2&amp;page=$3 last;rewrite ^([^\\.]*)/forum-(\\w+)-([0-9]+)\\.html$ $1/forum.php?mod=forumdisplay&amp;fid=$2&amp;page=$3 last;rewrite ^([^\\.]*)/thread-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ $1/forum.php?mod=viewthread&amp;tid=$2&amp;extra=page%3D$4&amp;page=$3 last;rewrite ^([^\\.]*)/group-([0-9]+)-([0-9]+)\\.html$ $1/forum.php?mod=group&amp;fid=$2&amp;page=$3 last;rewrite ^([^\\.]*)/space-(username|uid)-(.+)\\.html$ $1/home.php?mod=space&amp;$2=$3 last;rewrite ^([^\\.]*)/([a-z]+)-(.+)\\.html$ $1/$2.php?rewrite=$3 last;if (!-e $request_filename) &#123; return 404;&#125; PHPWind 伪静态 12rewrite ^(.*)-htm-(.*)$ $1.php?$2 last;rewrite ^(.*)/simple/([a-z0-9\\_]+\\.html)$ $1/simple/index.php?$2 last; SHOPEX 伪静态 123if (!-e $request_filename) &#123; rewrite ^/(.+\\.(html|xml|json|htm|php|jsp|asp|shtml))$ /index.php?$1 last;&#125; Typecho 伪静态 123456789if (-f $request_filename/index.html) &#123; rewrite (.*) $1/index.html break;&#125;if (-f $request_filename/index.php) &#123; rewrite (.*) $1/index.php;&#125;if (!-f $request_filename) &#123; rewrite (.*) /index.php;&#125; Emlog 伪静态 123456789101112131415if (!-f $request_filename) &#123; set $rule_0 1$rule_0;&#125;if (!-d $request_filename) &#123; set $rule_0 2$rule_0;&#125;if ($rule_0 = \"21\") &#123; rewrite ^/(post|record|sort|author|page)-([0-9]+)\\.html(.*)$ /index.php?$1=$2$3; rewrite ^/(post|record|sort|author|page)/([0-9]+)(.*)$ /index.php?$1=$2$3; rewrite ^/tag-(.+)\\.html$ /index.php?tag=$1; rewrite ^/tag/(.+)$ /index.php?tag=$1; rewrite ^/t/page/([0-9]+)$ /t/index.php?page=$1;&#125;","tags":[{"name":"emlog","slug":"emlog","permalink":"http://zqianduan.com/tags/emlog/"},{"name":"typecho","slug":"typecho","permalink":"http://zqianduan.com/tags/typecho/"},{"name":"wordpress","slug":"wordpress","permalink":"http://zqianduan.com/tags/wordpress/"}]},{"title":"前端 MVC 变形记","date":"2016-03-23T14:59:13.000Z","path":"2016/03/23/mvc-deformation/","text":"背景MVC是一种架构设计模式，它通过关注点分离鼓励改进应用程序组织。在过去，MVC被大量用于构建桌面和服务器端应用程序，如今Web应用程序的开发已经越来越向传统应用软件开发靠拢，Web和应用之间的界限也进一步模糊。传统编程语言中的设计模式也在慢慢地融入Web前端开发。由于前端开发的环境特性，在经典MVC模式上也引申出了诸多MV模式，被实现到各个Javascript框架中都有多少的衍变。在研究MV模式和各框架的过程中，却是“剪不断、理还乱”： 为什么每个地方讲的MVC都不太一样？ MVP、MVVM的出现是要解决什么问题？ 为什么有人义正言辞的说“MVC在Web前端开发中根本无法使用”？ 带着十万个为什么去翻阅很多资料，但是看起来像view、model、controller、解耦、监听、通知、主动、被动、注册、绑定、渲染等各种术语的排列组合，像汪峰的歌词似的。本篇希望用通俗易懂的方式阐述清楚一些关系，由于接触时间有限，英文阅读能力有限，可能会存在误解，欢迎讨论和纠正。 MVC变形记MVC历史MVC最初是在研究Smalltalk-80（1979年）期间设计出来的，恐怕没有一本书能够回到计算机石器时代介绍一下Smalltalk的代码是如何实现MVC的，不仅如此，连想搞清楚当时的应用场景都很难了，都要追溯到80后出生以前的事了。但是当时的图形界面少之又少，施乐公司正在研发友好的用户图形界面，以取代电脑屏幕上那些拒人于千里之外的命令行和DOS提示符。那时计算机世界天地混沌，浑然一体，然后出现了一个创世者，将现实世界抽象出模型形成model，将人机交互从应用逻辑中分离形成view，然后就有了空气、水、鸡啊、蛋什么的。在1995年出版的《设计模式：可复用面向对象软件的基础》对MVC进行了深入的阐述，在推广使用方面发挥了重要作用。 MVC包括三类对象，将他们分离以提高灵活性和复用性。 模型model用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法，会有一个或多个视图监听此模型。一旦模型的数据发生变化，模型将通知有关的视图。 视图view是它在屏幕上的表示，描绘的是model的当前状态。当模型的数据发生变化，视图相应地得到刷新自己的机会。 控制器controller定义用户界面对用户输入的响应方式，起到不同层面间的组织作用，用于控制应用程序的流程，它处理用户的行为和数据model上的改变。 实线：方法调用 虚线：事件通知 其中涉及两种设计模式： view和model之间的观察者模式，view观察model，事先在此model上注册，以便view可以了解在数据model上发生的改变。 view和controller之间的策略模式 一个策略是一个表述算法的对象，MVC允许在不改变视图外观的情况下改变视图对用户输入的响应方式。例如，你可能希望改变视图对键盘的响应方式，或希望使用弹出菜单而不是原来的命令键方式。MVC将响应机制封装在controller对象中。存在着一个controller的类层次结构，使得可以方便地对原有的controller做适当改变而创建新的controller。 view使用controller子类的实例来实现一个特定的响应策略。要实现不同的响应的策略只要用不同种类的controller实例替换即可。甚至可以在运行时刻通过改变view的controller来改变用户输入的响应方式。例如，一个view可以被禁止接受任何输入，只需给他一个忽略输入事件的controller。 好吧，如果被上述言论绕昏了，请继续研读《设计模式：可复用面向对象软件的基础》。 MVC for JAVASCRIPT我们回顾了经典的MVC，接下来讲到的MVC主要是在Javascript上的实现。 如图所示，view承接了部分controller的功能，负责处理用户输入，但是不必了解下一步做什么。它依赖于一个controller为她做决定或处理用户事件。事实上，前端的view已经具备了独立处理用户事件的能力，如果每个事件都要流经controller，势必增加复杂性。同时，view也可以委托controller处理model的更改。model数据变化后通知view进行更新，显示给用户。这个过程是一个圆，一个循环的过程。 这种从经典MVC到Javascript MVC的1对1转化，导致控制器的角色有点尴尬。MVC这样的结构的正确性在于，任何界面都需要面对一个用户，而controller “是用户和系统之间的链接”。在经典MVC中，controller要做的事情多数是派发用户输入给不同的view，并且在必要的时候从view中获取用户输入来更改model，而Web以及绝大多数现在的UI系统中，controller的职责已经被系统实现了。由于某种原因，控制器和视图的分界线越来越模糊，也有认为，view启动了action理论上应该把view归属于controller。比如在Backbone中，Backbone.View和Backbone.Router一起承担了controller的责任。这就为MVC中controller的衍变埋下了伏笔。 MVPMVP（model-view-Presenter）是经典MVC设计模式的一种衍生模式，是在1990年代Taligent公司创造的，一个用于C++ CommonPoint的模型。背景上不再考证，直接上图看一下与MVC的不同。 经典MVC中，一对controller-view捆绑起来表示一个ui组件，controller直接接受用户输入，并将输入转为相应命令来调用model的接口，对model的状态进行修改，最后通过观察者模式对view进行重新渲染。 进化为MVP的切入点是修改controller-view的捆绑关系，为了解决controller-view的捆绑关系，将进行改造，使view不仅拥有UI组件的结构，还拥有处理用户事件的能力，这样就能将controller独立出来。为了对用户事件进行统一管理，view只负责将用户产生的事件传递给controller，由controller来统一处理，这样的好处是多个view可共用同一个controller。此时的controller也由组件级别上升到了应用级别，然而更新view的方式仍然与经典MVC一样：通过Presenter更新model，通过观察者模式更新view。 另一个显而易见的不同在于，MVC是一个圆，一个循环的过程，但MVP不是，依赖Presenter作为核心，负责从model中拿数据，填充到view中。常见的MVP的实现是被动视图(passive view),Presenter观察model，不再是view观察model，一旦model发生变化，就会更新view。Presenter有效地绑定了model到view。view暴露了setters接口以便Presenter可以设置数据。对于这种被动视图的结构，没有直接数据绑定的概念。但是他的好处是在view和model直接提供更清晰的分离。但是由于缺乏数据绑定支持，意味着不得不单独关注某个任务。在MVP里，应用程序的逻辑主要在Presenter来实现，其中的view是很薄的一层。 MVVMMVVM，Model-View-ViewModel，最初是由微软在使用Windows Presentation Foundation和SilverLight时定义的，2005年John Grossman在一篇关于Avalon（WPF 的代号）的博客文章中正式宣布了它的存在。如果你用过Visual Studio, 新建一个WPF Application，然后在“设计”中拖进去一个控件、双击后在“代码”中写事件处理函数、或者绑定数据源。就对这个MVVM有点感觉了。比如VS自动生成的如下代码： 123456789101112&lt;GroupBox Header=\"绑定对象\"&gt; &lt;StackPanel Orientation=\"Horizontal\" Name=\"stackPanel1\"&gt; &lt;TextBlock Text=\"学号:\"/&gt; &lt;TextBlock Text=\"&#123;Binding Path=StudentID&#125;\"/&gt; &lt;TextBlock Text=\"姓名:\"/&gt; &lt;TextBlock Text=\"&#123;Binding Path=Name&#125;\"/&gt; &lt;TextBlock Text=\"入学日期:\"/&gt; &lt;TextBlock Text=\"&#123;Binding Path=EntryDate, StringFormat=yyyy-MM-dd&#125;\"/&gt; &lt;TextBlock Text=\"学分:\"/&gt; &lt;TextBlock Text=\"&#123;Binding Path=Credit&#125;\"/&gt; &lt;/StackPanel&gt;&lt;/GroupBox&gt; 123456stackPanel1.DataContext = new Student() &#123; StudentID=20130501, Name=\"张三\", EntryDate=DateTime.Parse(\"2013-09-01\"), Credit=0.0&#125;; 其中最重要的特性之一就是数据绑定，Data-binding。没有前后端分离，一个开发人员全搞定，一只手抓业务逻辑、一只手抓数据访问，顺带手拖放几个UI控件，绑定数据源到某个对象或某张表，一步到位。 背景介绍完毕，再来看一下理论图 首先，view和model是不知道彼此存在的，同MVP一样，将view和model清晰地分离开来。 其次，view是对viewmodel的外在显示，与viewmodel保持同步，viewmodel对象可以看作是view的上下文。view绑定到viewmodel的属性上，如果viewmodel中的属性值变化了，这些新值通过数据绑定会自动传递给view。反过来viewmodel会暴露model中的数据和特定状态给view。 所以，view不知道model的存在，viewmodel和model也觉察不到view。事实上，model也完全忽略viewmodel和view的存在。这是一个非常松散耦合的设计。 流行的MV*框架：每个框架都有自己的特性，这里主要讨论MVC三个角色的责任。粗浅地过一遍每个框架的代码结构和风格。 BackboneJSBackbone通过提供模型Model、集合Collection、视图View赋予了Web应用程序分层结构，其中模型包含领域数据和自定义事件；集合Colection是模型的有序或无序集合，带有丰富的可枚举API； 视图可以声明事件处理函数。最终将模型、集合、视图与服务端的RESTful JSON接口连接。 Backbone在升级的过程中，去掉了controller，由view和router代替controller，view集中处理了用户事件（如click，keypress等）、渲染HTML模板、与模型数据的交互。Backbone的model没有与UI视图数据绑定，而是需要在view中自行操作DOM来更新或读取UI数据。Router为客户端路由提供了许多方法，并能连接到指定的动作（actions）和事件（events）。 Backbone是一个小巧灵活的库，只是帮你实现一个MVC模式的框架，更多的还需要自己去实现。适合有一定Web基础，喜欢原生JS去操作DOM（因为没有数据绑定）的开发人员。为什么称它为库，而不是框架，不仅仅是由于仅4KB的代码，更重要的是 使用一个库，你有控制权。如果用一个框架，控制权就反转了，变成框架在控制你。库能够给予灵活和自由，但是框架强制使用某种方式，减少重复代码。这便是Backbone与Angular的区别之一了。 至于Backbone属于MV*中的哪种模式，有人认为不是MVC，有人觉得更接近于MVP，事实上，它借用多个架构模式中一些很好的概念，创建一个运行良好的灵活框架。不必拘泥于某种模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// view:var Appview = Backbone.View.extend(&#123; // 每个view都需要一个指向DOM元素的引用，就像ER中的main属性。 el: '#container', // view中不包含html标记，有一个链接到模板的引用。 template: _.template(\"&lt;h3&gt;Hello &lt;%= who %&gt;&lt;/h3&gt;\"), // 初始化方法 initialize: function()&#123; this.render(); &#125;, // $el是一个已经缓存的jQuery对象 render: function()&#123; this.$el.html(\"Hello World\"); &#125;, // 事件绑定 events: &#123;'keypress #new-todo': 'createTodoOnEnter'&#125;&#125;);var appview = new Appview();// model:// 每个应用程序的核心、包含了交互数据和逻辑// 如数据验证、getter、setter、默认值、数据初始化、数据转换var app = &#123;&#125;;app.Todo = Backbone.model.extend(&#123; defaults: &#123; title: '', completed: false &#125;&#125;);// 创建一个model实例var todo = new app.Todo(&#123;title: 'Learn Backbone.js', completed: false&#125;);todo.get('title'); // \"Learn Backbone.js\"todo.get('completed'); // falsetodo.get('created_at'); // undefinedtodo.set('created_at', Date());todo.get('created_at'); // \"Wed Sep 12 2012 12:51:17 GMT-0400 (EDT)\"// collection：// model的有序集合，可以设置或获取model// 监听集合中的数据变化，从后端获取模型数据、持久化。app.TodoList = Backbone.Collection.extend(&#123; model: app.Todo, localStorage: new Store(\"backbone-todo\")&#125;);// collection实例var todoList = new app.TodoList()todoList.create(&#123;title: 'Learn Backbone\\'s Collection'&#125;);// model实例var model = new app.Todo(&#123;title: 'Learn models', completed: true&#125;);todoList.add(model);todoList.pluck('title');todoList.pluck('completed'); KnockoutJSKnockoutJS是一个名正言顺的MVVM框架，通过简洁易读的data-bind语法，将DOM元素与viewmodel关联起来。当模型（viewmodel）状态更新时，自动更新UI界面。 viewmodel是model和view上的操作的一个连接，是一个纯粹的Javascript对象。它不是UI，没有控件和样式的概念，它也不是持久化的模型数据，它只是hold住一些用户正在编辑的数据，然后暴露出操作这些数据（增加或删除）的方法。 view是对viewmodel中数据的一个可视化的显示，view观察viewmodel，操作view时会发送命令到viewmodel，并且当viewmodel变化时更新。view和model是不了解彼此的存在的。 1234567&lt;form data-bind=\"submit: addItem\"&gt; New item: &lt;input data-bind='value: itemToAdd, valueUpdate: \"afterkeydown\"' /&gt; &lt;button type=\"submit\" data-bind=\"enable: itemToAdd().length &gt; 0\"&gt;Add&lt;/button&gt; &lt;p&gt;Your items:&lt;/p&gt; &lt;select multiple=\"multiple\" width=\"50\" data-bind=\"options: items\"&gt; &lt;/select&gt;&lt;/form&gt; 12345678910111213141516// viewmodelvar SimpleListmodel = function(items) &#123; this.items = ko.observableArray(items); this.itemToAdd = ko.observable(\"\"); this.addItem = function() &#123; if (this.itemToAdd() != \"\") &#123; // 把input中的值加入到items，会自动更新select控件 this.items.push(this.itemToAdd()); // 清空input中的值 this.itemToAdd(\"\"); &#125; // 确保这里的this一直是viewmodel &#125;.bind(this);&#125;;ko.applyBindings(new SimpleListmodel([\"Alpha\", \"Beta\", \"Gamma\"])); AngularJSAngularJS试图成为Web应用中的一种端对端的解决方案。这意味着它不只是你的Web应用中的一个小部分，而是一个完整的端对端的解决方案。这会让AngularJS在构建一个CRUD的应用时看起来很呆板，缺乏灵活性。AngularJS是为了克服HTML在构建应用上的不足而设计的。使用了不同的方法，它尝试去补足HTML本身在构建应用方面的缺陷。通过使用标识符(directives)的结构，让浏览器能够识别新的语法。例如使用双大括号语法进行数据绑定；使用ng-controller指定每个控制器负责监视视图中的哪一部分；使用ng-model，把输入数据绑定到模型中的一部分属性上。 双向数据绑定是AngularJS的另一个特性。UI控件的任何更改会立即反映到模型变量（一个方向），模型变量的任何更改都会立即反映到问候语文本中（另一方向）。AngularJS通过作用域来保持数据模型与视图界面UI的双向同步。一旦模型状态发生改变，AngularJS会立即刷新反映在视图界面中，反之亦然。 AngularJS原本是倾向于MVC，但是随着项目重构和版本升级，现在更接近MVVM。和Knockout view中的风格类似，都像从WPF衍变过来的，只是Knockout使用了自定义属性data-bind作为绑定入口，而AngularJS对于HTML的变革更彻底，扩展HTML的语法，引入一系列的指令。 在AngularJS中，一个视图是模型通过HTML模板渲染之后的映射。这意味着，不论模型什么时候发生变化，AngularJS会实时更新结合点，随之更新视图。比如，视图组件被AngularJS用下面这个模板构建出来： 12345678&lt;body ng-controller=\"PhoneListCtrl\"&gt; &lt;ul&gt; &lt;li ng-repeat=\"phone in phones\"&gt; &#123;&#123;phone.name&#125;&#125; &lt;p&gt;&#123;&#123;phone.snippet&#125;&#125;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 在li标签里面的ng-repeat语句是一个AngularJS迭代器。包裹在phone.name和phone.snippet周围的花括号标识着数据绑定，是对应用一个数据模型的引用。当页面加载的时候，AngularJS会根据模版中的属性值，将其与数据模型中相同名字的变量绑定在一起，以确保两者的同步性。 在PhoneListCtrl控制器里面初始化了数据模型： 123456789101112// controller:function PhoneListCtrl($scope) &#123; // 数组中存储的对象是手机数据列表 $scope.phones = [ &#123;\"name\": \"Nexus S\", \"snippet\": \"Fast just got faster with Nexus S.\"&#125;, &#123;\"name\": \"Motorola XOOM™ with Wi-Fi\", \"snippet\": \"The Next, Next Generation tablet.\"&#125;, &#123;\"name\": \"MOTOROLA XOOM™\", \"snippet\": \"The Next, Next Generation tablet.\"&#125; ];&#125; 尽管控制器看起来并没有什么控制的作用，但是它在这里的重要性在于，通过给定数据模型的作用域$scope，允许建立模型和视图之间的数据绑定。方法名PhoneListCtrl和body标签里面的ngcontroller指令的值相匹配。当应用启动之后，会有一个根作用域被创建出来，而控制器的作用域是根作用域的一个典型后继。这个控制器的作用域对所有标记内部的数据绑定有效。 AngularJS的作用域理论非常重要：一个作用域可以视作模板、模型和控制器协同工作的粘接器。AngularJS使用作用域，同时还有模板中的信息，数据模型和控制器。这些可以帮助模型和视图分离，但是他们两者确实是同步的！任何对于模型的更改都会即时反映在视图上；任何在视图上的更改都会被立刻体现在模型中。 实践中的思考我们使用的MVC框架是ER，适用于并能很方便地构建一个整站式的AJAX Web应用。提供精简、核心的action、model和view的抽象，使得构建RIA应用变得简单可行。在使用的过程中近距离地体会到非常多方面的优秀的设计理念。也让我开始思考各个角色的转型。 让view上前线我开始思考action（controller）这个角色。我觉得从纯粹地解耦角度来说，view和model应该是互相不知道彼此存在的，所有的事件流和对数据、UI的处理应该都流经action。但是这一点又极不现实。用户操作了一个UI，需要更新model的一个数据，就要fire到action，通过action来调用model的set方法。这样又有点麻烦，因为view中有对model的应用，可以一句代码搞定这一个数据的设置。所以，我自己设置了一个规则：如果是简单的模型数据读写可以直接在view中操作；如果要经过复杂的数据处理，必须流经action。于是，我遇到了一种怎么都偷不了懒（必须经过action）的情况： 比如有个主action main，两个子action list、select，用户在list中的view选择一条数据添加到右侧select中。那走过的流程是这样的： 子Action中的listView接受UI事件，fire到listAction中 listAction继续将事件fire到mainView中，由主action来处理另外子Action的事情。 mainView接收到事件、调用子Action selectAction的方法 selectAction继续调用selectView的方法来完成UI的更新。 其中涉及的model的变化暂时不考虑。我在想，view既然把经典MVC中的controller接受用户事件的角色承接过来的，那如果借鉴Backbone的思想，把view作为controller的一个实现，推到战场的最前线。省掉两次action的中转传递，是不是更简单。 model驱动开发实际开发中，常常会以view为核心，页面上需要展示什么数据，就去model中设置数据源。发生了用户事件，我会在action中更新model，然后刷新view。有时候会遗漏更新model，直到需要数据时才发现没有保存到model中。 model本身是独立的，自控制的，不依赖于view，能够同步支持多view的显示。就像linux上的应用程序通常会提供图形界面和命令行两种操作方式一样。那如果以model为核心，model驱动开发，数据在手、天下我有，以模型验证保证数据的完整性和正确性。实现数据绑定，任何对模型的更改都会在界面上反映出来。那我们只要预先写好view和model的关系映射（类似viewmodel），然后只关注模型数据，就OK了。 对于MV家族，都是在经典MVC基础上随着时代的发展、应用环境的变化衍变出来的。实现MV模式的这些框架到底归属于哪种模式，也不必泥古。MV是一个很有争议性的话题，能够构建一个健壮、具有良好设计、遵从关注点分离的项目比花时间去争论到底是MV更有意义。 本文转载自：http://efe.baidu.com/blog/mvc-deformation/","tags":[{"name":"angular","slug":"angular","permalink":"http://zqianduan.com/tags/angular/"},{"name":"mvvm","slug":"mvvm","permalink":"http://zqianduan.com/tags/mvvm/"}]},{"title":"前端优秀文章导航","date":"2016-03-22T13:07:31.000Z","path":"2016/03/22/front-end-excellent-article-navigate/","text":"Javascript 解析 Facebook 的 Flux 应用架构 有趣的 HTML5：离线存储 了解 JavaScript 应用程序中的内存泄漏 由NPM引发的关于 left-pad 的那些事儿 JavaScript 基于时间的动画算法 JavaScript单线程和浏览器事件循环简述 Sizzle选择器引擎原理分析 HTML5视频的那些事儿 前端动画原理与实现 【深入浅出jQuery】源码浅析–整体架构 【深入浅出jQuery】源码浅析2–奇技淫巧 从本质认识JavaScript的原型继承和类继承 3 种不同的原型继承： ES6+ 版本 Angular系列文章之angular路由 常用排序算法之JavaScript实现 JavaScript排序算法之归并排序 数组的完全随机排列 检查素数的正则表达式 九种浏览器端缓存机制知多少 作为前端应当了解的Web缓存知识 Vue.js：轻量高效的前端组件化方案 移动前端—图片压缩上传实践 深入浅出 - vue之深入响应式原理 JavaScript 创建对象: 方法一览与最佳实践 HTML5 手势检测原理和实现 从零开始编写自己的JavaScript框架 React中一个没人能解释清楚的问题——为什么要使用Virtual DOM 构建流式应用—RxJS详解 Redux 与异步数据逻辑封装 ES 5 新增特性汇总 ES 6 新特性汇总（一图全览） ECMAScript 6 规范总结 CSS 深入理解 CSS3 弹性盒布局模型 移动端高清、多屏适配方案 手机淘宝的flexible设计与实现 移动web适配之rem 使用 PostCSS 进行 CSS 处理 Retina 屏幕下的 1px 边框 构建工具 NPM 的 package.json 中文文档 Webpack 前端构建集成方案 使用 webpack + react + redux + es6 开发组件化前端项目 开发者手册 DevDocs JavaScript 秘密花园 RESTful API 设计指南 前端开发面试题 jQuery 基本原理 ECMAScript 6入门 JavaScript 标准参考教程（alpha） CSS参考手册 Backbone.js(1.1.2) API中文文档 MDN JavaScript 指南 ECMAScript 6 入门 ECMAScript 6规范总结 Redux 中文文档 Linux基础 Linux命令大全 大前端 2016年JavaScript技术栈展望 你可能不知道的font 新版卖家中心 Bigpipe 实践（一） 新版卖家中心 Bigpipe 实践（二） 现代浏览器的工作原理 京东资深前端架构师分享前端工程化在电商首页中的实践 HTTPS科普扫盲帖 三种解密 HTTPS 流量的方法介绍 HTTP2.0,SPDY,HTTPS你应该知道的一些事 HTTP2 Server Push的研究 关于启用 HTTPS 的经验分享 TCP的三次握手(建立连接）和四次挥手(关闭连接） 理解 TCP 和 UDP 超全面的移动端尺寸基础知识科普 无线性能优化：Composite PHP 资源列表 web前端图片极限优化策略 Google Developer 图片优化 如果有人问你数据库的原理，叫他看这篇文章 MySQL索引原理及慢查询优化 MySQL开发实践8问，你能hold住几个？","tags":[{"name":"css","slug":"css","permalink":"http://zqianduan.com/tags/css/"},{"name":"javascript","slug":"javascript","permalink":"http://zqianduan.com/tags/javascript/"}]},{"title":"-webkit-text-size-adjust 使用说明","date":"2016-03-19T10:30:31.000Z","path":"2016/03/19/text-size-adjust/","text":"-webkit-text-size-adjust 是为了保持网页字体大小的一个属性，因为有些网页的字体缩小以后，难以识别，并且也严重影响到用户体验，如果在全局定义了 html { -webkit-text-size-adjust: none; } 会导致另一个现象：浏览器一般提供给小群体用户一个功能，就是放大与缩小网页视图。禁用了这一属性，在 chrome 下放大网页，会导致其它元素均放大，而文字却依然为原定义的 12px。 这样造成了不友好的体验，给有需要的用户造成阅读上的门槛。故有需要设置小于 12px 字体的元素单个定义即可，但是，这个被定义的小元素，将令浏览器的缩放功能失效。 -webkit-text-size-adjust 的使用Chrome 浏览器在第27版本中正式取消了 -webkit-text-size-adjust 属性，可能就是因为有人设置这样的属性导致网页无法缩放，而用户却认为是浏览器坏了，这可真是鱼和熊掌不可兼得。 虽然这样取消了，但是还是有人在用，Chrome 下由于启用了缩放，所以字符间距出现问题，影响了美观；Firefox 下完美；Opera 能够识别 -webkit- 前缀（而且在检查元素时还抹掉了前缀），但又能够显示 12px 以下的字号，结果变成了 12×0.75。 所以对于 Opera 浏览器需要多定义一个规则： 12345.webkit &#123; font-size: 9px; -webkit-transform: scale(0.75); -o-transform: scale(1);&#125; -webkit-text-size-adjust 的注意事项 当样式表里 font-size&lt;12px 时，中文版 chrome 浏览器里字体显示仍为 12px，这时可以用 html { -webkit-text-size-adjust: none; } -webkit-text-size-adjust 放在 body 上会导致页面缩放失效 body 会继承定义在 html 的样式 用 -webkit-text-size-adjust 不要定义成可继承的或全局的","tags":[{"name":"css","slug":"css","permalink":"http://zqianduan.com/tags/css/"}]},{"title":"Web 消息推送及 WebSocket 简介","date":"2016-03-17T03:07:48.000Z","path":"2016/03/17/websocket-introduction/","text":"Web 的交互过程Web 应用典型的信息交互过程通常是：客户端通过浏览器发出一个请求，服务端接收请求后进行处理并返回结果给客户端，然后客户端浏览器将信息呈现出来。 这种机制对于信息交互不是特别频繁的应用尚能相安无事，但是对于那些实时要求比较高的应用来说（比如在线游戏），当客户端浏览器准备呈现获取到的信息的时候，这些信息在服务器端可能已经过时，所以，保持客户端和服务器端的信息同步是实时 Web 应用的关键要素。 在 WebSocket 规范出来之前，开发人员想实现这种应用，不得不采用一些折中的方案，其中最常用的就是轮询（Polling）和 Comet（轮询的改进版本，又可细分为长轮询机制与流技术）技术。这几种方案基本都是在用 Ajax 来模拟实时的效果，服务器与客户端编程都比较复杂，而且效率不高。 Web 消息推送的技术 轮询（polling）：Ajax 隔一段时间就去服务器查询是否有改变，从而进行增量式的更新。但是间隔多长时间去查询成了问题，因为性能和即时性造成了严重的反比关系。间隔太短，连续不断的请求会冲垮服务器，间隔太长，务器上的新数据就需要越多的时间才能到达客户机。 优点：服务端逻辑简单； 缺点：其中大多数请求可能是无效请求，在大量用户轮询很频繁的情况下对服务器的压力很大； 应用：并发用户量少，而且要求消息的实时性不高，一般很少采用； 长轮询（long-polling）：客户端向服务器发送 Ajax 请求，服务器接到请求后 hold 住连接，直到有新消息或超时（设置）才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。 优点：实时性高，无消息的情况下不会进行频繁的请求； 缺点：服务器维持着连接期间会消耗资源； 基于 iframe 及 htmlfile 的流（streaming）方式：iframe 流方式是在页面中插入一个隐藏的 iframe，利用其 src 属性在服务器和客户端之间创建一条长链接，服务器向 iframe 传输数据（通常是 HTML，内有负责插入信息的 javascript），来实时更新页面。 优点：消息能够实时到达； 缺点：服务器维持着长连接期会消耗资源； 插件提供 socket 方式：比如利用 Flash XMLSocket，Java Applet 套接口，Activex 包装的 socket。 优点：原生 socket 的支持，和 PC 端和移动端的实现方式相似； 缺点：浏览器端需要装相应的插件； WebSocket：是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 优点：更好的节省服务器资源和带宽并达到实时通讯； 缺点：目前还未普及，浏览器支持不好； HTML5 WebSocket 设计出来的目的就是要取代轮询和 Comet 技术，使客户端浏览器具备像 C/S 架构下桌面系统的实时通讯能力。浏览器向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。因为 WebSocket 连接本质上就是一个 TCP 连接，所以在数据传输的稳定性和数据传输量的大小方面，和轮询以及 Comet 技术比较，具有很大的性能优势。 WebSocket 协议WebSocket 协议本质上是一个基于 TCP 协议。为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息 ”Upgrade: WebSocket” 表明这是一个申请协议升级的 HTTP 请求(详细的 WebSocket 消息的内容这里就不详细说了，基本和 HTTP 的差不多，而且都是由 WebSocket 对象自动发送和接收的，对用户透明)，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。 WebSocket API 最伟大之处在于服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息。WebSocket 并不限于以 Ajax (或 XmlHttpRequest)方式通信，因为 Ajax 技术需要客户端发起请求，而 WebSocket 服务器和客户端可以彼此相互推送信息；XmlHttpRequest 通信受到域的限制，而 WebSocket 允许跨域通信。 需要注意的问题是，除了安全和性能以外，服务端只管往 socket 里面写数据就可以了，WebSocket 的通信数据全部是以 ”\\x00″ 开头以 ”\\xFF” 结尾的，无论是服务端发出的数据还是客户端发送的数据都遵从这个格式，唯一不同的是客户端的 WebSocket 对象能够自动将头尾去除，获得主体数据，这就省却了在客户端处理原始数据的必要，而且 WebSocket 通信的消息总是 UTF-8 格式的。 参考资料： WebSocket Comet：基于 HTTP 长连接的“服务器推”技术 WEB消息推送框架","tags":[{"name":"server","slug":"server","permalink":"http://zqianduan.com/tags/server/"},{"name":"socket.io","slug":"socket-io","permalink":"http://zqianduan.com/tags/socket-io/"},{"name":"comet","slug":"comet","permalink":"http://zqianduan.com/tags/comet/"}]},{"title":"前端开发者不得不知的 ES6 十大特性","date":"2016-03-15T05:30:52.000Z","path":"2016/03/15/es6-front-end-developers-will-have-to-know/","text":"ES6（ECMAScript2015）的出现，无疑给前端开发人员带来了新的惊喜，它包含了一些很棒的新特性，可以更加方便的实现很多复杂的操作，提高开发人员的效率。 本文主要针对 ES6 做一个简要介绍。 主要译自：http://webapplog.com/ES6/comment-page-1/。也许你还不知道 ES6 是什么, 实际上, 它是一种新的 javascript 规范。在这个大家都很忙碌的时代，如果你想对 ES6 有一个快速的了解，那么请继续往下读，去了解当今最流行的编程语言 JavaScript 最新一代的十大特性。 以下是 ES6 排名前十的最佳特性列表（排名不分先后）： Default Parameters（默认参数） in ES6 Template Literals （模板文本）in ES6 Multi-line Strings （多行字符串）in ES6 Destructuring Assignment （解构赋值）in ES6 Enhanced Object Literals （增强的对象文本）in ES6 Arrow Functions （箭头函数）in ES6 Promises in ES6 Block-Scoped Constructs Let and Const（块作用域构造Let and Const） Classes（类） in ES6 Modules（模块） in ES6 声明：这些列表仅是个人主观意见。它绝不是为了削弱 ES6 其它功能，这里只列出了10条比较常用的特性。 首先回顾一下 JavaScript 的历史，不清楚历史的人，很难理解 JavaScript 为什么会这样发展。下面就是一个简单的 JavaScript 发展时间轴： 1995：JavaScript 诞生，它的初始名叫 LiveScript。 1997：ECMAScript 标准确立。 1999：ES3 出现，与此同时 IE5 风靡一时。 2000–2005： XMLHttpRequest 又名 AJAX， 在 Outlook Web Access (2000)、Oddpost (2002)，Gmail (2004)和Google Maps (2005) 大受重用。 2009： ES5出现，（就是我们大多数人现在使用的）例如 foreach，Object.keys，Object.create 和 JSON 标准。 2015：ES6/ECMAScript2015 出现。 历史回顾就先到此，现让我们进入正题。 1. Default Parameters（默认参数）in ES6还记得我们以前不得不通过下面方式来定义默认参数： 123456var link = function (height, color, url) &#123; var height = height || 50; var color = color || 'red'; var url = url || 'http://azat.co'; // ...&#125; 一切工作都是正常的，直到参数值是 0 后，就有问题了，因为在 JavaScript 中，0 表示 false，它是默认被 hard-coded 的值，而不能变成参数本身的值。当然，如果你非要用 0 作为值，我们可以忽略这一缺陷并且使用逻辑 OR 就行了！但在 ES6，我们可以直接把默认值放在函数申明里： 123var link = function(height = 50, color = 'red', url = 'http://azat.co') &#123; // ...&#125; 顺便说一句，这个语法类似于 Ruby！ 2. Template Literals（模板对象）in ES6在其它语言中，使用模板和插入值是在字符串里面输出变量的一种方式。因此，在 ES5，我们可以这样组合一个字符串： 12var name = 'Your name is ' + first + ' ' + last + '.';var url = 'http://localhost:3000/api/messages/' + id; 幸运的是，在 ES6 中，我们可以使用新的语法 ${NAME}，并把它放在反引号里： 12var name = `Your name is $&#123;first&#125; $&#123;last&#125;. `;var url = `http://localhost:3000/api/messages/$&#123;id&#125;`; 3. Multi-line Strings（多行字符串）in ES6ES6 的多行字符串是一个非常实用的功能。在 ES5 中，我们不得不使用以下方法来表示多行字符串： 1234567var roadPoem = 'Then took the other, as just as fair,nt' + 'And having perhaps the better claimnt' + 'Because it was grassy and wanted wear,nt' + 'Though as for that the passing therent' + 'Had worn them really about the same,nt';var fourAgreements = 'You have the right to be you.n You can only be you when you do your best.'; 然而在 ES6 中，仅仅用反引号就可以解决了： 1234567var roadPoem = `Then took the other, as just as fair, And having perhaps the better claim Because it was grassy and wanted wear, Though as for that the passing there Had worn them really about the same,`;var fourAgreements = `You have the right to be you. You can only be you when you do your best.`; 4. Destructuring Assignment（解构赋值）in ES6解构可能是一个比较难以掌握的概念。先从一个简单的赋值讲起，其中 house 和 mouse 是 key，同时 house 和 mouse 也是一个变量，在 ES5 中是这样： 123var data = $('body').data(), // data has properties house and mouse house = data.house, mouse = data.mouse; 以及在 node.js 中用 ES5 是这样： 1234var jsonMiddleware = require('body-parser').jsonMiddleware;var body = req.body, // body has username and password username = body.username, password = body.password; 在 ES6，我们可以使用这些语句代替上面的 ES5 代码： 123var &#123; house, mouse &#125; = $('body').data(); // we'll get house and mouse variablesvar &#123; jsonMiddleware &#125; = require('body-parser');var &#123; username, password &#125; = req.body; 这个同样也适用于数组，非常赞的用法： 12var [col1, col2] = $('.column'), [line1, line2, line3, , line5] = file.split('n'); 我们可能需要一些时间来习惯解构赋值语法的使用，但是它确实能给我们带来许多意外的收获。 5. Enhanced Object Literals（增强的对象字面量）in ES6使用对象文本可以做许多让人意想不到的事情！通过 ES6，我们可以把 ES5 中的 JSON 变得更加接近于一个类。 下面是一个典型 ES5 对象文本，里面有一些方法和属性： 123456789101112var serviceBase = &#123; port: 3000, url: 'azat.co' &#125;, getAccounts = function() &#123; return [1,2,3] &#125;;var accountServiceES5 = &#123; port: serviceBase.port, url: serviceBase.url, getAccounts: getAccounts, toString: function() &#123; return JSON.stringify(this.valueOf()); &#125;, getUrl: function() &#123; return \"http://\" + this.url + ':' + this.port &#125;, valueOf_1_2_3: getAccounts() &#125; 如果我们想让它更有意思，我们可以用 Object.create 从 serviceBase 继承原型的方法： 123456789var accountServiceES5ObjectCreate = Object.create(serviceBase)var accountServiceES5ObjectCreate = &#123; getAccounts: getAccounts, toString: function() &#123; return JSON.stringify(this.valueOf()); &#125;, getUrl: function() &#123; return \"http://\" + this.url + ':' + this.port &#125;, valueOf_1_2_3: getAccounts() &#125; 我们知道，accountServiceES5ObjectCreate 和 accountServiceES5 并不是完全一致的，因为一个对象 (accountServiceES5) 在 proto 对象中将有下面这些属性： 为了方便举例，我们将考虑它们的相似处。所以在 ES6 的对象文本中，既可以直接分配 getAccounts: getAccounts,也可以只需用一个 getAccounts，此外，我们在这里通过 proto（并不是通过’proto’）设置属性，如下所示： 12345var serviceBase = &#123; port: 3000, url: 'azat.co' &#125;, getAccounts = function()&#123; return [1, 2, 3] &#125;;var accountService = &#123; __proto__: serviceBase, getAccounts, 另外，我们可以调用 super 防范，以及使用动态 key 值 (valueOf_1_2_3): 1234567 toString() &#123; return JSON.stringify((super.valueOf())); &#125;, getUrl: function() &#123; return \"http://\" + this.url + ':' + this.port &#125;, [ 'valueOf_' + getAccounts().join('_') ]: getAccounts()&#125;;console.log(accountService) ES6 对象文本是一个很大的进步对于旧版的对象文本来说。 6. Arrow Functions in（箭头函数）ES6这是我迫不及待想讲的一个特征，CoffeeScript 就是因为它丰富的箭头函数让很多开发者喜爱。在 ES6 中，也有了丰富的箭头函数。这些丰富的箭头是令人惊讶的因为它们将使许多操作变成现实，比如： 以前我们使用闭包，this 总是预期之外地产生改变，而箭头函数的迷人之处在于，现在你的 this 可以按照你的预期使用了，身处箭头函数里面，this 还是原来的 this。 有了箭头函数在 ES6 中， 我们就不必用 that = this 或 self = this 或 _this = this 或 .bind(this)。例如，下面的代码用 ES5 就不是很优雅： 1234var _this = this;$('.btn').click(function(event) &#123; _this.sendData();&#125;) 在 ES6 中就不需要用 _this = this： 123$('.btn').click((event) =&gt; &#123; this.sendData();&#125;) 不幸的是，ES6 委员会决定，以前的 function 的传递方式也是一个很好的方案，所以它们仍然保留了以前的功能。下面这是一个另外的例子，我们通过 call 传递文本给 logUpperCase() 函数在 ES5 中： 12345678910var logUpperCase = function() &#123; var _this = this; this.string = this.string.toUpperCase(); return function () &#123; return console.log(_this.string); &#125; &#125; logUpperCase.call(&#123; string: 'ES6 rocks' &#125;)(); 而在 ES6，我们并不需要用 _this 浪费时间： 12345var logUpperCase = function() &#123; this.string = this.string.toUpperCase(); return () =&gt; console.log(this.string); &#125; logUpperCase.call(&#123; string: 'ES6 rocks' &#125;)(); 请注意，只要你愿意，在 ES6 中 =&gt; 可以混合和匹配老的函数一起使用。当在一行代码中用了箭头函数，它就变成了一个表达式。它将暗地里返回单个语句的结果。如果你超过了一行，将需要明确使用 return。 这是用 ES5 代码创建一个消息数组： 1234var ids = ['5632953c4e345e145fdf2df8', '563295464e345e145fdf2df9'];var messages = ids.map(function(value) &#123; return \"ID is \" + value; // explicit return &#125;); 用 ES6 是这样： 12var ids = ['5632953c4e345e145fdf2df8', '563295464e345e145fdf2df9'];var messages = ids.map(value =&gt; `ID is $&#123;value&#125;`); // implicit return 请注意，这里用了字符串模板。 在箭头函数中，对于单个参数，括号()是可选的，但当你超过一个参数的时候你就需要他们。 在ES5代码有明确的返回功能： 1234var ids = ['5632953c4e345e145fdf2df8', '563295464e345e145fdf2df9'];var messages = ids.map(function(value, index, list) &#123; return 'ID of ' + index + ' element is ' + value + ' '; // explicit return &#125;); 在 ES6 中有更加严谨的版本，参数需要被包含在括号里并且它是隐式的返回： 12var ids = ['5632953c4e345e145fdf2df8', '563295464e345e145fdf2df9'];var messages = ids.map((value, index, list) =&gt; `ID of $&#123;index&#125; element is $&#123;value&#125; `); // implicit return 7. Promises in ES6Promises 是一个有争议的话题。因此有许多略微不同的 promise 实现语法。Q，bluebird，deferred.js，vow, avow, jquery 一些可以列出名字的。也有人说我们不需要 promises，仅仅使用异步，生成器，回调等就够了。但令人高兴的是，在 ES6 中有标准的 Promise 实现。 下面是一个简单的用 setTimeout() 实现的异步延迟加载函数: 123setTimeout(function() &#123; console.log('Yay!');&#125;, 1000); 在 ES6 中，我们可以用 promise 重写: 123456var wait1000 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 1000); &#125;) .then(function() &#123; console.log('Yay!'); &#125;); 或者用 ES6 的箭头函数： 123456var wait1000 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000); &#125;) .then(() =&gt; &#123; console.log('Yay!'); &#125;); 到目前为止，代码的行数从三行增加到五行，并没有任何明显的好处。确实，如果我们有更多的嵌套逻辑在 setTimeout() 回调函数中，我们将发现更多好处： 123456setTimeout(function() &#123; console.log('Yay!'); setTimeout(function() &#123; console.log('Wheeyee!'); &#125;, 1000)&#125;, 1000); 在 ES6 中我们可以用 promises 重写： 12345678910var wait1000 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000) &#125;);wait1000() .then(function() &#123; console.log('Yay!') return wait1000() &#125;) .then(function() &#123; console.log('Wheeyee!') &#125;); 还是不确信 Promises 比普通回调更好？其实我也不确信，我认为一旦你有回调的想法，那么就没有必要额外增加 promises 的复杂性。 虽然，ES6 有让人崇拜的 Promises，Promises 是一个有利有弊的回调但是确实是一个好的特性，更多详细的信息关于 promise: Introduction to ES6 Promises. 8. Block-Scoped Constructs Let and Const（块作用域和构造 let 和 const）在 ES6 代码中，你可能已经看到那熟悉的身影 let。在 ES6 里 let 并不是一个花俏的特性，它是更复杂的。Let 是一种新的变量申明方式，它允许你把变量作用域控制在块级里面。我们用大括号定义代码块，在 ES5 中，块级作用域起不了任何作用： 123456789101112131415function calculateTotalAmount(vip) &#123; var amount = 0; if(vip) &#123; var amount = 1; &#125; &#123; // more crazy blocks! var amount = 100; &#123; var amount = 1000; &#125; &#125; return amount;&#125;console.log(calculateTotalAmount(true)); 结果将返回 1000，这真是一个 bug。在 ES6 中，我们用 let 限制块级作用域。而 var 是限制函数作用域。 123456789101112131415function calculateTotalAmount (vip) &#123; var amount = 0; // probably should also be let, but you can mix var and let if(vip) &#123; let amount = 1; // first amount is still 0 &#125; &#123; // more crazy blocks! let amount = 100; // first amount is still 0 &#123; let amount = 1000; // first amount is still 0 &#125; &#125; return amount;&#125; console.log(calculateTotalAmount(true)); 这个结果将会是0，因为块作用域中有了let。如果（amount=1）.那么这个表达式将返回1。谈到 const，就更加容易了；它就是一个不变量，也是块级作用域就像 let 一样。下面是一个演示，这里有一堆常量，它们互不影响，因为它们属于不同的块级作用域: 123456789101112131415function calculateTotalAmount (vip) &#123; const amount = 0; if(vip) &#123; const amount = 1; &#125; &#123; // more crazy blocks! const amount = 100 ; &#123; const amount = 1000; &#125; &#125; return amount;&#125;console.log(calculateTotalAmount(true)); 从我个人看来，let 和 const 使这个语言变复杂了。没有它们的话，我们只需考虑一种方式，现在有许多种场景需要考虑。 9. Classes（类）in ES6如果你喜欢面向对象编程（OOP），那么你将喜爱这个特性。以后写一个类和继承将变得跟在 facebook 上写一个评论那么容易。 类的创建和使用真是一件令人头疼的事情在过去的 ES5 中，因为没有一个关键字 class （它被保留，但是什么也不能做）。在此之上，大量的继承模型像 pseudo classical, classical, functional 更加增加了混乱，JavaScript 之间的宗教战争只会更加火上浇油。 用 ES5 写一个类，有很多种方法，这里就先不说了。现在就来看看如何用 ES6 写一个类吧。ES6 没有用函数, 而是使用原型实现类。我们创建一个类 baseModel ，并且在这个类里定义了一个 constructor 和一个 getName() 方法： 12345678910111213class baseModel &#123; constructor(options, data) &#123; // class constructor，node.js5.6 暂时不支持 options = &#123;&#125;, data = [] 这样传参 this.name = 'Base'; this.url = 'http://azat.co/api'; this.data = data; this.options = options; &#125; getName() &#123; // class method console.log(`Class name: $&#123;this.name&#125;`); &#125;&#125; 注意我们对 options 和 data 使用了默认参数值。此外方法名也不需要加 function 关键字，而且冒号(:)也不需要了。另外一个大的区别就是你不需要分配属性 this。现在设置一个属性的值，只需简单的在构造函数中分配。 AccountModel 从类 baseModel 中继承而来: 12class AccountModel extends baseModel &#123; constructor(options, data) &#123; 为了调用父级构造函数，可以毫不费力的唤起 super() 用参数传递： 12345 // call the parent method with super super(&#123;private: true&#125;, ['32113123123', '524214691']); this.name = 'Account Model'; this.url +='/accounts/';&#125; 如果你想做些更好玩的，你可以把 accountData 设置成一个属性： 12345 get accountsData() &#123; //calculated attribute getter // ... make XHR return this.data; &#125;&#125; 那么，你如何调用他们呢？它是非常容易的： 123let accounts = new AccountModel(5);accounts.getName();console.log('Data is %s', accounts.accountsData); 结果令人惊讶，输出是： 12Class name: Account ModelData is 32113123123,524214691 10. Modules（模块）in ES6众所周知，在 ES6 以前 JavaScript 并不支持本地的模块。人们想出了 AMD，RequireJS，CommonJS 以及其它解决方法。现在 ES6 中可以用模块 import 和 export 操作了。 在 ES5 中，你可以在 &lt;script&gt; 中直接写可以运行的代码（简称 IIFE），或者一些库像 AMD。然而在 ES6 中，你可以用export 导入你的类。下面举个例子，在 ES5 中，module.js 有 port 变量和 getAccounts 方法: 123456module.exports = &#123; port: 3000, getAccounts: function() &#123; // ... &#125;&#125; 在 ES5 中，main.js 需要依赖 require(‘module’) 导入 module.js： 12var service = require('module.js');console.log(service.port); // 3000 但在 ES6 中，我们将用 export and import。例如，这是我们用 ES6 写的 module.js 文件库： 1234export var port = 3000;export function getAccounts(url) &#123; // ...&#125; 如果用 ES6 来导入到文件 main.js 中，我们需用 import {name} from ‘my-module’ 语法，例如： 12import &#123;port, getAccounts&#125; from 'module';console.log(port); // 3000 或者我们可以在 main.js 中把整个模块导入, 并命名为 service： 12import * as service from 'module';console.log(service.port); // 3000 从我个人角度来说，我觉得 ES6 模块是让人困惑的。但可以肯定的事，它们使语言更加灵活了。 并不是所有的浏览器都支持 ES6 模块，所以你需要使用一些像 jspm 去支持 ES6 模块。 更多的信息和例子关于 ES6 模块，请看 this text。不管怎样，请写模块化的 JavaScript。 如何使用 ES6(Babel)ES6 已经敲定，但并不是所有的浏览器都完全支持，详见：http://kangax.github.io/compat-table/es6/。要使用 ES6，需要一个编译器例如：babel。你可以把它作为一个独立的工具使用，也可以把它放在构建中。grunt，gulp 和 webpack 中都有可以支持 babel 的插件。 这是一个gulp案列，安装gulp-babel插件： 1$ npm install --save-dev gulp-babel 在 gulpfile.js 中，定义一个任务 build，放入 src/app.js，并且编译它进入构建文件中。 12345678var gulp = require('gulp'), babel = require('gulp-babel');gulp.task('build', function() &#123; return gulp.src('src/app.js') .pipe(babel()) .pipe(gulp.dest('build'));&#125;) Node.js and ES6在 nodejs 中，你可以用构建工具或者独立的 Babel 模块 babel-core 来编译你的 Node.js 文件。安装如下： 1$ npm install --save-dev babel-core 然后在 node.js 中，你可以调用这个函数： 1require(\"babel-core\").transform(ES5Code, options); ES6 总结这里还有许多 ES6 的其它特性你可能会使用到，排名不分先后： 全新的Math, Number, String, Array 和 Object 方法 二进制和八进制数据类型 默认参数不定参数扩展运算符 Symbols符号 tail调用 Generators (生成器) New data structures like Map and Set(新的数据构造对像 MAP 和 set) 参考文献： ES6 Cheatsheet (FREE PDF) http://webapplog.com/ES6/comment-page-1/ Understanding ECMAScript 6 by Nicolas Zakas book http://ES6-features.org/#DateTimeFormatting IIFE：立刻运行的函数表达式 本文转载自 AlloyTeam：http://www.alloyteam.com/2016/03/es6-front-end-developers-will-have-to-know-the-top-ten-properties/","tags":[{"name":"es6","slug":"es6","permalink":"http://zqianduan.com/tags/es6/"},{"name":"promise","slug":"promise","permalink":"http://zqianduan.com/tags/promise/"}]},{"title":"前端性能优化总结","date":"2016-03-14T07:56:35.000Z","path":"2016/03/14/front-end-optimization/","text":"优化方向 优化手段 请求数量 合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 请求带宽 开启GZip，精简JavaScript，移除重复脚本，图像优化 缓存利用 使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 页面结构 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 代码校验 避免CSS表达式，避免重定向 参考资料： 雅虎14条性能优化原则 前端工程精粹（一）：静态资源版本更新与缓存 前端工程精粹（二）：静态资源管理与模板框架","tags":[{"name":"gzip","slug":"gzip","permalink":"http://zqianduan.com/tags/gzip/"},{"name":"uglify","slug":"uglify","permalink":"http://zqianduan.com/tags/uglify/"}]},{"title":"SASS优化响应式断点管理","date":"2016-03-13T04:33:27.000Z","path":"2016/03/13/sass-responsive-breakpoints/","text":"当你需要搞定响应式布局时，一堆堆的媒体查询、大量的属性、属性值往往可以把你搞颠，SASS（或者诸如此类的预处理器）被认为是处理响应式断点的最佳利器。 说到响应式断点处理，很多种方式涌上心头，经常有人问哪种方式最优，正如前端开发领域的大多数问题一样，这个问题同样没有标准答案，我们需要具体问题具体分析。更确切的说，难度不在于提出一个系统，而是提出一个既足够灵活（适用大部分场合）又不非常复杂的系统。 在今天的文章里，我将给大家介绍若干种响应式布局断点的解决方案，每一种都经过实践验证，一些方案可能优于其他方案，我会把决定的权利交给大家。 1. 使用变量(With variables)Bootstrap 和 Foundation 采用这种方式，首先定义变量，然后在媒体查询中使用变量。换句话说，你可以在配置文件或者其他地方定义变量以备使用。我们来看看 Bootstrap 怎么干的。 123456789101112131415// Defining values$screen-sm-min: 768px;$screen-xs-max: ($screen-sm-min - 1);$screen-md-min: 992px;$screen-sm-max: ($screen-md-min - 1);$screen-lg-min: 1200px;$screen-md-max: ($screen-lg-min - 1);// Usage@media (max-width: $screen-xs-max) &#123; ... &#125;@media (min-width: $screen-sm-min) &#123; ... &#125;@media (max-width: $screen-sm-max) &#123; ... &#125;@media (min-width: $screen-md-min) &#123; ... &#125;@media (max-width: $screen-md-max) &#123; ... &#125;@media (min-width: $screen-lg-min) &#123; ... &#125; Foudation 更进一步，使用跨范围的媒体查询，避免使用过多的 max-width 和 min-width 123456789101112131415161718192021222324252627282930313233// Defining values$small-range: (0em, 40em); /* 0, 640px */$medium-range: (40.063em, 64em); /* 641px, 1024px */$large-range: (64.063em, 90em); /* 1025px, 1440px */$xlarge-range: (90.063em, 120em); /* 1441px, 1920px */$xxlarge-range: (120.063em); /* 1921px */ // Defining media queries$screen: &quot;only screen&quot; !default;$landscape: &quot;#&#123;$screen&#125; and (orientation: landscape)&quot; !default;$portrait: &quot;#&#123;$screen&#125; and (orientation: portrait)&quot; !default;$small-up: $screen !default;$small-only: &quot;#&#123;$screen&#125; and (max-width: #&#123;upper-bound($small-range)&#125;)&quot; !default;$medium-up: &quot;#&#123;$screen&#125; and (min-width:#&#123;lower-bound($medium-range)&#125;)&quot; !default;$medium-only: &quot;#&#123;$screen&#125; and (min-width:#&#123;lower-bound($medium-range)&#125;) and (max-width:#&#123;upper-bound($medium-range)&#125;)&quot; !default;$large-up: &quot;#&#123;$screen&#125; and (min-width:#&#123;lower-bound($large-range)&#125;)&quot; !default;$large-only: &quot;#&#123;$screen&#125; and (min-width:#&#123;lower-bound($large-range)&#125;) and (max-width:#&#123;upper-bound($large-range)&#125;)&quot; !default;$xlarge-up: &quot;#&#123;$screen&#125; and (min-width:#&#123;lower-bound($xlarge-range)&#125;)&quot; !default;$xlarge-only: &quot;#&#123;$screen&#125; and (min-width:#&#123;lower-bound($xlarge-range)&#125;) and (max-width:#&#123;upper-bound($xlarge-range)&#125;)&quot; !default;$xxlarge-up: &quot;#&#123;$screen&#125; and (min-width:#&#123;lower-bound($xxlarge-range)&#125;)&quot; !default;$xxlarge-only: &quot;#&#123;$screen&#125; and (min-width:#&#123;lower-bound($xxlarge-range)&#125;) and (max-width:#&#123;upper-bound($xxlarge-range)&#125;)&quot; !default; // Usage@media #&#123;$small-up&#125; &#123; ... &#125;@media #&#123;$small-only&#125; &#123; ... &#125;@media #&#123;$medium-up&#125; &#123; ... &#125;@media #&#123;$medium-only&#125; &#123; ... &#125;@media #&#123;$large-up&#125; &#123; ... &#125;@media #&#123;$large-only&#125; &#123; ... &#125;@media #&#123;$xlarge-up&#125; &#123; ... &#125;@media #&#123;$xlarge-only&#125; &#123; ... &#125;@media #&#123;$xxlarge-up&#125; &#123; ... &#125;@media #&#123;$xxlarge-only&#125; &#123; ... &#125; 两种方法各有一个不爽的地方，在 Bootstrap 里每次都要使用 max-width，在 Foundation 里我们需要使用插值变量这种又丑又烦的方式，我们需要想办法解决这些问题。 2. 使用独立 Mixin(With a standalone mixin)《media queries in Sass 3.2》是 CSS-Tricks 里最火的文章之一，在这篇文章里 Chris Coyier 在借鉴 a former idea by Mason Wendell 和 a former idea by Jeff Croft 两文的基础上，如何使用 sass 实现响应式布局的断点管理。 命名断点是非常重要的，因为可以为抽象的数字赋予意义（你知道767px是什么意思吗，我不知道，直到我去使用小屏幕的时候才知道）。为什么 Bootstrap 和 Foundation 要使用变量呢，不也是为了给抽象的数字起个名字吗？ 所以我们定义个 mixin，接收断点名作唯一的参数，返回媒体查询的内容。准备好了吗？走起。 1234567891011121314151617@mixin respond-to($breakpoint) &#123; @if $breakpoint == &quot;small&quot; &#123; @media (min-width: 767px) &#123; @content; &#125; &#125; @else if $breakpoint == &quot;medium&quot; &#123; @media (min-width: 992px) &#123; @content; &#125; &#125; @else if $breakpoint == &quot;large&quot; &#123; @media (min-width: 1200px) &#123; @content; &#125; &#125;&#125; 然后，我们这样使用 mixin： 123@include respond-to(small) &#123; ... &#125;@include respond-to(medium) &#123; ... &#125;@include respond-to(large) &#123; ... &#125; 这个方法是极好的（甄嬛体，老外也看？），原因有二：抽象数据有意义，大量断点集中管理。如果你想把“992px”改成“970px”，你不需要爬过每一个 css 文件，而只需更新 mixin，然后全部更新。 但是也还有两个问题： 断点不容易从mixin里拿出来，放到配置文件里去 冗余太多 3. 可配置的mixin(With a configurable mixin)为了解决上面的两个问题，我们需要从断点 mixin 中抽出一个列表，只剩下 mixin 核心，然后这个列表就可以随便移动，或者扔到配置文件中。然后，使用 sass 3.3+ 中的 maps，我们可以方便的使用关联的属性和属性值。 12345$breakpoints: ( &apos;small&apos; : 767px, &apos;medium&apos; : 992px, &apos;large&apos; : 1200px); 然后原来的 mixin 进行相应的修改： 123456789101112131415161718@mixin respond-to($breakpoint) &#123; // Retrieves the value from the key $value: map-get($breakpoints, $breakpoint); // If the key exists in the map @if $value != null &#123; // Prints a media query based on the value @media (min-width: $value) &#123; @content; &#125; &#125; // If the key doesn&apos;t exist in the map @else &#123; @warn &quot;Unfortunately, no value could be retrieved from `#&#123;$breakpoint&#125;`. &quot; + &quot;Please make sure it is defined in `$breakpoints` map.&quot;; &#125;&#125; 我们在修改 mixin 的同时也进行了一些提高，不要小看这些提高，我们加上了错误处理，如果在 maps 中没有找到断点值，将会弹出一个错误提示，这将便于我们开发过程中的调试。 我们让 mixin 变得更加精简，能很好的处理错误，同时我们去掉了一个功能——判断属性是否是你想要的（min-width, max-width, min-height等），这在移动优先的网页中没问题，因为我们仅仅需要 min-width。但是，如果需要查询其他属性，我们需要把这个功能加回来。为了达到这个目的，我想到了一个非常优雅的解决方案，同时并不增加复杂性。 123456789101112131415161718192021$breakpoints: ( &apos;small&apos; : ( min-width: 767px ), &apos;medium&apos; : ( min-width: 992px ), &apos;large&apos; : ( min-width: 1200px )); @mixin respond-to($name) &#123; // If the key exists in the map @if map-has-key($breakpoints, $name) &#123; // Prints a media query based on the value @media #&#123;inspect(map-get($breakpoints, $name))&#125; &#123; @content; &#125; &#125; // If the key doesn&apos;t exist in the map @else &#123; @warn &quot;Unfortunately, no value could be retrieved from `#&#123;$breakpoint&#125;`. &quot; + &quot;Please make sure it is defined in `$breakpoints` map.&quot;; &#125;&#125; 在这里，我们主要做了三个事情 检查查询的断点在map中存在不存在 如果存在，打印对应的媒体查询。 如果不在，进行错误提示。 简单吧，如果我们回顾前面的两个缺陷，已经不再有 WET(Write Everything Twice) 问题，也不再有不灵活的媒体查询。但是还有一个问题，不支持复杂的媒体查询。复杂指的是涉及多个组件的查询（e.g. screen and (min-width: 767px)）。我们上面这些方案除了第一种变量之外都不能很好的解决这个问题。 4. 使用外部工具(With an external tool)最后一个同样重要的是，如果不想创建自己的 mixin，你可以使用外部的工具处理响应式布局的断点，有很多 sass 的扩展在这个方面做得很好。 SassMQ by Kaelig Breakpoint by Mason Wendell and Sam Richard Breakup by Ben Scott SassMQ Breakpoint Breakup MQ type *-width any any No Query fallback yep yep yep API complexity simple very simple medium Code complexity very simple complexe simple Extra Debug mode Singularity.gs — 基本上是这样，如果发现有没有涉及的，记得一定告诉我。 SassMQ 12345678910111213141516// Configuration$mq-responsive: true;$mq-static-breakpoint: desktop;$mq-breakpoints: ( mobile: 320px, tablet: 740px, desktop: 980px, wide: 1300px); // Exampleselector &#123; @include mq($from: mobile) &#123; property: value; &#125;&#125; BreakPoints 12345678910$high-tide: 500px;$ex-presidents: 600px 800px;$surfboard-width: max-width 1000px;$surfboard-height: (min-height 1000px) (orientation portrait); selector &#123; @include breakpoint($high-tide) &#123; property: value; &#125;&#125; Breakup 1234567891011$breakup-breakpoints: ( &apos;thin&apos; &apos;(max-width: 35.999em)&apos;, &apos;wide&apos; &apos;(min-width: 36em)&apos;, &apos;full&apos; &apos;(min-width: 61em)&apos;); selector &#123; @include breakup-block(&apos;thin&apos;) &#123; property: value; &#125;&#125; 5. 总结我们在这篇文章里看到的这么些个方案，都有长有短，没有一个完美的方案。最后我觉得还是由你来决定怎么把握可用性和复杂性的平衡。 一句话，在合适的场合使用合适的工具。 本文转载自：http://blog.csdn.net/whqet/article/details/26564287原文：《Managing Responsive Breakpoints with Sass》作者：Hugo Giraudel，来自法国，著名 SASS 大牛，在 SassWay 等多个网站撰文推广 sass，是 SassyJSON、SassyMatrix 等多个开源项目的开发者，大家可以到他的官方网站、github 上了解详情。翻译：前端开发whqet，以意译为主，不当之处请大家批评指正。","tags":[{"name":"css","slug":"css","permalink":"http://zqianduan.com/tags/css/"},{"name":"media","slug":"media","permalink":"http://zqianduan.com/tags/media/"}]},{"title":"BigPipe 学习研究","date":"2016-03-12T05:02:10.000Z","path":"2016/03/12/an-introduction-to-bigpipe/","text":"1. 技术背景：FaceBook 页面加载技术试想这样一个场景，一个经常访问的网站，每次打开它的页面都要要花费 6 秒；同时另外一个网站提供了相似的服务，但响应时间只需 3 秒，那么你会如何选择呢？数据表明，如果用户打开一个网站，等待 3~4 秒还没有任何反应，他们会变得急躁，焦虑，抱怨，甚至关闭网页并且不再访问，这是非常糟糕的情况。所以，网页加载的速度十分重要,尤其对于拥有遍布全球的 5 亿用户的 Facebook(全球最大的社交服务网站)这样的大型网站，有着大量并发请求、海量数据等客观情况，速度就成了必须攻克的难题之一。 2010 年初的时候，Facebook 的前端性能研究小组开始了他们的优化项目，经过了六个月的努力，成功的将个人空间主页面加载耗时由原来的 5 秒减少为现在的 2.5 秒。这是一个非常了不起的成就，也给用户来带来了很好的体验。在优化项目中，工程师提出了一种新的页面加载技术，称之为 Bigpipe。目前淘宝和 Facebook 面临的问题非常相似：海量数据和页面过大，如果可以在详情页、列表页中使用 bigpipe，或者在 webx 中集成 bigpipe，将会带来明显的页面加载速度提升。 2. 相关介绍 2.1 网站前端优化的重要性 《高性能网站建设指南》一书中指出，只有10%~20%的最终用户响应时间是花费在从Web 服务器获取HTML 文档并传送到浏览器中的。如果希望能够有效地减少页面的响应时间，就必须关注剩余的80%~90%的最终用户体验。做个比较，如果对后台业务逻辑进行优化，效率提高了50%，但最终的页面响应时间只减少了5%~10%，因为它所占的比重较少。如果对前端进行性能优化，效率提升50%，则会使最终页面响应时间减少40%~45%。这是多么可观的数字！另外，前端的性能优化一般比业务逻辑的优化更加容易。所以，前端优化投入小，见效快，性价比极高，需要投入更多的关注。 2.2 BigPipe与AJAX Web2.0 的重要特征是网页显示大量动态内容，即 web2.0 注重网页与用户的交互。其核心技术是 AJAX，如今所有主流网站都或多或少使用 AJAX。与 AJAX 类似，BigPipe 实现了分块儿的概念，使页面能够分步输出，即每次输出一部分网页内容。接下来讨论 BigPipe 与 AJAX 的区别。 简单的说，BigPipe 比AJAX 有三个好处： AJAX 的核心是XMLHttpRequest，客户端需要异步的向服务器端发送请求，然后将传送过来的内容动态添加到网页上。如此实现存在一些缺陷，即发送往返请求需要耗费时间，而BigPipe 技术使浏览器并不需要发送XMLHttpRequest 请求，这样就节省时间损耗。 使用AJAX时，浏览器和服务器的工作顺序执行。服务器必须等待浏览器的请求，这样就会造成服务器的空闲。浏览器工作时，服务器在等待，而服务器工作时，浏览器在等待，这也是一种性能的浪费。使用BigPipe，浏览器和服务器可以并行同时工作，服务器不需要等待浏览器的请求，而是一直处于加载页面内容的工作阶段，这就会使效率得到更大的提高。 减少浏览器发送到请求。对一个5亿用户的网站来说，减少了使用AJAX额外带来的请求，会减少服务器的负载，同样会带来很大的性能提升。 基于以上三点，Facebook 在进行页面优化时采用了BigPipe 技术。目前淘宝主搜索结果页中，需要加载类目，相关搜索，宝贝列表，广告等内容，前端这里使用php 的curl 的批处理来并发的访问引擎获取相应的数据，并进行分步输出。这种模式还是与bigpipe有些不同，这点后面会讲到。一般来讲，在页面比较大，而且比较复杂，样式表和脚本比较多的情况下，使用BigPipe 来优化输出页面是比较合适的。另外非常重要的一点，BigPipe 并不改变浏览器的结构与网络协议，仅使用JS就可以实现，用户不需要做任何的设置，就会看到明显的访问时间缩短。 3. 目前的问题接下来讨论现有的瓶颈。面对网页越来越大的情况，尤其是大量的css 文件和js 文件需要加载，传统的页面加载模型很难满足这样的需求，直接结果就是页面加载速度变慢，这绝不是我们希望看到的。目前的技术实现中，用户提出页面访问请求后，页面的完整加载流程如下： 用户访问网页，浏览器发送一个HTTP 请求到网络服务器 服务器解析这个请求，然后从存储层去数据，接着生成一个html 文件内容，并在一个HTTP Response 中把它传送给客户端 HTTP response 在网络中传输 浏览器解析这个Response ，创建一个DOM 树，然后下载所需的CSS 和JS文件 下载完CSS 文件后，浏览器解析他们并且应用在相应的内容上 下载完JS 后，浏览器解析和执行他们 完整流程见图1，图中左侧表示服务器，右侧表示浏览器。浏览器先发送请求，然后服务器进行查找数据，生成页面，返回html 代码，最后浏览器进行渲染页面。这种模式有非常明显的缺陷：流程中的操作有着严格的顺序，如果前面的一个操作没有执行结束，后面的操作就不能执行，即操作之间是不能重叠。这样就造成性能的瓶颈：服务器生成一个页面的内容时，浏览器是空闲的，显示空白内容；而当浏览器加载渲染页面内容时，服务器又是空闲的，时间与性能的浪费由此产生。 考虑图2 中现有的服务模型，横轴表示花费的时间。黄色表示在服务器的生成页面内容的时间，白色表示网络传输时间，蓝色表示在浏览器渲染页面的时间。可以看出，现有的模式造成很大的时间浪费。 考虑图3 中的情况，图中绿色表示服务器从春储层取查数据花费的时间，在海量数据下，当执行一条很费时的查询语句时（如下图右侧），服务器就就阻塞在那 里没有其他操作，而浏览器更是得不到任何反馈。这会造成非常不友好的用户体验，用户不知道什么原因使他们等待很长时间。 4. BigPipe思想与原理面对上述问题，我们看下 BigPipe 的解决办法。BigPipe 提出分块的概念，即根据页面内容位置的不同，将整个页面分成不同的块儿 – 称为 pagelet。该技术的设计者 Changhao Jiang 是研究电子电路的博士，可能从微机上得到了启发，将众多 pagelet 加载的不同阶段像流水线一样在浏览器和服务器上执行，这样就做到了浏览器和服务器的并行化，从而达到重叠服务器端运行时间和浏览器端运行时间的目的。使用 BigPipe 不仅可以节省时间，使加载的时间缩短，而且可以同过 pagelet 的分步输出，使一部分的页面内容更快的输出，从而获得更好的用户体验。BigPipe 中，用户提出页面访问请求后，页面的完整加载流程如下: Request parsing：服务器解析和检查http request Datafetching：服务器从存储层获取数据 Markup generation：服务器生成html 标记 Network transport ： 网络传输response CSS downloading：浏览器下载CSS DOM tree construction and CSS styling:浏览器生成DOM 树，并且使用CSS JavaScript downloading: 浏览器下载页面引用的JS 文件 JavaScript execution: 浏览器执行页面JS代码 这 8 个流程几乎与上文中提到现有的模式没有区别，但这整个流程只是一个 pagelet 的完整流程，而多个 pagelet 的不同操作阶段就可以像流水线一样进行执行了。 图4 中，可以看出 BigPipe 对原有的模式进行的改进。浏览器发送访问请求，然后浏览器分步返回不同的 pagelet 的内容，具体实现将在后面介绍.考虑图5中的改进，BigPipe 打破了原有的顺序执行，将页面分成不同的 pagelet ，如此一来，所有的 pagelet 的执行时间累加起来还是原有的时间。但是， 通过叠加不同 pagelet 的不同阶段的执行时间，使总的运行时间大大减少，这就是 Bigpipe 减少页面加载时间的秘密。 FaceBook的页面被分成了很多不同的pagelets，如图： 5. BigPipe实现原理了解了 BigPipe 的核心思想后，我们讨论它的实现原理。当浏览器访问服务器时，服务器接受请求并对其进行检查。如果请求有效，服务器端不做任何的查询，而是立刻返回一个 http request 给浏览器，内容是一段 html 代码，包括 html 标签和 标签的一部分。 标签包括 BigPipe 的 js 文件和 css 文件，这个 js 文件用来解析后面接收的 http response，因为后面传输的内容都为 js 脚本。未封闭的 标签中，是显示页面的逻辑结构和 pagelet 的占位符的模板，例如： 123456789101112131415&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt; &lt;div&gt; &lt;div id=\"hotnews\"&gt;&lt;/div&gt; &lt;div id=\"societynews\"&gt;&lt;/div&gt; &lt;div id=\"financialnews\"&gt;&lt;/div&gt; &lt;div id=\"ITnews\"&gt;&lt;/div&gt; &lt;div id=\"sportsnews\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;div&gt;&lt;/div&gt; 上述模板使用 css-div 描述了页面的结构，不同的 div 标签对应不同的 pagelet，id 对应了 pagelet 的名称。将这个 response 返回给浏览器后，服务器开始对每个 pagelet 的内容进行查询，加载，生成。当一个 pagelet 的内容生成好，立刻调用 flush() 函数，将其返回给客户端，传输的数据是以 json 格式的，包括这个 pagelet 需要的 CSS 和 JS，以及 html 内容和一些元数据。例如： 123456789&lt;script type=\"text/javascript\"&gt; big_pipe.onPageletArrive(&#123; id: 'pagelet_composer', content: '&lt;html&gt;', css: '[..]', js: '[..]', // ...... &#125;);&lt;/script&gt; 其中 “content” 表示这个 pagelet 的内容，是 html 源码，特殊字符如”/“需要进行转义；”id” 表示 content 要显示的位置，即为对应的 pagelet 的 id 标签；”css” 表示需要下载的 CSS 资源的路径；”js” 表示需要下载的 JS 脚本的路径。为了避免文件路径过长，所以在前面需要对 css 和 js 文件的路径进行转换，转换后为 5 位字符串：不同的 pagelet 可能会加载同一个 css 或 js 文件，所以要避免重复下载。 虽然每个 pagelet 都有要加载的 js 文件，但是所有的 js 文件都是在最后加载，这样有利于加快页面加载速度。客户端，当通过调用 onPageletArrive(json) 函数，第一次影响传输的 JS 脚本中的函数解析了传入的 json 数据，接着下载需要的 CSS，然后把 html 内容显示到响应的 DIV 标签位置上。多个 pagelets 的 CSS 文件可以同时下载，CSS 下载完成的 pagelet 先显示。 在 BigPipe 中，js 被给予了比 CSS 和 content 更低的优先级。这样， 只有当所有的 pagelets 都显示了，BigPipe 才开始去下载 JS 文件。所有的 JS 文件都下载完成后，Pagelets 的 JS 初始化代码开始执行，按照下载完成时间的先后顺序。在这个高度并行的系统中，几个的 pagelet 所要执行的不同的阶段可以同时执行。例如，浏览器可以给两个 pagelets 下载 CSS 资源，同时浏览器可以渲染另外一个 pagelet 的内容，同时服务器仍然在为另一个 pagelet 生成 html 源码。从用户的角度看来，页面时逐步呈现的。初始的页面显示的更快，可以有效减短用户感觉到的延迟。 6. BigPipe实现问题讨论 6.1 服务器端的并行化 理想情况下，服务器端的实现是并行处理不同的 pagelet 的内容，这样可以提升性能。服务器并发处理多个 pagelet 的内容时，一个 pagelet 内容生成好了，立刻将其 flush 给浏览器。但是 PHP 是不支持线程，所以服务器无法利用多线程的概念去并发的加载多个 pagelet 的内容。对于小型网站来说，使用串行的加载 pagelet 的内容就已经可以达到优化的要求了。对于大型网站，为了达到更快的速度，服务器端可以选择并发的独立不同的 pagelet 的内容，具体实现有以下几种方式： java 多线程。后台逻辑使用 java，可以使用 java 的多线程机制去同时加载不同的 pagelet 的内容，加载完成后加页面内容返回给浏览器。在最后的引用部分可以看到网上用 java 多线程实现的例子。 使用 PHP 实现。PHP 不支持线程，无法像 java 使用多线程的机制来并发处理不同 pagelet 的内容。但是，Facebook 和淘宝主搜索的业务逻辑是用 PHP 实现的，所以我们必须考虑如何在 PHP 下完成并发处理。PHP 扩展中有 curl 模块，可以在该模块中 curl_multi_fetch() 函数进行批处理请求，把本来应该串行的请求访问并发的执行。可以这样写： 12345678910111213141516do &#123; $mrc = curl_multi_exec($mh, $active);&#125;while($mrc==CURLM_CALL_MULTI_PERFORM); while($active &amp;amp;&amp;amp; $mrc == CURLM_OK) &#123; if (curl_multi_select($mh) != -1) &#123; do &#123; $mrc = curl_multi_exec($mh,$active); &#125; while($mrc == CURLM_CALL_MULTI_PERFORM); &#125;&#125; 但是会碰到一个问题，多个请求是同时返回结果的。当所有的 pagelet 的页面请求所消耗的时间差不多时，可以达到很好的性能，但是当有的消耗时间很长（执行一条复杂的查询）的情况下，批处理就会阻塞在那里，等每个请求都返回结果了才结束。而在这段时间致服务器会阻塞在那里不返回任何内容，而浏览器更是没有响应，这样就违背了 BigPipe 的原理。另外一种实现方法是使用 stream_select 函数。跟上一种方法类似，不过可以使用 PHP5 中新增的 stream_socket_client() 函数链接而不是之前 PHP 函数中的 fsocketopen() 函数。 123456789101112131415161718192021222324252627282930313233while (count($sockets)) &#123; $read = $write = $sockets; $n = stream_select($read,$write, $e, $timeout); if ($n &amp;gt; 0) &#123; foreach ($read as $r) &#123; $id = array_search($r, $sockets); $data = fread($r, 8192); if (strlen($data) == 0) &#123; fclose($r); unset ($sockets[$id]); &#125; else &#123; $retdata[$id] .= $data; &#125; &#125; $retdata[$id] = preg_replace('/^HTTP(.*?)\\r\\n\\r\\n/is', &lt;em&gt;, $retdata[$id]); foreach ($write as $w) &#123; if (!is_resource($w)) continue; $id = array_search($w, $sockets); fwrite($w, \"GET /\" . $url[$id] . \"HTTP/1.0\\r\\nHost: \" . $hosts[$id] .\"\\r\\n\\r\\n\"); $status[$id] = 1; &#125; &#125; else &#123; break; &#125;&#125; 这样实现也可以做到服务器的并发访问，但是会碰到和上一种方法同样的问题：服务器的阻塞问题。所以，可以采用另一种方法，用多进程模拟多线程。使用 PHP 的扩展模块 pctnl 模块中的 pcntl_fork() 函数来生成子进程， 用不同的子进程去处理不同的 pagelet 的页面内容。如果子进程返回内容，则返回给浏览器。或者，修改 curl 模块。使其可以支持回调函数，当并发请求中一个请求完成时，立刻调用回调函数。这两种方法目前还在探索中。 6.2 直接调用 flush 函数输出 到这里，可能会有这样的疑问，为什服务器不直接把生成好的 HTML 内容分部 flush 返回给客户端，而是使用 json 格式传递，然后用 js 解析呢？这不是多此一举么？实际上，这也是目前主搜索前端使用的方法。我们看看使用 BigPipe 方式的两大好处： 如果直接调用 flush() 函数输出 html 源码，当模块较多的情况，模块间必须按顺序加载，在 html 前面的模块必须先加载完，后面的才能加载，这样也就没办法每个模块同时显示一些内容。例如下面的 html： 上面 3 个 div 分别代表 3 个模块，如果直接分部输出 html，服务器端必须先加载完毕 div1 模块中的内容并 flush 出去后，才能继续加载 div2 的内容，如果 flush 顺序不一样，输出的 html 结构肯定就会出问题，这样就导致前台页面没办法同时显示 3 个 loading。因为这样 flush 必须要有先后顺序。而如果采用 JS 的话，可以前台显示3 个 loading，而且不需要关心到底哪个模块先加载完，这样还能发挥后台多线程处理数据的优势。 使用 JS 这种方式可以是页面结构更加清晰，管理更加方便。同时做到了页面逻辑结构和数据解耦，首先返回的是页面的结构，接着不断地返回 js 脚本，然后动态添加页面内容，而不是所有完整的 html 源码一起输出，增加了可维护性。 6.3 访问者是爬虫或者访问者浏览器禁止使用 JS 的情况 我们知道 BigPipe 使用 js 脚本加载页面，那么当用户在浏览器里设置禁止使用 js 脚本（虽然人数很少），就会造成加载页面失败，这同样是非常不好的用户体验。对搜索引擎的爬虫来讲，同样会遇到类似的问题。解决办法是当用户发送访问请求时，服务器端检测 user-agent 和客户端是否支持 js 脚本。如果 user-agent 显示是一个搜索引擎爬虫或者客户端不支持 js，就不使用 BigPipe，而用原有的模式，从而解决问题。 6.4 对 SEO 的影响 这是一个必须考虑的问题，如今是搜索引擎的时代，如果网页对搜索引擎不友好，或者使搜索引擎很难识别内容，那么会降低网页在搜索引擎中的排名，直接减少网站的访问次数。在 BigPipe 中，页面的内容都是动态添加的，所以可能会使搜索引擎无法识别。但是正如前面所说，在服务器端首先要根据 user-agent 判断客户端是否是搜索引擎的爬虫，如果是的话，则转化为原有的模式，而不是动态添加。这样就解决了对搜索引擎的不友好。 6.5 融合其他技术 除了使用 BigPipe，Facebook 的页面加载技术还融合了其他的页面优化技术，具体如下： 6.5.1 资源文件的G-zip压缩 这是非常重要的技术，使用 Gzip 对 css 和 js 文件压缩可以使大小减少70%，这是多么诱人的数字！在网络传输的文件中，主要就是样式表和脚本文件。如此可以大大减小传输的内容，使页面加载速度变得更快。具体实现可以借助服务器来进行，例如 Apache，使用 mod_deflate 模块来完成，具体配置为： 1AddOutputFilterByType DEFLATE text/html text/css application/xjavascript 6.5.2 将 js 文件进行了精简 对 js 文件进行精简，可以从代码中移除不必要的字符，注释以及空行以减小 js 文件的大小，从而改善加载的页面的时间。精简 js 脚本的工具可以使用 JSMin，使用精简后的脚本的大小会减少 20% 左右。这也是一个很大的提升。 6.5.3 将 css 和 js 文件进行合并 这是前端优化的一项原则，将多个样式表和 js 文件进行合并，这样的话，将会减少 http 的请求个数。对于上亿用户的网站来说，这也会带来性能的提升，大约会减少5%左右的时间损耗。 6.5.4 使用外部 JS 和 CSS 同样是前端优化的一项原则。纯粹就速度来言，使用内联的 js 和 css 速度要更快，因为减少了 http 请求。但是，使用外部的文件更有利于文件的复用，这与面向对象编程的概念很像。更为重要的是，虽然在第一次的加载速度慢一点，但 css 文件和 js 脚本是可以被浏览器缓存。即之后用户的多次访问中，使用外部的 js 和 css 将会将会更好的提升速度。 6.5.5 将样式表放在顶部 和上面内容相似，这也是一种规范，将 html 内容所需的 css 文件放在首部加载是非常重要的。如果放在页面尾部，虽然会使页面内容更快的加载（因为将加载 css 文件的时间放在最后，从而使页面内容先显示出来），但是这样的内容是没有使用样式表的，在 css 文件加载进来后，浏览器会对其使用样式表，即再次改变页面的内容和样式，称之为“无样式内容的闪烁”，这对于用户来说当然是不友好的。实现的时候将 css 文件放在 标签中即可。 6.5.6 将脚本放在底部实现“barrier” 支持页面动态内容的 Js 脚本对于页面的加载并没有什么作用，把它放在顶部加载只会使页面更慢的加载，这点和前面的提到的 css 文件刚好相反，所以可以将它放在页尾加载。是用户能看到的页面内容先加载，js 文件最后加载，这样会使用户觉得页面速度更快。Bigpipe 实现一个 “barrier” 的概念，即当所有的 pagelet 的内容全部加载好了之后，浏览器再向服务器发送 js 的http 请求。可以在 BigPipe.js 中将所有的 pagelet 所需的 js 文件的路径保存下来，在判断所有的内容加载完成后统一向服务器发送请求。 7. BigPipe 具体实现细节如上文讨论的那样，具体实现如下： 当用户访问该页面时，在第一个 flush 的 Response 内容中，返回大部分的 HTML 代码，包括完整的 标签，和一个未封闭的 ，其中 标签中有需要导入的文件的路径，如一些公共的 css 文件和 BigPipe.js 文件， 标签有页面的主要布局，第二块 flush 的内容为一段 js 脚本，处理 BigPipe 对象的生成，以及 js 和 css 文件的路径和字符串的映射 123456789var bigPipe = new bigPipe();bigPipe.setResourceMap(&#123; aaaaa: &#123; 'name': 'js/list1.js', 'type': 'js', 'src': 'js/list1.js' &#125;&#125;); setResourceMap(json) 为 BigPipe 中的函数，功能是设置文件的映射。”aaaaa” 应该是在服务器随即生成的五位字符串，name 表示文件名称，type 为文件的类型，可以是 js 或 css，”src” 为文件的路径。在下面的页面中，就可以使用 “aaaaa” 来替代 “js/list1.js” 了，减少了复杂性。接下来 flush 的是每一个 pagelet 的内容了，例如： 123456789101112131415161718192021222324&lt;script type=\"text/javascript\"&gt; bigPipe.onPageletArrive(&#123; id: 'list1', content: 'this is list 1 &lt;\\/ br&gt; &lt;img src = \\\"img13.jpg\\\" \\/&gt;', css: ['eeeee'], js: ['aaaaa'], 'resource_map': &#123; aaaaa: &#123; 'name': 'js/list1.js', 'type': 'js', 'src': 'js/list1.js' &#125;, eeeee: &#123; 'name': 'css/list1.css', 'type': 'css' 'src': 'css/list1.css' &#125; &#125; &#125;);&lt;/script&gt; onPageletArrive(json_arrive) 也是 BigPipe 的函数，功能是动态添加页面的内容和加载 pagelet 所需的文件，函数的参数为 json 格式的数据。其参数含义是：”id” 用来寻找 pagelet 标签；”content” 是 html 页面内容，在找到对应的 pagelet 的标签之后，将 content 内动态添加到 html 页面中；”css” 为该 Pagelet 所需的 css 文件，这里的 css 文件可能在之前导入过了；”js” 为该 pagelet 所需的 js 文件，同样，有可能在之前的 pagelet 已经导入过了。在函数实现过程中，因为 js 文件是最后加载的，可以把这些 js 的路径存入到一个数组当中（去掉重复的），在最后一起加载。”resource_map” 为该 pagelet 所单独需要加载的 js 和 css 文件，同样也是 json 格式的，结构与前面的 setResource() 中的参数一样。最后 flush 的是 12&lt;/body&gt;&lt;/html&gt; 即为最后的标签。 8. 结论经过上面的讨论，我们可以发现，使用 BigPipe 技术优化页面可以有四个好处： 1． 减少页面的加载时间 2． 使页面分步输出，改善用户体验 3． 使页面结构化，提高可读性，更加便于维护 4． 每个pagelet 都是相互独立的，如果有一个pagelet 的内容不能加载，并不会影响其他的pagelet 的内容显示。 同时，BigPipe 是一项比较新的理念， 在去年六月份才由 Facebook 的工程师提出，应该说有很大的发展空间。BigPipe 的原理非常简单，并不会引入很多额外的负担，适用范围很广，容易上手。几乎所有的网页都可以采用 BigPipe 的理念去进行优化，尤其对于是有着海量数据和网页比较大的网站，将会以低成本带来高回报。一般来讲，网站越大，脚本和样式表越多，浏览器版本越旧，网络环境越差，优化的结果越可观。 9. 引用与参考资料 作者的博客：http://www.facebook.com/note.php?note_id=389414033919 bigpipe 技术的 ppt：http://twork.taobao.net/books/237 bigpipe 的 java 实现： http://codemonkeyism.com/facebook-bigpipe-java/ 一篇介绍 bigpipe 的文章：http://www.54chen.com/architecture/rose-pipe-http-54chen.html 另一篇挺有用的文章：http://www.cnblogs.com/BearsTaR/archive/2010/06/18/facebook_html_chunk.html 人人网类似 bigpipe 的技术 – rosepipe：http://www.54chen.com/architecture/rose-open-source-portal-framework.html 《高性能网站建设指南》by Steve Souder， Copyright 2007 Steve Sounder， 978-0-596- 52930-7 本文转载自：http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html","tags":[{"name":"server","slug":"server","permalink":"http://zqianduan.com/tags/server/"}]},{"title":"利用 HTML 和 CSS 实现常见的布局","date":"2016-03-10T14:50:59.000Z","path":"2016/03/10/html-css-layout/","text":"单列布局 水平居中 水平居中的页面布局中最为常见的一种布局形式，多出现于标题，以及内容区域的组织形式，下面介绍四种实现水平居中的方法（注：下面各个实例中实现的是child元素的对齐操作，child元素的父容器是parent元素） 使用 inline-block 和 text-align 实现 123456.parent &#123; text-align: center;&#125;.child &#123; display: inline-block;&#125; 优点：兼容性好； 不足：需要同时设置子元素和父元素 使用 margin:0 auto 来实现 1234.child &#123; width: 200px; margin: 0 auto;&#125; 优点：兼容性好 缺点: 需要指定宽度 使用 table 实现 1234.child &#123; display: table; margin: 0 auto;&#125; 优点：只需要对自身进行设置 不足：IE6,7 需要调整结构 使用绝对定位实现 123456789.parent &#123; position: relative;&#125;/* 或者实用 margin-left 的负值为盒子宽度的一半也可以实现，不过这样就必须知道盒子的宽度，但兼容性好 */.child &#123; position: absolute; left: 50%; transform: translate(-50%);&#125; 不足：兼容性差，IE9 及以上可用 使用 flex 布局实现 12345678910111213/* 第一种方法 */.parent &#123; display:flex; justify-content: center;&#125;/* 第二种方法 */.parent &#123; display: flex;&#125;.child &#123; margin:0 auto;&#125; 缺点：兼容性差，如果进行大面积的布局可能会影响效率 垂直居中 vertical-align 我们都知道，每个人都有不同的嗜好，有的人喜欢吃甜食，有的人喜欢吃辣的东西，有的人不喜欢吃芹菜，有的人不喜欢吃羊肉等等。CSS 中的有些元素也是这样，他们有的只对牛奶感兴趣，有的只喜欢吃坚果和果冻，而讨厌牛奶。而 vertical-align 呢，是个比较挑食的家伙，它只喜欢吃果冻，从小吃果冻长大，没有了果冻，它就会闹脾气，对你不理不睬。我称之为“果冻依赖型元素”，又称之为“inline-block 依赖型元素”，也就是说,只有一个元素属于 inline 或是 inline-block（table-cell 也可以理解为 inline-block 水平）水平，其身上的 vertical-align 属性才会起作用（参考） 在使用 vertical-align 的时候，由于对齐的基线是用行高的基线作为标记，故需要设置 line-height 或设置 display: table-cell; 123456789101112/*第一种方法*/.parent &#123; display: table-cell; vertical-align: middle; height:20px;&#125;/*第二种方法*/.parent &#123; display: inline-block; vertical-align: middle; line-height: 20px;&#125; 利用绝对定位 12345678.parent &#123; position: relative;&#125;.child &#123; positon: absolute; top: 50%; transform: translate(0,-50%);&#125; 利用 flex 实现 1234.parent &#123; display: flex; align-items: center;&#125; 水平垂直全部居中 利用 vertical-align, text-align, inline-block 实现 12345678.parent &#123; display: table-cell; vertical-align: middle; text-align: center;&#125;.child &#123; display: inline-block;&#125; 利用绝对定位实现 123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; 利用 flex 实现 12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125; 多列布局 左列定宽，右列自适应 该布局方式非常常见，适用于定宽的一侧常为导航，自适应的一侧为内容的布局 利用 float+margin 实现 1234567.left &#123; float: left; width: 100px;&#125;.right &#123; margin-left: 100px;&#125; 注：IE6 会有 3px 的 bug 利用 float+margin(fix) 实现 123456&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right-fix\"&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112.left &#123; width: 100px; float: left;&#125;.right-fix &#123; width: 100%; margin-left: -100px; float: right;&#125;.right &#123; margin-left: 100px;&#125; 利用 float+overflow 实现 1234567.left &#123; width: 100px; float:left;&#125;.right &#123; overflow: hidden;&#125; overflow: hidden 触发 bfc 模式，浮动无法影响，隔离其他元素，IE6 不支持（关于BFC） 如果我们需要将两列设置为等高，可以用下述方法将“背景”设置为等高，其实并不是内容的等高 123456789101112131415.left &#123; width: 100px; float: left;&#125;.right &#123; height: 500px; overflow: hidden;&#125;.parent &#123; overflow: hidden;&#125;.left, .right &#123; padding-bottom: 9999px; margin-bottom: -9999px;&#125; 利用 table 实现 1234567891011.parent &#123; display: table; table-layout: fixed; width: 100%;&#125;.left &#123; width: 100px;&#125;.right, .left &#123; display: table-cell;&#125; 利用 flex 实现 123456789.parent &#123; display: flex;&#125;.left &#123; width: 100px;&#125;.right &#123; flex: 1;&#125; 利用右侧容器的 flex:1，均分了剩余的宽度，也实现了同样的效果。而 align-items 默认值为 stretch，故二者高度相等 右列定宽，左列自适应 使用 float+margin 实现 12345678910111213141516.parent &#123; background: red; height: 100px; margin: 0 auto;&#125;.left &#123; background: green; margin-right: -100px; width: 100%; float:left;&#125;.right &#123; float: right; width: 100px; background: blue;&#125; 使用 table 实现 123456789101112.parent &#123; display: table; table-layout: fixed; width: 100%;&#125;.left &#123; display: table-cell;&#125;.right &#123; width: 100px; display: table-cell;&#125; 使用 flex 实现 123456789.parent &#123; display: flex;&#125;.left &#123; flex: 1;&#125;.right &#123; width: 100px;&#125; 两列定宽，一列自适应 基本 html 结构为父容器为 parent，自容器为 left, center, right. 其中，left, center 定宽，right 自适应 利用 float+margin 实现 1234567.left, .center &#123; float: left; width: 200px;&#125;.right &#123; margin-left: 400px;&#125; 利用 float+overflow 实现 1234567.left, .center &#123; float: left; width: 200px;&#125;.right &#123; overflow: hidden;&#125; 利用 table 实现 1234567891011.parent &#123; display: table; table-layout: fixed; width: 100%;&#125;.left, .center, .right &#123; display: table-cell;&#125;.left, .center &#123; width: 200px;&#125; 利用 flex 实现 123456789.parent &#123; display: flex;&#125;.left, .center &#123; width: 100px;&#125;.right &#123; flex: 1;&#125; 两侧定宽，中栏自适应 利用 float+margin 实现 12345678910111213.left &#123; width: 100px; float: left;&#125;.center &#123; float: left; width: 100%; margin-right: -200px;&#125;.right &#123; width: 100px; float: right;&#125; 利用 table 实现 1234567891011121314.parent &#123; width: 100%; display: table; table-layout: fixed;&#125;.left, .center, .right &#123; display: table-cell;&#125;.left &#123; width: 100px;&#125;.right &#123; width: 100px;&#125; 利用 flex 实现 123456789101112.parent &#123; display: flex;&#125;.left &#123; width: 100px;&#125;.center &#123; flex: 1;&#125;.right &#123; width: 100px;&#125; 一列不定宽，一列自适应 利用 float+overflow 实现 123456.left &#123; float: left;&#125;.right &#123; overflow: hidden;&#125; 利用 table 实现 1234567891011.parent &#123; display: table; table-layout: fixed; width: 100%;&#125;.left &#123; width: 0.1%;&#125;.left, .right &#123; display: table-cell;&#125; 利用 flex 实现 123456.parent &#123; display: flex;&#125;.right &#123; flex: 1;&#125; 多列等分布局 多列等分布局常出现在内容中，多数为功能的，同阶级内容的并排显示等。 1234567&lt;!-- Html 结构如下 --&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt;&lt;/div&gt; 使用 float 实现 12345678910.parent &#123; /* 假设列之间的间距为20px */ margin-left: -20px&#125;.column &#123; float: left; width: 25%; padding-left: 20px; box-sizing: border-box;&#125; 利用 table 实现 123456789101112.parent-fix &#123; margin-left: -20px;&#125;.parent &#123; display: table; table-layout: fixed; width: 100%;&#125;.column &#123; display: table-cell; padding-left: 20px;&#125; 利用 flex 实现 123456789.parent &#123; display: flex;&#125;.column &#123; flex: 1;&#125;.column + .column &#123; margin-left: 20px;&#125; 九宫格布局 使用 table 实现 12345&lt;div class=\"parent\"&gt; &lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213.parent &#123; display: table; table-layout: fixed; width: 100%;&#125;.row &#123; display: table-row;&#125;.item &#123; display: table-cell; width: 33.3%; height: 200px;&#125; 利用 flex 实现 12345&lt;div class=\"parent\"&gt; &lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112.parent &#123; display: flex; flex-direction: column;&#125;.row &#123; height: 100px; display: flex;&#125;.item &#123; width: 100px; background: red;&#125; 全屏布局 利用绝对定位实现 123456&lt;div class=\"parent\"&gt; &lt;div class=\"top\"&gt;top&lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;div class=\"bottom\"&gt;bottom&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233html, body, parent &#123; height: 100%; overflow: hidden;&#125;.top &#123; position: absolute; top: 0; left: 0; right: 0; height: 100px;&#125;.left &#123; position: absolute; top: 100px; left: 0; bottom: 50px; width: 200px;&#125;.right &#123; position: absolute; overflow: auto; left: 200px; right: 0; top: 100px; bottom: 50px;&#125;.bottom &#123; position: absolute; left: 0; right: 0; bottom: 0; height: 50px;&#125; 利用 flex 实现 12345678&lt;div class=\"parent\"&gt; &lt;div class=\"top\"&gt;top&lt;/div&gt; &lt;div class=\"middle\"&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt;bottom&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021.parent &#123; display: flex; flex-direction: column;&#125;.top &#123; height: 100px;&#125;.bottom &#123; height: 50px;&#125;.middle &#123; flex: 1; display: flex;&#125;.left &#123; width: 200px;&#125;.right &#123; flex: 1; overflow: auto;&#125; 响应式布局 meta 标签的使用 设置布局宽度等于设备宽度，布局 viewport 等于度量 viewport 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; 媒体查询 12345678&lt;!-- 语法 --&gt;&lt;style&gt; @media screen and (max-width:960px) &#123; .... &#125;&lt;/style&gt;&lt;link rel=\"stylesheet\" media=\"screen and (max-width:960px)\" href='xxx.css' /&gt; 本文转载自：https://segmentfault.com/a/1190000003931851","tags":[{"name":"layout","slug":"layout","permalink":"http://zqianduan.com/tags/layout/"},{"name":"flex","slug":"flex","permalink":"http://zqianduan.com/tags/flex/"}]},{"title":"javascript 跨域总结","date":"2016-03-09T02:42:04.000Z","path":"2016/03/09/js-cross-domain/","text":"什么情况会跨域 主域不同 主域相同，子域不同 域名相同，协议不同（http / https） 域名相同，端口不同 跨域解决办法 document.domain + iframe 对于主域相同而子域不同的例子，可以通过设置 document.domain 的办法来解决。具体的做法如下： 是可以在 a.com/a.html 和 1.a.com/b.html 两个文件中分别加上 document.domain = &#39;a.com&#39;; 然后通过 a.html 文件中创建一个 iframe，去控制 iframe 的 contentDocument，当然这种办法只能解决主域相同而二级域名不同的情况。 123456&lt;!-- a.com/a.html --&gt;&lt;iframe id='i' src=\"1.a.com\" onload=\"do()\"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'a.com'; document.getElementById('i').contentWindow;&lt;/script&gt; 1234&lt;!-- 1.a.com/b.html --&gt;&lt;script&gt; document.domain = 'a.com';&lt;/script&gt; 这样，就可以解决问题了。值得注意的是：document.domain 的设置是有限制的，只能设置为页面本身或者更高一级的域名。利用这种方法是极其方便的，但是如果一个网站被攻击之后另外一个网站很可能会引起安全漏洞。 动态创建 script (jsonp) JSONP 的全称是 “JSON With Padding”， 词面意思上理解就是 “填充式的JSON”。由于浏览器的同源策略，使得在网页端出现了这个“跨域”的问题，然而我们发现，所有的 src 属性并没有受到相关的限制，比如 img / script 等，jsonp 就是利用了 script 可以执行其它域的 js 函数，比如这样： 1234567891011121314&lt;!-- a.com/a.html --&gt;...&lt;script&gt; function callback(data) &#123; console.log(data.url) &#125;&lt;/script&gt;&lt;script src='http://b.com/b.js'&gt;&lt;/script&gt;...&lt;!-- b.com/b.js --&gt;callback(&#123;url: 'http://www.rccoder.net'&#125;) 利用这一点，假如 b.js 里面的内容不是固定的，而是根据一些东西自动生成的， 嗯，这就是 JSONP 的主要原理了。回调函数+数据就是 JSON With Padding 了，回调函数用来响应应该在页面中调用的函数，数据则用来传入要执行的回调函数，至于这个数据是怎么产生的，无非就是服务端的字符串拼接了。 以下是 jsonp 请求的实现： 1234567891011121314151617181920212223242526272829303132var loadJsonp = (function() &#123; var seq = new Date() * 1; return function(url, params, callback) &#123; var funName = 'XYJsonp' + seq++, head = document.getElementsByTagName('head')[0], script = document.createElement('script'); for (var key in params) &#123; url += (/\\?/.test(url) ? '&amp;': '?') + key + '=' + encodeURIComponent(params[key]); &#125; url += '&amp;callback=' + funName; window[funName] = function(data) &#123; window[funName] = undefined; try &#123; delete window[funName]; &#125; catch(e) &#123;&#125; if (head) &#123; head.removeChild(script); &#125; callback(data); &#125;; script.charset = \"UTF-8\"; script.src = url; head.appendChild(script); &#125;;&#125; ()); 注意：JSONP的这种实现方式不受同源策略的影响，兼容性也很好；但是它之支持 GET 方式的请求，只支持 HTTP 请求这种特殊的情况，对于两个不同域之间两个页面的互相调用也是无能为力。 利用 iframe 和 location.hash 这个办法比较绕，把数据的变化显示在 url 的 hash 里面。原理是利用 location.hash 来进行传值。但是由于 chrome 和 IE 不允许修改 parent.location.hash 的值，所以需要再加一层。 a.html 和 b.html 进行数据交换： 1234567891011121314151617181920&lt;!-- a.com/a.html --&gt;&lt;script&gt; function startRequest() &#123; var ifr = document.createElement('iframe'); ifr.style.display = 'none'; ifr.src = 'http://b.com/b.html#paramdo'; document.body.appendChild(ifr); &#125; function checkHash() &#123; try &#123; var data = location.hash ? location.hash.substring(1) : ''; if (console.log) &#123; console.log('Now the data is '+data); &#125; &#125; catch(e) &#123;&#125;; &#125; setInterval(checkHash, 2000);&lt;/script&gt; 1234567891011121314151617181920212223242526&lt;!-- b.com/b.html --&gt;&lt;script&gt; // 模拟一个简单的参数处理操作 switch(location.hash)&#123; case '#paramdo': callBack(); break; case '#paramset': //do something…… break; &#125; function callBack() &#123; try &#123; parent.location.hash = 'somedata'; &#125; catch (e) &#123; // ie、chrome 的安全机制无法修改 parent.location.hash， // 所以要利用一个中间域下的代理 iframe var ifrproxy = document.createElement('iframe'); ifrproxy.style.display = 'none'; ifrproxy.src = 'http://a.com/c.html#somedata'; // 注意该文件在 a.com 域下 document.body.appendChild(ifrproxy); &#125; &#125;&lt;/script&gt; 12345&lt;!-- a.com/c.html --&gt;&lt;script&gt; // 因为 parent.parent 和自身属于同一个域，所以可以改变其 location.hash 的值 parent.parent.location.hash = self.location.hash.substring(1);&lt;/script&gt; window.name 实现跨域数据传输 window.name 在一个窗口（标签）的生命周期之内是共享的，利用这点结合 iframe：当在 iframe 中加载新页面时，name 的属性值依旧保持不变。 总结起来即：iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 需要3个文件：a.com/a.html, a.com/proxy.html, b.com/b.html 1234567891011121314151617181920212223242526&lt;!-- a.com/a.html --&gt;&lt;script type=\"text/javascript\"&gt; var state = 0, iframe = document.createElement('iframe'), loadfn = function() &#123; if (state === 1) &#123; var data = iframe.contentWindow.name; // 读取数据 alert(data); //弹出'I was there!' &#125; else if (state === 0) &#123; state = 1; iframe.contentWindow.location = \"http://a.com/proxy.html\"; // 设置的代理文件 &#125; &#125;; iframe.src = 'http://b.com/b.html'; if (iframe.attachEvent) &#123; iframe.attachEvent('onload', loadfn); &#125; else &#123; iframe.onload = loadfn; &#125; document.body.appendChild(iframe);&lt;/script&gt; 123456&lt;!-- b.com/b.html --&gt;&lt;script type=\"text/javascript\"&gt; window.name = 'I was there!'; // 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右 // 数据格式可以自定义，如json、字符串&lt;/script&gt; proxy 是一个代理文件，空的就可以，需要和 a 在同一域下 利用 HTML5 postMessage window.postMessage 是 HTML5 新增 API 之一，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了他，就会让后面的函数超时无法执行。 下一代浏览器支持这个功能 Chrome 2.0+, Internet Explorer 8.0+, Firefox 1.0+, Opera 9.6+, 和 Safari 4.0+ 。 参考资料： https://developer.mozilla.org/en-US/docs/Web/API/window.postMessage CORS CORS 的全称是 Cross-Origin Resource Sharing，即跨域资源共享。他的原理就是使用自定义的 HTTP 头部，让服务器与浏览器进行沟通，主要是通过设置响应头的 Access-Control-Allow-Origin 来达到目的，这样，XMLHttpRequest 就能跨域了。 参考资料： https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS","tags":[{"name":"jsonp","slug":"jsonp","permalink":"http://zqianduan.com/tags/jsonp/"},{"name":"iframe","slug":"iframe","permalink":"http://zqianduan.com/tags/iframe/"}]},{"title":"圣杯布局","date":"2016-03-08T09:01:08.000Z","path":"2016/03/08/holy-grail-layout/","text":"经典的三列布局，也叫做圣杯布局 Holy Grail of Layouts，是Kevin Cornell在2006年提出的一个布局模型概念，在国内最早是由淘宝UED的工程师传播开来，在中国也有叫法是双飞翼布局，它的布局要求有几点： 三列布局，中间宽度自适应，两边定宽 中间栏要在浏览器中优先展示渲染 允许任意列的高度最高 要求只用一个额外的 div 标签 要求用最少的 CSS，最少的 Hack 语句 1234567&lt;div class=\"header\"&gt;&lt;/div&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829.wrap &#123; padding: 0 100px 0 120px; overflow: hidden; zoom: 1;&#125;.center, .left, .right &#123; float: left; height: 200px; padding-bottom: 9999px; margin-bottom: -9999px;&#125;.center &#123; width: 100%; background: #eee;&#125;.left &#123; width: 120px; margin-left: -100%; background: #ace; position: relative; left: -120px;&#125;.right &#123; width: 100px; margin-left: -100px; background: #f50; position: relative; right: -100px;&#125;","tags":[{"name":"css","slug":"css","permalink":"http://zqianduan.com/tags/css/"},{"name":"layout","slug":"layout","permalink":"http://zqianduan.com/tags/layout/"}]},{"title":"BFC 和 HasLayout","date":"2016-03-08T08:50:31.000Z","path":"2016/03/08/bfc-haslayout/","text":"BFC 的定义是 W3C CSS2.1 规范中的一个概念，它决定了元素如何对其元素进行定位，以及与其它元素的关系和相互作用。 在创建了 Block Formating Context 的元素中，其子元素会一个接一个地放置。垂直方向上他们的起点是一个包含块的顶部，两个相邻的元素之间的垂直距离取决于 margin 特性。在 Block Formating Context 中相邻的块级元素的垂直边距会折叠（collapse）。 在 Block Formating Context 中，每一个元素左外边距与包含块的左边相接触（对于从右到左的格式化，右外边接触右边），即使存在浮动也是如此（尽管一个元素的内容区域会由于浮动而压缩），除非这个元素也创建了一个 Block Formating Context。 BFC到底是什么？当涉及到可视化布局的时候，Block Formatting Context 提供了一个环境，HTML 元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成 BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个 BFC 就是一个独立的行政单位的意思。 怎样才能形成BFC float 的值不为 none overflow 的值不为 visible display 的值为 table-cell, table-caption, inline-block 中的任何一个 position 的值不为 relative 和 static BFC 的作用 不和浮动元素重叠 如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个覆盖的现象，很多自适应的两栏布局就是这么做的。比如下图的效果，参考例子 清除元素内部浮动 只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于 IE6 加上zoom:1就可以了(IE Haslayout) 嵌套元素 margin 边距折叠问题的解决 按照 BFC 的定义，只有同属于一个 BFC 时，两个元素才有可能发生垂直 margin 的重叠，这个包括相邻元素，嵌套元素，只要他们之间没有阻挡(例如边框，非空内容，padding等)就会发生 margin 重叠。 因此要解决 margin 重叠问题，只要让它们不在同一个 BFC 就行了，但是对于两个相邻元素来说，意义不大，没有必要给它们加个外壳，但是对于嵌套元素来说就很有必要了，只要把父元素设为 BFC 就可以了。这样子元素的 margin 就不会和父元素的 margin 发生重叠了。 IE HasLayoutLayout 是一个 Internet Explorer for Windows 的私有概念，它决定了一个元素如何显示以及约束其包含的内容、如何与其他元素交互和建立联系、如何响应和传递应用程序事件、用户事件等。这种渲染特性可以通过某些 CSS 属性被不可逆转地触发。而有些 HTML 元素则默认就具有 layout。 一个元素“得到 layout”，或者说一个元素“拥有 layout” 的时候，是指它的微软专有属性 hasLayout 被设为了 true 。一个“layout 元素”可以是一个默认就拥有 layout 的元素或者是一个通过设置某些 CSS 属性得到 layout 的元素。 不同于标准属性，也不像某些浏览器的私有 CSS 属性，layout 无法通过某一个 CSS 声明直接设定 。也就是说没有“layout 属性”这么一个东西，元素要么本身自动拥有 layout，要么借助一些 CSS 声明悄悄地获得 layout。 下列元素应该是默认具有 layout 的： &lt;html&gt;, &lt;body&gt; &lt;table&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt; &lt;img&gt; &lt;hr&gt; &lt;input&gt;, &lt;button&gt;, &lt;select&gt;, &lt;textarea&gt;, &lt;fieldset&gt;, &lt;legend&gt; &lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt;, &lt;applet&gt; &lt;marquee&gt; 下列 CSS 属性和取值将会让一个元素获得 layout： position: absolute 绝对定位元素的包含区块(containing block)就会经常在这一方面出问题。 float: left | right 由于 layout 元素的特性，浮动模型会有很多怪异的表现。 display: inline-block 当一个内联级别的元素需要 layout 的时候往往就要用到它，这也可能也是这个 CSS 属性的唯一效果–让某个元素拥有 layout。inline-block行为在 IE 中是可以实现的，但是非常与众不同： IE/Win: inline-block and hasLayout 。 width: 除 auto 外的任意值 很多人遇到 layout 相关问题发生时，一般都会先尝试用这个来修复。 height: 除 auto 外的任意值 height: 1% 就在 Holly Hack 中用到。 zoom: 除 normal 外的任意值 IE专有属性。不过 zoom: 1 可以临时用做调试。 writing-mode: tb-rl MS专有属性。 IE7中引入的hasLayout成员 overflow: hidden | scroll | auto 在 IE7 中，overflow 也变成了一个 layout 触发器，这个属性在之前版本 IE 中没有触发 layout 的功能。 position: fixed min-width: 任意值 就算设为0也可以让该元素获得 layout。 max-width: 除 none 之外的任意值 min-height: 任意值 即使设为0也可以让该元素的 haslayout=true max-height: 除 none 之外的任意值 参考资料： 常规流( Normal flow )：http://www.w3help.org/zh-cn/kb/010/","tags":[{"name":"bfc","slug":"bfc","permalink":"http://zqianduan.com/tags/bfc/"},{"name":"layout","slug":"layout","permalink":"http://zqianduan.com/tags/layout/"}]},{"title":"Javascript 中的内存管理","date":"2016-03-08T08:30:57.000Z","path":"2016/03/08/js-memory-management/","text":"无论哪种语言，内存的生命周期差不多总是相同的： 分配你需要的内存 使用它（读、写） 当不再需要已分配的内存时释放它 js 中，大部分内存管理问题出现在释放内存阶段1，基本问题在于无法确定一些内存是否“不再被需要”。高阶语言的的解释器包含一个称为“垃圾收集器”的软件，它的工作是追踪内存的分配使用，以便在于不再需要某个已分配的内存时发现，并自动释放它。 垃圾回收算法： 引用计数式 引发内存泄漏的主要方式：循环引用、内部函数引用（闭包）、页面交叉泄漏、貌似泄漏 123456789function f() &#123; var o = &#123;&#125;; var o2 = &#123;&#125;; o.a = o2; o2.a = o; return 'jimco';&#125;f(); 标记 - 扫描式 这个算法将定义“一个对象不再被需要”，缩小为“一个对象不能被到达”。算法假设一组称为 root 的对象（在 js 中，root 是全局对象）。垃圾收集器会定期地从 root 开始查找所有被 root 引用的对象，然后是所有被这些对象引用的对象，以此类推。由于是从 root 开始，因此垃圾收集器将找到所有可以到达的对象，并收集所有不可到达的对象。 参考资料： Javascript中的内存管理 理解并解决IE的内存泄漏方式 了解 JavaScript 应用程序中的内存泄漏","tags":[{"name":"memory","slug":"memory","permalink":"http://zqianduan.com/tags/memory/"}]},{"title":"javascript oo 实现","date":"2016-03-08T08:08:42.000Z","path":"2016/03/08/js-oo-class/","text":"简单栗子理解三个关键字： function, JS 世界里 Class 的定义用 function, function 里面的内容就是构造函数的内容 this, 代表调用这个函数的对象 prototype, 用它来定义成员函数，比较规范和保险 12345678910111213// 定义 Circle 类，拥有成员变量 r，常量 PI 和计算面积的成员函数 area()function Circle(radius) &#123; this.r = radius;&#125;Circle.PI = 1.1415926;Circle.prototype.area = function() &#123; return Circle.PI * this.r * this.r;&#125;// 使用 Circle 类var c = new Circle(1.0);console.log(c); 另外成员函数也可以写成这样： 12345function compute_area() &#123; return Circle.PI * this.r * this.r;&#125;Circle.prototype.area = compute_area; 创建对象 工厂模式 1234567891011121314function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; console.log(this.name); &#125; return o;&#125;var person1 = createPerson('jimco', 24, 'Front-end Engineer');var person2 = crestePerson('Lucy', 25, 'Dcotor'); 构造函数模式 1234567891011function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; console.log(this.name); &#125;&#125;var person1 = new Person('jimco', 24, 'Front-end Engineer');var person2 = new Person('Lucy', 25, 'Dcotor'); 创建 Person 的新实例，必须使用 new 操作符，以这种方式调用构造函数实际上会经历以下 4 个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（因此 this 就指向这个新对象） 执行构造函数中的代码（为这个对象添加属性） 返回新对象 原型模式 123456789101112function Person() &#123;&#125;Person.prototype.name = 'jimco';Person.prototype.age = '24';Person.prototype.job = 'Front-end Engineer';Person.prototype.sayName = function() &#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();console.log(person1.sayName == person2.sayName); // true 更简单的原型语法： 1234567891011function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name: 'jimco', age: 24, job: 'Front-end Engineer', sayName: function() &#123; console.log(this.name); &#125;&#125; 组合使用构造函数模式和原型模式 1234567891011121314151617181920212223function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = ['Shelby', 'Court'];&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; console.log(this.name); &#125;&#125;var person1 = new Person('jimco', 24, 'Front-end Engineer');var person2 = new Person('Lucy', 25, 'Dcotor');person1.friends.push('Van');console.log(person1.friends);console.log(person2.friends);console.log(person1.friends === person2.friends); // falseconsole.log(person1.sayName === person2.sayName); // true 继承基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针(constructor)，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，如此层层递进，就构成了实例与原型的链条。这就是原型链的基本概念。 原型链基本模式： 123456789101112131415161718192021function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperVal = function() &#123; return this.property;&#125;function SubType = &#123; this.subproperty = false;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType; // 若不重写则指向 SuperTypeSubType.prototype.getSubVal = function() &#123; return this.subproperty;&#125;var instance = new SubType();console.log(instance.getSuperVal()); // true 原型链的问题：包含引用类型值的属性会被所有实例共享。 1234567891011121314function SuperType() &#123; this.colors = ['red', 'green', 'blue'];&#125;function SubType() &#123;&#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push('black');console.log(instance1.colors); // ['red', 'green', 'blue', 'black']var instance2 = new SubType();console.log(instance2.colors); // ['red', 'green', 'blue', 'black'] 借用构造函数： 123456789101112131415161718function SuperType() &#123; this.colors = ['red', 'green', 'blue']; this.getColors = function() &#123; console.log(this.colors); &#125;&#125;function SubType()&#123; // 继承了 SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push('black');console.log(instance1.colors); // ['red', 'green', 'blue', 'black']var instance2 = new SubType();console.log(instance2.colors); // ['red', 'green', 'blue'] 缺陷：方法都在构造函数中定义，复用无从谈起。而且在超类型的原型中定义的方法，对子类型而言也是不可见的 组合继承： 123456789101112131415161718192021222324252627282930function SuperType(name) &#123; this.name = name; this.colors = ['red', 'green', 'blue'];&#125;SuperType.prototype.sayName = function() &#123; console.log(this.name);&#125;function SubType(name, age) &#123; SuperType.call(this, name); // 继承属性 this.age = age;&#125;SubType.prototype = new SuperType(); // 继承方法SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125;var instance1 = new SubType('jimco', 24);instance1.colors.push('black');console.log(instance1.colors); // ['red', 'green', 'blue', 'black']instance1.sayName(); // 'Jimco'instance1.sayAge(); // 24var instance2 = new SubType('Lucy', 25);console.log(instance2.colors); // ['red', 'green', 'blue']instance2.sayName(); // 'Lucy'instance2.sayAge(); // 25 原型式继承： 1234567891011121314151617181920function object(o) &#123; function F() &#123;&#125;; F.prototype = o; return new F();&#125;var person = &#123; name: 'jimco', friends: ['Shelby', 'Court', 'Van']&#125;var person1 = object(person);person1.name = 'Greg';person1.friends.push('Bob');var person2 = object(person);person2.name = 'Linda';person2.friends.push('Barbie');console.log(person2.friends); // ['Shelby', 'Court', 'Van', 'Bob', 'Barbie'] object() 方法与 ECMAScript 5 新增的 object.create() 方法类似 在没有必要兴师动众地创建构造函数的，而只想让一个对象与另一个对象保持类似的情况下，原型式继承完全是可以胜任的。不过，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样 寄生式继承： 12345678910111213141516function createAnother(original) &#123; var clone = object(original); // 通过调用函数创建一个新对象 clone.sayHi = function() &#123; // 以某种方式来增强这个对象 console.log('hi'); &#125; return clone; // 返回这个对象&#125;var person = &#123; name: 'jimco', friend: ['Shelby', 'Court', 'Van']&#125;var person1 = createAnother(person);person1.sayHi(); // 'hi' 使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率，这一点与构造函数模式类似。 寄生组合式继承： (引用类型最理想的继承范式) 12345678910111213141516171819202122232425262728293031function object(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype;&#125;function SuperType(name) &#123; this.name = name; this.colors = ['red', 'green', 'blue'];&#125;SuperType.prototype.sayName = function() &#123; console.log(this.name);&#125;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125; 这个例子的高效率体现在它只调用了一次 SuperType 构造函数，并且避免了在 SuperType.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此还能够正常使用 instanceof 和 isPrototypeOf()。 参考资料 如何编写可维护的面向对象JavaScript代码 Javascript面向对象扩展库 知乎：面向对象编程的弊端是什么？","tags":[{"name":"oo","slug":"oo","permalink":"http://zqianduan.com/tags/oo/"},{"name":"class","slug":"class","permalink":"http://zqianduan.com/tags/class/"}]},{"title":"javascript 异步编程原理","date":"2016-03-08T07:52:22.000Z","path":"2016/03/08/js-async-principle/","text":"Javascript 的执行环境是单线程的，所谓的单线程，就是指一次只能完成一件任务，如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。 这种模式的好处是实现起来比较简单，执行环境相对单纯。坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为一段 Js 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其它任务无法执行。 为了解决这个问题，Javascript 语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。 “同步模式”如上文所描述的，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的； “异步模式”则完全不同，每一个任务有一个或多个回调函数，前一个任务结束后不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。 “异步模式”非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是 Ajax 操作。在服务器端，“异步模式”甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有 http 请求，服务器性能会急剧下降，很快就会失去响应。 setTimeout 神器 弊端1：setTimeout 和 setInterval 运行的最短周期是 5ms 左右，HTML规范 12345678var d = new Date(), count = 0, timer;timer = setTimeout(function()&#123; if( new Date() - d &gt; 1000)&#123; clearTimeout(timer); console.log(count); &#125; count++;&#125;, 0); setTimeout 是存在一定时间间隔的，不是设定 n 毫秒执行，它就是 n 毫秒执行，可能会有一点时间延迟（2ms 左右） 弊端2：while 循环阻塞 setTimeout 执行 12345var d = new Date();setTimeout(function()&#123; console.log('show me after 1s, but you konw: ' + ( new Date() -d ));&#125;, 1000);while(true) if( new Date() - d &gt; 2000 ) break; 上面代码，我们期望 console 在 1s 后打出结果，可事实却是在 2000ms+ 之后运行的，这就是 Javascript 单线程给我们带来的烦恼，while 循环阻塞了 setTimeout 的执行。 弊端3：try…catch… 捕捉不到它的错误 12345678try &#123; setTimeout(function() &#123; throw new Error('我不希望这个错误出现'); &#125;, 1000);&#125;catch(e) &#123; console.log(e.message);&#125; setTimeout 是异步编程不可缺少的角色，但它本身存在诸多问题，这就要求我们用更恰当的方式去规避。 什么样的函数是异步的？ 异步的概念和非阻塞是息息相关的，我们通过 ajax 请求的时候一般是通过异步的方式： 123456var xhr = new XMLHttpRequest();xhr.open('GET', '/', true); // 第三个参数设置为 true， 也就是异步加载xhr.send();xhr.onreadystatechange = function()&#123; console.log(xhr.status);&#125; 常见异步模型 回调函数 陷入回调地狱，解耦程度特别低。 事件监听（on / off / trigger） JS 和浏览器提供的原生方法基本都是基于事件触发机制的，耦合度很低，不过事件不能得到流程控制。 发布/订阅模式（Pub / Sub） 把事件全部交给控制器管理，可以完全掌握事件被订阅的次数，以及订阅者的信息，管理起来特别方便。 这种方法的性质与“事件监听”类似，但是明显优于后者。因为我们可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 Promise 对象 Promise 对象是 CommonJS 工作组提出的一种规范，目的是为异步编程提供统一的接口。简单说，它的思想是，每一个异步任务返回一个 Promise 对象，该对象有一个 then 方法，允许指定回调函数。 promise 模式在任何时候都处于一下 3 中状态之一：未完成(unfulfilled)、已完成(resolved)、和拒绝(rejected)。以 CommonJS Promise/A 标准为例，promise 对象上的 then 方法负责添加针对已完成和拒绝状态下的处理函数。then 方法会返回另一个 promise 对象，以便于形成 promise 管道，这种返回 promise 对象的方式能够支持开发人员把异步操作串联起来，如 then(resolvedHandler, rejectedHandler); 。resolvedHandler 回调函数在 promise 对象进入完成状态时会触发，并传递结果；rejectedHandler 函数会在拒绝状态下调用。 12345678910111213141516var Promise = function(thens)&#123; this.thens = thens || [];&#125;Promise.prototype = &#123; resolve: function()&#123; /* move from unfulfilled to resolved */ var t = this.thens.shift(), n; t &amp;&amp; ( n ＝ t.apply(null, arguments), n instanceof Promise &amp;&amp; ( n.thens = this.thens ) ) &#125;, reject: function()&#123; /* move from unfulfilled to rejected */ &#125;, then: function(n)&#123; return this.thens.push(n), this; &#125;&#125;","tags":[{"name":"promise","slug":"promise","permalink":"http://zqianduan.com/tags/promise/"},{"name":"async","slug":"async","permalink":"http://zqianduan.com/tags/async/"}]},{"title":"https 服务器配置指南","date":"2016-03-07T14:25:30.000Z","path":"2016/03/07/https-server-config/","text":"Nginx1234567891011121314151617181920server &#123; listen 443; server_name demo.com; # 开启 ssl 支持 ssl on; # 指定证书文件 ssl_certificate /usr/local/nginx/conf/server.crt; # 指定私钥文件 ssl_certificate_key /usr/local/nginx/conf/server.key;&#125;# 80 端口重定向server &#123; listen 80; server_name demo.com; rewrite ^(.*) https://$server_name$request_uri? permanent;&#125; 有时候我们可能既需要 http 能访问，https 也能访问，那么我们可以这么配置 conf 文件： 12345678server &#123; listen 80; listen 443 ssl; server_name demo.com; ssl_certificate /usr/local/nginx/conf/server.crt; ssl_certificate_key /usr/local/nginx/conf/server.key;&#125; Apache 修改 httpd-ssl.conf 文件，在文件中配置证书和密钥 12SSLCertificateFile /apache/conf/server.crtSSLCertificateKeyFile /apache/conf/server.key 虚拟机设置 123456789101112NameVirtualHost *:443&lt;VirtualHost *:443&gt; SSLEngine on SSLCertificateFile /apache/conf/server.crt SSLCertificateKeyFile /apache/conf/server.key &lt;Directory /var/www/html/virtual-web&gt; AllowOverride All &lt;/Directory&gt; ServerAdmin email@example.com DocumentRoot /var/www/html/virtual-web ServerName demo.com&lt;/VirtualHost&gt; 修改 httpd.conf 文件 1234567891011# 打开ssl模块LoadModule ssl_module /opt/taobao/install/httpd/modules/mod_ssl.so# 引入步骤1中修改的 ssl 配置文件Include /apache/conf/httpd-ssl.conf# 80 端口重定向&lt;VirtualHost *:80&gt; ServerName demo.com Redirect permanent / https://demo.com/&lt;/VirtualHost&gt; 参考资料： http://manual.seafile.com/deploy/https_with_nginx.html http://manual.seafile.com/deploy/https_with_apache.html","tags":[{"name":"server","slug":"server","permalink":"http://zqianduan.com/tags/server/"},{"name":"https","slug":"https","permalink":"http://zqianduan.com/tags/https/"}]},{"title":"瀑布流布局的开发实践","date":"2016-03-06T06:54:24.000Z","path":"2016/03/06/infinite-loading-disadvantage/","text":"瀑布流的布局方式展现的内容通常是扁平化、琐碎的东西。首先吸引人的应该是图片，并且图片是那种参差不齐的，如果瀑布流中文字过多，会给人很杂乱的感觉，所以瀑布流更适合单纯的图片浏览。 传统的定位布局方式目前主流的瀑布流布局都是采用定位的方式，对每个单元格计算定位值，如下图： 定位的方式实现起来其实也简单，在窗口 resize 时，也可以方便的对单元格进行重新计算排序。但是计算的频率比较高，如果要做无限的加载数据，以及 resize 时的自适应排列，那么性能就是一个必须要重视的问题。 如果没有任何优化手段，成百上千个单元格本身就很耗资源，resize 时再全部重新计算一遍，可以想象浏览器在这个时候一定很吃力，必然会有浏览器假死的情况。 多列浮动的布局方式再来看看多列浮动布局的实现方式，多个单元格组成一列，无需对单个的单元格进行定位的计算，然后对整列进行浮动，如下图： 当然，这种布局方式在无限加载和 resize 时的自适应面前，面对着同样的问题。 自适应窗口先说 resize 时的布局自适应，虽然浮动布局的计算没有定位那么方便，但要实现自适应的布局还是可以的。比如原来有 4 列，resize 时页面宽度变小了，只能放 3 列了，单元格的总数是不变的，数据的顺序也是固定的，那么只有把原来 4 列里面的单元格全部清空，按照数据的顺序重新计算排序，依次添加到 3 列中。需要注意的是清空的时候并不是把单元格的 DOM 元素给删除掉，而是从 DOM 树提取出来存放在一个文档碎片中，这样就避免了每次都要去创建单元格的 DOM 元素，节省了创建时的性能开销，说得通俗点就是离线操作。 无限加载的挑战浏览器中运行的 WEB 程序并不能像桌面软件那样会有足够多的 CPU 和内存去使用。当网页中的 DOM 元素的数量呈指数倍的增长，那么其占用的内存也势必会成正比的增长，每个 DOM 元素都会有性能开销，只是通常情况下 DOM 的数量并没有达到需要注意型性能的那个阙值。 无限加载的瀑布流就必须要注意这种由于 DOM 数量庞大而引发出来的性能问题。不能抱着侥幸的心理去认为用户可能滚动不了多长就会跳出。此次做的瀑布流布局的项目压根就没有内页，都是浮层直接展示大图，虽说在一定程度上方便了用户，但同时也给浏览器端很大的性能压力。用户如果不需要跳转一直停留在瀑布流的列表页，只要不关闭这个页面，内存就会一直没有释放的机会。 虽然页面可以无限长，但是用户的显示器的可视区域是有限的，就好比一个再富有的人，他晚上睡觉时占的面积还是那么大，床的面积也是有限的。由于可视区域是有限的，通常会利用这一点对没加载的 DOM 元素作延迟加载，那么反过来，能否对已加载的但不在可视区域的 DOM 元素做文章呢？答案是肯定的，人有多大胆，地有多大产嘛。 当页面向下滚动的时候，瀑布流会创建新的单元格，老的单元格就会随着页面的向下滚动而处于非可视范围，既然都不可见了，那么为了节省性能完全可以把这些老单元格删除掉。当然，也要有技巧性的去删除。如果页面往上滚，滚回去的时候你总不能给用户看白板，不能这样坑人。那么原来删除的还得保持原位置加回去。不悠着点的话，光是这样一删一加的两个动作就够浏览器受的了。作为 WEB 开发者，要时刻都有浏览器是很脆弱的如芒在背的心理。 分组操作上面说到的有技巧性的删除就是将那些处于非可视区域的 DOM 元素从 DOM 树中提取出来，存储在一个文档碎片的容器中。DOM 元素脱离了 DOM 树也会大大节省性能的开销，这样就达到了节省性能的目的。当然如果仅仅只做到这一步还不太好意思说是技巧。正是因为这个，我将 HTML 结构再包裹一层，在 ul 外面添加了一个 div，称之为一组，其真实结构如下图所示。 在这里，组是比列更大的单位，一组可以是可视区域大小的尺寸( 目前组还没精确到针对不同的分辨率 )，一组里面就是浮动的自适应屏幕分辨率的几列，每列里面就是一个个的单元格。如上图，这样几列就可以组成一组。有了组就可以比较方便的将频繁出入于 DOM 树中的 DOM 元素的性能开销平衡的分配到每一组。可以在页面滚动向下到指定的位置，只删除某一组，继续向下滚再继续删除。每次都删除处于最顶端的那一组，因为是在非可视区域内，用户也不会知道你的删除操作。 页面的高度是由一个个单元格给撑起来的，删除了单元格后，其高度就会出现变化，由此就会导致页面的高度也跟着变化。在删除前计算出组元素的高度，然后设置其 visibility 为 hidden，让其在删除后还保留组元素原有的位置和高度，这样就不会有高度的变化了。 通过的删除非可视区域的 DOM 元素的优化方法，可以让页面始终保持1-2组单元格，只要你组内的单元格的数量能把握好。这样就在一定程度上大大的缓解了了页面中由于 DOM 数量过多而出现的性能开销的问题。 当窗口 resize 达到重新排序的宽度条件时，还是要将页面中所有单元格重新计算排序。由于非可视区域的单元格已经不在 DOM 树中，那么其计算也没什么压力了。那些存储在文档碎片容器中的单元格也还是需要计算的，因为如果此时页面往上滚动时那些离线的单元格还要重新和用户见面嘛，只是这个计算并不是在 DOM 树中而已。 本文转载自：http://uxc.360.cn/archives/1285.html","tags":[{"name":"waterflow","slug":"waterflow","permalink":"http://zqianduan.com/tags/waterflow/"},{"name":"dom","slug":"dom","permalink":"http://zqianduan.com/tags/dom/"}]},{"title":"jQuey 发布订阅模式快速实现","date":"2016-03-04T06:29:09.000Z","path":"2016/03/04/jquey-pub-sub-pattern/","text":"1234567891011121314151617(function($) &#123; var o = $(&#123;&#125;); $.subscribe = function() &#123; o.on.apply(o, arguments); &#125;; $.unsubscribe = function() &#123; o.off.apply(o, arguments); &#125;; $.publish = function() &#123; o.trigger.apply(o, arguments); &#125;;&#125;(jQuery));","tags":[{"name":"javascript","slug":"javascript","permalink":"http://zqianduan.com/tags/javascript/"},{"name":"pattern","slug":"pattern","permalink":"http://zqianduan.com/tags/pattern/"}]},{"title":"js 获取图片尺寸","date":"2016-03-04T06:19:43.000Z","path":"2016/03/04/javascript-image-dimensions/","text":"12345678910111213141516171819202122// HTML5提供了一个新属性naturalWidth/naturalHeight可以直接获取图片的原始宽高。// 这两个属性在Firefox/Chrome/Safari/Opera及IE9里已经实现。改造下获取图片尺寸的方法。// 注意IE6/7/8的处理，创建了一个新的img，仅设置其src，这时需要让图片完全载入后才可以获取其宽高。// 因此这里是异步的，可以传一个回调，回调里把原始的宽高作为参数传入。function getImgNaturalDimensions(img, callback) &#123; var nWidth, nHeight; if (img.naturalWidth) &#123; // 现代浏览器 nWidth = img.naturalWidth nHeight = img.naturalHeight &#125; else &#123; // IE6/7/8 var imgae = new Image() image.src = img.src image.onload = function() &#123; callback(image.width, image.height) &#125; &#125; return [nWidth, nHeight]&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://zqianduan.com/tags/javascript/"},{"name":"image","slug":"image","permalink":"http://zqianduan.com/tags/image/"}]},{"title":"短小强悍的 Javascript 异步调用库","date":"2016-03-04T06:02:07.000Z","path":"2016/03/04/javascript-queue-fuction/","text":"12345678910111213141516171819202122232425262728293031var queue = function(funcs, scope) &#123; (function next()&#123; if(funcs.length &gt; 0)&#123; funcs.shift().apply(scope, [next].concat(Array.prototype.slice.call(arguments, 0))); &#125; &#125;)();&#125;// Examplevar obj = &#123; value: null &#125;;queue([ function(callback)&#123; var me = this; setTimeout(function()&#123; me.value = 10; callback(20); &#125;); &#125;, function(callback, add)&#123; console.log(this.value + add); callback(); &#125;, function()&#123; console.log(obj.value); &#125;], obj);// console: 30// console: 10","tags":[{"name":"javascript","slug":"javascript","permalink":"http://zqianduan.com/tags/javascript/"}]},{"title":"meta 标签知识汇总","date":"2016-03-04T05:49:39.000Z","path":"2016/03/04/html-meta/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt; &lt;!-- HTML5 doctype 不区分大小写 --&gt;&lt;html lang=\"zh-cmn-Hans-CN\"&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; &lt;!-- 优先使用IE最新版本和 Chrome --&gt; &lt;meta name=\"renderer\" content=\"webkit|ie-comp|ie-stand\"&gt; &lt;!-- 360 浏览器内核控制 --&gt; &lt;!-- content的取值为webkit,ie-comp,ie-stand之一，区分大小写，分别代表用webkit内核，IE兼容内核，IE标准内核。 若页面需默认用极速核，增加标签：&lt;meta name=\"renderer\" content=\"webkit\"&gt; 若页面需默认用ie兼容内核，增加标签：&lt;meta name=\"renderer\" content=\"ie-comp\"&gt; 若页面需默认用ie标准内核，增加标签：&lt;meta name=\"renderer\" content=\"ie-stand\"&gt; --&gt; &lt;!-- width=device-width 会导致 iPhone 5 添加到主屏后以 WebAPP 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt; &lt;meta name =\"viewport\" content =\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1,user-scalable=no\"&gt; &lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"&gt; &lt;!-- 添加到主屏时的标题 --&gt; &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt; &lt;!-- 是否启用 WebAPP 全屏模式 --&gt; &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" /&gt; &lt;!-- 状态条颜色 --&gt; &lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt; &lt;!-- 屏蔽数字自动识别为电话号码 --&gt; &lt;!-- favicon 图标 --&gt; &lt;link type=\"image/x-icon\" rel=\"icon\" href=\"http://static.example.com/favicon.ico\"/&gt; &lt;link type=\"image/x-icon\" rel=\"shortcut icon\" href=\"http://static.example.com/favicon.ico\"/&gt; &lt;link type=\"image/x-icon\" rel=\"bookmark\" href=\"http://static.example.com/favicon.ico\"/&gt; &lt;!-- iOS 图标 begin --&gt; &lt;!--默认 57x57 像素--&gt; &lt;link rel=\"apple-touch-icon-precomposed\" href=\"http://wanke.etao.com/assets/img/icon/57/apple-touch-icon-57x57-precomposed.png\" /&gt; &lt;!--iPad 1 72x72 像素--&gt; &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"72x72\" href=\"http://wanke.etao.com/assets/img/icon/72/apple-touch-icon-72x72-precomposed.png\" /&gt; &lt;!--iPhone 4 114x114 像素--&gt; &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"http://wanke.etao.com/assets/img/icon/114/apple-touch-icon-114x114-precomposed.png\" /&gt; &lt;!-- iOS 图标 end --&gt; &lt;meta name=\"msapplication-TileColor\" content=\"#000\"/&gt; &lt;!-- Windows 8 磁贴颜色 --&gt; &lt;meta name=\"msapplication-TileImage\" content=\"icon.png\"/&gt; &lt;!-- Windows 8 磁贴图标 --&gt; &lt;!-- SEO 优化 --&gt; &lt;meta name=\"description\" content=\"\" /&gt; &lt;!-- 页面描述 --&gt; &lt;meta name=\"keywords\" content=\"\"/&gt; &lt;!-- 页面关键词 --&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;!-- iOS 应用启动界面设置 begin --&gt; &lt;!-- iPad Landscape – 1024 x 748 --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"1024x748\" href=\"img/splash-screen-1024x748.png\" /&gt; &lt;!-- iPad Portrait – 768 x 1004 --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"768x1004\" href=\"img/splash-screen-768x1004.png\" /&gt; &lt;!-- iPhone/iPod Touch Portrait – 320 x 480 (standard resolution) --&gt; &lt;link rel=\"apple-touch-startup-image\" href=\"img/splash-screen-320x480.png\" /&gt; &lt;!-- iPhone/iPod Touch Portrait – 640 x 960 pixels (high-resolution) --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x960\" href=\"img/splash-screen-640x960.png\" /&gt; &lt;!-- iOS 应用启动界面设置 end --&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 参考资料 Supported Meta Tags 在移动浏览器中使用viewport元标签控制布局 https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta","tags":[{"name":"html","slug":"html","permalink":"http://zqianduan.com/tags/html/"},{"name":"meta","slug":"meta","permalink":"http://zqianduan.com/tags/meta/"}]},{"title":"ubb 标签正则匹配","date":"2016-03-04T03:30:00.000Z","path":"2016/03/04/ubb-regexp/","text":"1234567891011121314151617181920function ubbTrans(s)&#123; if(s.indexOf(\"://\") &gt; 0)&#123; // url s = s.replace(/(^|[^\\\"\\'\\]])(http|ftp|mms|rstp|news|https)\\:\\/\\/([^\\s\\033\\[\\]\\\"\\']+) /gi, \"$1[url]$2://$3[/url]\"); // img s = s.replace(/\\[url\\](http\\:\\/\\/\\S+\\.)(gif|jpg|jpeg|png)\\[\\/url\\]/gi, \"[img]$1$2[/img]\"); &#125; //ubb: 匹配[UBB]...[/UBB]形式 if(s.match(/\\[(\\w+)([^\\[\\]\\s]*)\\].*\\[\\/\\1\\]/))&#123; s = s.replace(/\\[url\\](.+?)\\[\\/url\\]/gi,\"&lt;a href=$1 target=_blank&gt;$1&lt;/a&gt;\"); s = s.replace(/\\[img\\](.+?\\.(?:gif|jpg|jpeg|png))\\[\\/img\\]/gi, \"&lt;img src='$1' alt='$1'&gt;\"); s = s.replace(/\\[flash\\](.+?\\.swf)\\[\\/flash\\]/gi, \"&lt;embed src='$1' quality=high wmode=transparent type='application/x-shockwave-flash' width=400 height=300&gt;&lt;/embed&gt;&lt;br&gt; FLASH: &lt;a href='$1' target=_blank&gt;$1&lt;/a&gt;&lt;br&gt;\"); s = s.replace(/\\[wma\\](.+?\\.(?:wma|mp3))\\[\\/wma\\]/gi, \"&lt;embed src='$1' height=40 AutoStart=0&gt;&lt;/embed&gt;&lt;br&gt; WMA: &lt;a href='$1' target=_blank&gt;$1&lt;/a&gt;&lt;br&gt;\"); s = s.replace(/\\[color=([#0-9a-zA-Z]&#123;1,10&#125;)\\](.+?)\\[\\/color\\]/gi, \"&lt;font color='$1'&gt;$2&lt;/font&gt;\"); s = s.replace(/\\[b\\](.+?)\\[\\/b\\]/gi, \"&lt;b&gt;$1&lt;/b&gt;\"); s = s.replace(/\\[i\\](.+?)\\[\\/i\\]/gi, \"&lt;i&gt;$1&lt;/i&gt;\"); &#125; return s;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://zqianduan.com/tags/javascript/"},{"name":"ubb","slug":"ubb","permalink":"http://zqianduan.com/tags/ubb/"}]},{"title":"setInterval 计时误差解决方案","date":"2016-03-04T03:13:03.000Z","path":"2016/03/04/setinterval-error-solution/","text":"在 js 中如果打算使用 setInterval 进行倒数，计时等功能，往往是不准确的，因为 setInterval 的回调函数并不是到时后立即执行，而是等系统计算资源空闲下来后才会执行。而下一次触发时间则是在 setInterval 回调函数执行完毕之后才开始计时，所以如果 setInterval 内执行的计算过于耗时，或者有其他耗时任务在执行，setInterval 的计时会越来越不准，延迟很厉害。 下面给出解决方案： 12345678910111213141516171819202122// 动态调整触发时间，减小误差耗时var startTime = new Date().getTime();var count = 0;setInterval(function()&#123; // 耗时任务 var i = 0; while(i++ &lt; 100000000);&#125;, 0);function fixed() &#123; count++; var offset = new Date().getTime() - (startTime + count * 1000); var nextTime = 1000 - offset; if (nextTime &lt; 0) nextTime = 0; setTimeout(fixed, nextTime); console.log(new Date().getTime() - (startTime + count * 1000));&#125;// 虽然触发时间并非绝对准确，但是由于每次触发都进行及时修正，所以没有造成误差累积setTimeout(fixed, 1000);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://zqianduan.com/tags/javascript/"},{"name":"setInterval","slug":"setInterval","permalink":"http://zqianduan.com/tags/setInterval/"}]},{"title":"Backbone 0.9.2 源码分析","date":"2016-03-03T07:16:34.000Z","path":"2016/03/03/backbone-source-analysis/","text":"Backbone.js 为复杂 WEB 应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API；视图可以声明事件处理函数，并通过 RESRful JSON 接口连接到应用程序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457145814591460146114621463146414651466146714681469147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153615371538153915401541154215431544154515461547154815491550155115521553155415551556155715581559156015611562156315641565156615671568156915701571157215731574157515761577157815791580158115821583158415851586158715881589159015911592159315941595159615971598159916001601160216031604160516061607160816091610161116121613161416151616161716181619162016211622162316241625162616271628162916301631163216331634163516361637163816391640164116421643164416451646164716481649165016511652165316541655165616571658165916601661166216631664166516661667166816691670167116721673167416751676167716781679168016811682168316841685168616871688168916901691169216931694169516961697169816991700170117021703170417051706170717081709171017111712171317141715171617171718171917201721172217231724172517261727172817291730173117321733173417351736173717381739174017411742174317441745174617471748174917501751175217531754175517561757175817591760176117621763176417651766176717681769177017711772177317741775177617771778177917801781178217831784178517861787178817891790179117921793179417951796179717981799180018011802180318041805180618071808180918101811181218131814181518161817181818191820182118221823182418251826182718281829183018311832183318341835183618371838183918401841184218431844184518461847184818491850185118521853185418551856185718581859186018611862186318641865186618671868186918701871187218731874187518761877187818791880188118821883188418851886188718881889189018911892189318941895189618971898189919001901190219031904190519061907190819091910191119121913191419151916191719181919192019211922192319241925192619271928192919301931193219331934193519361937193819391940194119421943194419451946194719481949195019511952195319541955195619571958195919601961196219631964196519661967196819691970197119721973197419751976197719781979198019811982198319841985// Backbone.js 0.9.2// (c) 2010-2012 Jeremy Ashkenas, DocumentCloud Inc.// Backbone may be freely distributed under the MIT license.// For all details and documentation:// http://backbonejs.org(function() &#123; // 创建一个全局对象, 在浏览器中表示为window对象, 在Node.js中表示global对象 var root = this; // 保存\"Backbone\"变量被覆盖之前的值 // 如果出现命名冲突或考虑到规范, 可通过Backbone.noConflict()方法恢复该变量被Backbone占用之前的值, 并返回Backbone对象以便重新命名 var previousBackbone = root.Backbone; // 将Array.prototype中的slice和splice方法缓存到局部变量以供调用 var slice = Array.prototype.slice; var splice = Array.prototype.splice; var Backbone; if( typeof exports !== 'undefined') &#123; Backbone = exports; &#125; else &#123; Backbone = root.Backbone = &#123;&#125;; &#125; // 定义Backbone版本 Backbone.VERSION = '0.9.2'; // 在服务器环境下自动导入Underscore, 在Backbone中部分方法依赖或继承自Underscore var _ = root._; if(!_ &amp;&amp; ( typeof require !== 'undefined')) _ = require('underscore'); // 定义第三方库为统一的变量\"$\", 用于在视图(View), 事件处理和与服务器数据同步(sync)时调用库中的方法 // 支持的库包括jQuery, Zepto等, 它们语法相同, 但Zepto更适用移动开发, 它主要针对Webkit内核浏览器 // 也可以通过自定义一个与jQuery语法相似的自定义库, 供Backbone使用(有时我们可能需要一个比jQuery, Zepto更轻巧的自定义版本) // 这里定义的\"$\"是局部变量, 因此不会影响在Backbone框架之外第三方库的正常使用 var $ = root.jQuery || root.Zepto || root.ender; // 手动设置第三方库 // 如果在导入了Backbone之前并没有导入第三方库, 可以通过setDomLibrary方法设置\"$\"局部变量 // setDomLibrary方法也常用于在Backbone中动态导入自定义库 Backbone.setDomLibrary = function(lib) &#123; $ = lib; &#125;; // 放弃以\"Backbone\"命名框架, 并返回Backbone对象, 一般用于避免命名冲突或规范命名方式 // 例如: // var bk = Backbone.noConflict(); // 取消\"Backbone\"命名, 并将Backbone对象存放于bk变量中 // console.log(Backbone); // 该变量已经无法再访问Backbone对象, 而恢复为Backbone定义前的值 // var MyBackbone = bk; // 而bk存储了Backbone对象, 我们将它重命名为MyBackbone Backbone.noConflict = function() &#123; root.Backbone = previousBackbone; return this; &#125;; // 对于不支持REST方式的浏览器, 可以设置Backbone.emulateHTTP = true // 与服务器请求将以POST方式发送, 并在数据中加入_method参数标识操作名称, 同时也将发送X-HTTP-Method-Override头信息 Backbone.emulateHTTP = false; // 对于不支持application/json编码的浏览器, 可以设置Backbone.emulateJSON = true; // 将请求类型设置为application/x-www-form-urlencoded, 并将数据放置在model参数中实现兼容 Backbone.emulateJSON = false; // Backbone.Events 自定义事件相关 // ----------------- // eventSplitter指定处理多个事件时, 事件名称的解析规则 var eventSplitter = /\\s+/; // 自定义事件管理器 // 通过在对象中绑定Events相关方法, 允许向对象添加, 删除和触发自定义事件 var Events = Backbone.Events = &#123; // 将自定义事件(events)和回调函数(callback)绑定到当前对象 // 回调函数中的上下文对象为指定的context, 如果没有设置context则上下文对象默认为当前绑定事件的对象 // 该方法类似与DOM Level2中的addEventListener方法 // events允许指定多个事件名称, 通过空白字符进行分隔(如空格, 制表符等) // 当事件名称为\"all\"时, 在调用trigger方法触发任何事件时, 均会调用\"all\"事件中绑定的所有回调函数 on : function(events, callback, context) &#123; // 定义一些函数中使用到的局部变量 var calls, event, node, tail, list; // 必须设置callback回调函数 if(!callback) return this; // 通过eventSplitter对事件名称进行解析, 使用split将多个事件名拆分为一个数组 // 一般使用空白字符指定多个事件名称 events = events.split(eventSplitter); // calls记录了当前对象中已绑定的事件与回调函数列表 calls = this._callbacks || (this._callbacks = &#123;&#125;); // 循环事件名列表, 从头至尾依次将事件名存放至event变量 while( event = events.shift()) &#123; // 获取已经绑定event事件的回调函数 // list存储单个事件名中绑定的callback回调函数列表 // 函数列表并没有通过数组方式存储, 而是通过多个对象的next属性进行依次关联 /** 数据格式如: * &#123; * tail: &#123;Object&#125;, * next: &#123; * callback: &#123;Function&#125;, * context: &#123;Object&#125;, * next: &#123; * callback: &#123;Function&#125;, * context: &#123;Object&#125;, * next: &#123;Object&#125; * &#125; * &#125; * &#125; */ // 列表每一层next对象存储了一次回调事件相关信息(函数体, 上下文和下一次回调事件) // 事件列表最顶层存储了一个tail对象, 它存储了最后一次绑定回调事件的标识(与最后一次回调事件的next指向同一个对象) // 通过tail标识, 可以在遍历回调列表时得知已经到达最后一个回调函数 list = calls[event]; // node变量用于记录本次回调函数的相关信息 // tail只存储最后一次绑定回调函数的标识 // 因此如果之前已经绑定过回调函数, 则将之前的tail指定给node作为一个对象使用, 然后创建一个新的对象标识给tail // 这里之所以要将本次回调事件添加到上一次回调的tail对象, 是为了让回调函数列表的对象层次关系按照绑定顺序排列(最新绑定的事件将被放到最底层) node = list ? list.tail : &#123;&#125;; node.next = tail = &#123;&#125;; // 记录本次回调的函数体及上下文信息 node.context = context; node.callback = callback; // 重新组装当前事件的回调列表, 列表中已经加入了本次回调事件 calls[event] = &#123; tail : tail, next : list ? list.next : node &#125;; &#125; // 返回当前对象, 方便进行方法链调用 return this; &#125;, // 移除对象中已绑定的事件或回调函数, 可以通过events, callback和context对需要删除的事件或回调函数进行过滤 // - 如果context为空, 则移除所有的callback指定的函数 // - 如果callback为空, 则移除事件中所有的回调函数 // - 如果events为空, 但指定了callback或context, 则移除callback或context指定的回调函数(不区分事件名称) // - 如果没有传递任何参数, 则移除对象中绑定的所有事件和回调函数 off : function(events, callback, context) &#123; var event, calls, node, tail, cb, ctx; // No events, or removing *all* events. // 当前对象没有绑定任何事件 if(!( calls = this._callbacks)) return; // 如果没有指定任何参数, 则移除所有事件和回调函数(删除_callbacks属性) if(!(events || callback || context)) &#123; delete this._callbacks; return this; &#125; // 解析需要移除的事件列表 // - 如果指定了events, 则按照eventSplitter对事件名进行解析 // - 如果没有指定events, 则解析已绑定所有事件的名称列表 events = events ? events.split(eventSplitter) : _.keys(calls); // 循环事件名列表 while( event = events.shift()) &#123; // 将当前事件对象从列表中移除, 并缓存到node变量中 node = calls[event]; delete calls[event]; // 如果不存在当前事件对象(或没有指定移除过滤条件, 则认为将移除当前事件及所有回调函数), 则终止此次操作(事件对象在上一步已经移除) if(!node || !(callback || context)) continue; // Create a new list, omitting the indicated callbacks. // 根据回调函数或上下文过滤条件, 组装一个新的事件对象并重新绑定 tail = node.tail; // 遍历事件中的所有回调对象 while(( node = node.next) !== tail) &#123; cb = node.callback; ctx = node.context; // 根据参数中的回调函数和上下文, 对回调函数进行过滤, 将不符合过滤条件的回调函数重新绑定到事件中(因为事件中的所有回调函数在上面已经被移除) if((callback &amp;&amp; cb !== callback) || (context &amp;&amp; ctx !== context)) &#123; this.on(event, cb, ctx); &#125; &#125; &#125; return this; &#125;, // 触发已经定义的一个或多个事件, 依次执行绑定的回调函数列表 trigger : function(events) &#123; var event, node, calls, tail, args, all, rest; // 当前对象没有绑定任何事件 if(!( calls = this._callbacks)) return this; // 获取回调函数列表中绑定的\"all\"事件列表 all = calls.all; // 将需要触发的事件名称, 按照eventSplitter规则解析为一个数组 events = events.split(eventSplitter); // 将trigger从第2个之后的参数, 记录到rest变量, 将依次传递给回调函数 rest = slice.call(arguments, 1); // 循环需要触发的事件列表 while( event = events.shift()) &#123; // 此处的node变量记录了当前事件的所有回调函数列表 if( node = calls[event]) &#123; // tail变量记录最后一次绑定事件的对象标识 tail = node.tail; // node变量的值, 按照事件的绑定顺序, 被依次赋值为绑定的单个回调事件对象 // 最后一次绑定的事件next属性, 与tail引用同一个对象, 以此作为是否到达列表末尾的判断依据 while(( node = node.next) !== tail) &#123; // 执行所有绑定的事件, 并将调用trigger时的参数传递给回调函数 node.callback.apply(node.context || this, rest); &#125; &#125; // 变量all记录了绑定时的\"all\"事件, 即在调用任何事件时, \"all\"事件中的回调函数均会被执行 // - \"all\"事件中的回调函数无论绑定顺序如何, 都会在当前事件的回调函数列表全部执行完毕后再依次执行 // - \"all\"事件应该在触发普通事件时被自动调用, 如果强制触发\"all\"事件, 事件中的回调函数将被执行两次 if( node = all) &#123; tail = node.tail; // 与调用普通事件的回调函数不同之处在于, all事件会将当前调用的事件名作为第一个参数传递给回调函数 args = [event].concat(rest); // 遍历并执行\"all\"事件中的回调函数列表 while(( node = node.next) !== tail) &#123; node.callback.apply(node.context || this, args); &#125; &#125; &#125; return this; &#125; &#125;; // 绑定事件与释放事件的别名, 也为了同时兼容Backbone以前的版本 Events.bind = Events.on; Events.unbind = Events.off; // Backbone.Model 数据对象模型 // -------------- // Model是Backbone中所有数据对象模型的基类, 用于创建一个数据模型 // @param &#123;Object&#125; attributes 指定创建模型时的初始化数据 // @param &#123;Object&#125; options /** * @format options * &#123; * parse: &#123;Boolean&#125;, * collection: &#123;Collection&#125; * &#125; */ var Model = Backbone.Model = function(attributes, options) &#123; // defaults变量用于存储模型的默认数据 var defaults; // 如果没有指定attributes参数, 则设置attributes为空对象 attributes || ( attributes = &#123;&#125;); // 设置attributes默认数据的解析方法, 例如默认数据是从服务器获取(或原始数据是XML格式), 为了兼容set方法所需的数据格式, 可使用parse方法进行解析 if(options &amp;&amp; options.parse) attributes = this.parse(attributes); if( defaults = getValue(this, 'defaults')) &#123; // 如果Model在定义时设置了defaults默认数据, 则初始化数据使用defaults与attributes参数合并后的数据(attributes中的数据会覆盖defaults中的同名数据) attributes = _.extend(&#123;&#125;, defaults, attributes); &#125; // 显式指定模型所属的Collection对象(在调用Collection的add, push等将模型添加到集合中的方法时, 会自动设置模型所属的Collection对象) if(options &amp;&amp; options.collection) this.collection = options.collection; // attributes属性存储了当前模型的JSON对象化数据, 创建模型时默认为空 this.attributes = &#123;&#125;; // 定义_escapedAttributes缓存对象, 它将缓存通过escape方法处理过的数据 this._escapedAttributes = &#123;&#125;; // 为每一个模型配置一个唯一标识 this.cid = _.uniqueId('c'); // 定义一系列用于记录数据状态的对象, 具体含义请参考对象定义时的注释 this.changed = &#123;&#125;; this._silent = &#123;&#125;; this._pending = &#123;&#125;; // 创建实例时设置初始化数据, 首次设置使用silent参数, 不会触发change事件 this.set(attributes, &#123; silent : true &#125;); // 上面已经设置了初始化数据, changed, _silent, _pending对象的状态可能已经发生变化, 这里重新进行初始化 this.changed = &#123;&#125;; this._silent = &#123;&#125;; this._pending = &#123;&#125;; // _previousAttributes变量存储模型数据的一个副本 // 用于在change事件中获取模型数据被改变之前的状态, 可通过previous或previousAttributes方法获取上一个状态的数据 this._previousAttributes = _.clone(this.attributes); // 调用initialize初始化方法 this.initialize.apply(this, arguments); &#125;; // 使用extend方法为Model原型定义一系列属性和方法 _.extend(Model.prototype, Events, &#123; // changed属性记录了每次调用set方法时, 被改变数据的key集合 changed : null, // // 当指定silent属性时, 不会触发change事件, 被改变的数据会记录下来, 直到下一次触发change事件 // _silent属性用来记录使用silent时的被改变的数据 _silent : null, _pending : null, // 每个模型的唯一标识属性(默认为\"id\", 通过修改idAttribute可自定义id属性名) // 如果在设置数据时包含了id属性, 则id将会覆盖模型的id // id用于在Collection集合中查找和标识模型, 与后台接口通信时也会以id作为一条记录的标识 idAttribute : 'id', // 模型初始化方法, 在模型被构造结束后自动调用 initialize : function() &#123; &#125;, // 返回当前模型中数据的一个副本(JSON对象格式) toJSON : function(options) &#123; return _.clone(this.attributes); &#125;, // 根据attr属性名, 获取模型中的数据值 get : function(attr) &#123; return this.attributes[attr]; &#125;, // 根据attr属性名, 获取模型中的数据值, 数据值包含的HTML特殊字符将被转换为HTML实体, 包含 &amp; &lt; &gt; \" ' \\ // 通过 _.escape方法实现 escape : function(attr) &#123; var html; // 从_escapedAttributes缓存对象中查找数据, 如果数据已经被缓存则直接返回 if( html = this._escapedAttributes[attr]) return html; // _escapedAttributes缓存对象中没有找到数据 // 则先从模型中获取数据 var val = this.get(attr); // 将数据中的HTML使用 _.escape方法转换为实体, 并缓存到_escapedAttributes对象, 便于下次直接获取 return this._escapedAttributes[attr] = _.escape(val == null ? '' : '' + val); &#125;, // 检查模型中是否存在某个属性, 当该属性的值被转换为Boolean类型后值为false, 则认为不存在 // 如果值为false, null, undefined, 0, NaN, 或空字符串时, 均会被转换为false has : function(attr) &#123; return this.get(attr) != null; &#125;, // 设置模型中的数据, 如果key值不存在, 则作为新的属性添加到模型, 如果key值已经存在, 则修改为新的值 set : function(key, value, options) &#123; // attrs变量中记录需要设置的数据对象 var attrs, attr, val; // 参数形式允许key-value对象形式, 或通过key, value两个参数进行单独设置 // 如果key是一个对象, 则认定为使用对象形式设置, 第二个参数将被视为options参数 if(_.isObject(key) || key == null) &#123; attrs = key; options = value; &#125; else &#123; // 通过key, value两个参数单独设置, 将数据放到attrs对象中方便统一处理 attrs = &#123;&#125;; attrs[key] = value; &#125; // options配置项必须是一个对象, 如果没有设置options则默认值为一个空对象 options || ( options = &#123;&#125;); // 没有设置参数时不执行任何动作 if(!attrs) return this; // 如果被设置的数据对象属于Model类的一个实例, 则将Model对象的attributes数据对象赋给attrs // 一般在复制一个Model对象的数据到另一个Model对象时, 会执行该动作 if( attrs instanceof Model) attrs = attrs.attributes; // 如果options配置对象中设置了unset属性, 则将attrs数据对象中的所有属性重置为undefined // 一般在复制一个Model对象的数据到另一个Model对象时, 但仅仅需要复制Model中的数据而不需要复制值时执行该操作 if(options.unset) for(attr in attrs) attrs[attr] = void 0; // 对当前数据进行验证, 如果验证未通过则停止执行 if(!this._validate(attrs, options)) return false; // 如果设置的id属性名被包含在数据集合中, 则将id覆盖到模型的id属性 // 这是为了确保在自定义id属性名后, 访问模型的id属性时, 也能正确访问到id if(this.idAttribute in attrs) this.id = attrs[this.idAttribute]; var changes = options.changes = &#123;&#125;; // now记录当前模型中的数据对象 var now = this.attributes; // escaped记录当前模型中通过escape缓存过的数据 var escaped = this._escapedAttributes; // prev记录模型中数据被改变之前的值 var prev = this._previousAttributes || &#123;&#125;; // 遍历需要设置的数据对象 for(attr in attrs) &#123; // attr存储当前属性名称, val存储当前属性的值 val = attrs[attr]; // 如果当前数据在模型中不存在, 或已经发生变化, 或在options中指定了unset属性删除, 则删除该数据被换存在_escapedAttributes中的数据 if(!_.isEqual(now[attr], val) || (options.unset &amp;&amp; _.has(now, attr))) &#123; // 仅删除通过escape缓存过的数据, 这是为了保证缓存中的数据与模型中的真实数据保持同步 delete escaped[attr]; // 如果指定了silent属性, 则此次set方法调用不会触发change事件, 因此将被改变的数据记录到_silent属性中, 便于下一次触发change事件时, 通知事件监听函数此数据已经改变 // 如果没有指定silent属性, 则直接设置changes属性中当前数据为已改变状态 (options.silent ? this._silent : changes)[attr] = true; &#125; // 如果在options中设置了unset, 则从模型中删除该数据(包括key) // 如果没有指定unset属性, 则认为将新增或修改数据, 向模型的数据对象中加入新的数据 options.unset ? delete now[attr] : now[attr] = val; // 如果模型中的数据与新的数据不一致, 则表示该数据已发生变化 if(!_.isEqual(prev[attr], val) || (_.has(now, attr) != _.has(prev, attr))) &#123; // 在changed属性中记录当前属性已经发生变化的状态 this.changed[attr] = val; if(!options.silent) this._pending[attr] = true; &#125; else &#123; // 如果数据没有发生变化, 则从changed属性中移除已变化状态 delete this.changed[attr]; delete this._pending[attr]; &#125; &#125; // 调用change方法, 将触发change事件绑定的函数 if(!options.silent) this.change(options); return this; &#125;, // 从当前模型中删除指定的数据(属性也将被同时删除) unset : function(attr, options) &#123; (options || ( options = &#123;&#125;)).unset = true; // 通过options.unset配置项告知set方法进行删除操作 return this.set(attr, null, options); &#125;, // 清除当前模型中的所有数据和属性 clear : function(options) &#123; (options || ( options = &#123;&#125;)).unset = true; // 克隆一个当前模型的属性副本, 并通过options.unset配置项告知set方法执行删除操作 return this.set(_.clone(this.attributes), options); &#125;, // 从服务器获取默认的模型数据, 获取数据后使用set方法将数据填充到模型, 因此如果获取到的数据与当前模型中的数据不一致, 将会触发change事件 fetch : function(options) &#123; // 确保options是一个新的对象, 随后将改变options中的属性 options = options ? _.clone(options) : &#123;&#125;; var model = this; // 在options中可以指定获取数据成功后的自定义回调函数 var success = options.success; // 当获取数据成功后填充数据并调用自定义成功回调函数 options.success = function(resp, status, xhr) &#123; // 通过parse方法将服务器返回的数据进行转换 // 通过set方法将转换后的数据填充到模型中, 因此可能会触发change事件(当数据发生变化时) // 如果填充数据时验证失败, 则不会调用自定义success回调函数 if(!model.set(model.parse(resp, xhr), options)) return false; // 调用自定义的success回调函数 if(success) success(model, resp); &#125;; // 请求发生错误时通过wrapError处理error事件 options.error = Backbone.wrapError(options.error, model, options); // 调用sync方法从服务器获取数据 return (this.sync || Backbone.sync).call(this, 'read', this, options); &#125;, // 保存模型中的数据到服务器 save : function(key, value, options) &#123; // attrs存储需要保存到服务器的数据对象 var attrs, current; // 支持设置单个属性的方式 key: value // 支持对象形式的批量设置方式 &#123;key: value&#125; if(_.isObject(key) || key == null) &#123; // 如果key是一个对象, 则认为是通过对象方式设置 // 此时第二个参数被认为是options attrs = key; options = value; &#125; else &#123; // 如果是通过key: value形式设置单个属性, 则直接设置attrs attrs = &#123;&#125;; attrs[key] = value; &#125; // 配置对象必须是一个新的对象 options = options ? _.clone(options) : &#123;&#125;; // 如果在options中设置了wait选项, 则被改变的数据将会被提前验证, 且服务器没有响应新数据(或响应失败)时, 本地数据会被还原为修改前的状态 // 如果没有设置wait选项, 则无论服务器是否设置成功, 本地数据均会被修改为最新状态 if(options.wait) &#123; // 对需要保存的数据提前进行验证 if(!this._validate(attrs, options)) return false; // 记录当前模型中的数据, 用于在将数据发送到服务器后, 将数据进行还原 // 如果服务器响应失败或没有返回数据, 则可以保持修改前的状态 current = _.clone(this.attributes); &#125; // silentOptions在options对象中加入了silent(不对数据进行验证) // 当使用wait参数时使用silentOptions配置项, 因为在上面已经对数据进行过验证 // 如果没有设置wait参数, 则仍然使用原始的options配置项 var silentOptions = _.extend(&#123;&#125;, options, &#123; silent : true &#125;); // 将修改过最新的数据保存到模型中, 便于在sync方法中获取模型数据保存到服务器 if(attrs &amp;&amp; !this.set(attrs, options.wait ? silentOptions : options)) &#123; return false; &#125; var model = this; // 在options中可以指定保存数据成功后的自定义回调函数 var success = options.success; // 服务器响应成功后执行success options.success = function(resp, status, xhr) &#123; // 获取服务器响应最新状态的数据 var serverAttrs = model.parse(resp, xhr); // 如果使用了wait参数, 则优先将修改后的数据状态直接设置到模型 if(options.wait) &#123; delete options.wait; serverAttrs = _.extend(attrs || &#123;&#125;, serverAttrs); &#125; // 将最新的数据状态设置到模型中 // 如果调用set方法时验证失败, 则不会调用自定义的success回调函数 if(!model.set(serverAttrs, options)) return false; if(success) &#123; // 调用响应成功后自定义的success回调函数 success(model, resp); &#125; else &#123; // 如果没有指定自定义回调, 则默认触发sync事件 model.trigger('sync', model, resp, options); &#125; &#125;; // 请求发生错误时通过wrapError处理error事件 options.error = Backbone.wrapError(options.error, model, options); // 将模型中的数据保存到服务器 // 如果当前模型是一个新建的模型(没有id), 则使用create方法(新增), 否则认为是update方法(修改) var method = this.isNew() ? 'create' : 'update'; var xhr = (this.sync || Backbone.sync).call(this, method, this, options); // 如果设置了options.wait, 则将数据还原为修改前的状态 // 此时保存的请求还没有得到响应, 因此如果响应失败, 模型中将保持修改前的状态, 如果服务器响应成功, 则会在success中设置模型中的数据为最新状态 if(options.wait) this.set(current, silentOptions); return xhr; &#125;, // 删除模型, 模型将同时从所属的Collection集合中被删除 // 如果模型是在客户端新建的, 则直接从客户端删除 // 如果模型数据同时存在服务器, 则同时会删除服务器端的数据 destroy : function(options) &#123; // 配置项必须是一个新的对象 options = options ? _.clone(options) : &#123;&#125;; var model = this; // 在options中可以指定删除数据成功后的自定义回调函数 var success = options.success; // 删除数据成功调用, 触发destroy事件, 如果模型存在于Collection集合中, 集合将监听destroy事件并在触发时从集合中移除该模型 // 删除模型时, 模型中的数据并没有被清空, 但模型已经从集合中移除, 因此当没有任何地方引用该模型时, 会被自动从内存中释放 // 建议在删除模型时, 将模型对象的引用变量设置为null var triggerDestroy = function() &#123; model.trigger('destroy', model, model.collection, options); &#125;; // 如果该模型是一个客户端新建的模型, 则直接调用triggerDestroy从集合中将模型移除 if(this.isNew()) &#123; triggerDestroy(); return false; &#125; // 当从服务器删除数据成功时 options.success = function(resp) &#123; // 如果在options对象中配置wait项, 则表示本地内存中的模型数据, 会在服务器数据被删除成功后再删除 // 如果服务器响应失败, 则本地数据不会被删除 if(options.wait) triggerDestroy(); if(success) &#123; // 调用自定义的成功回调函数 success(model, resp); &#125; else &#123; // 如果没有自定义回调, 则默认触发sync事件 model.trigger('sync', model, resp, options); &#125; &#125;; // 请求发生错误时通过wrapError处理error事件 options.error = Backbone.wrapError(options.error, model, options); // 通过sync方法发送删除数据的请求 var xhr = (this.sync || Backbone.sync).call(this, 'delete', this, options); // 如果没有在options对象中配置wait项, 则会先删除本地数据, 再发送请求删除服务器数据 // 此时无论服务器删除是否成功, 本地模型数据已被删除 if(!options.wait) triggerDestroy(); return xhr; &#125;, // 获取模型在服务器接口中对应的url, 在调用save, fetch, destroy等与服务器交互的方法时, 将使用该方法获取url // 生成的url类似于\"PATHINFO\"模式, 服务器对模型的操作只有一个url, 对于修改和删除操作会在url后追加模型id便于标识 // 如果在模型中定义了urlRoot, 服务器接口应为[urlRoot/id]形式 // 如果模型所属的Collection集合定义了url方法或属性, 则使用集合中的url形式: [collection.url/id] // 在访问服务器url时会在url后面追加上模型的id, 便于服务器标识一条记录, 因此模型中的id需要与服务器记录对应 // 如果无法获取模型或集合的url, 将调用urlError方法抛出一个异常 // 如果服务器接口并没有按照\"PATHINFO\"方式进行组织, 可以通过重载url方法实现与服务器的无缝交互 url : function() &#123; // 定义服务器对应的url路径 var base = getValue(this, 'urlRoot') || getValue(this.collection, 'url') || urlError(); // 如果当前模型是客户端新建的模型, 则不存在id属性, 服务器url直接使用base if(this.isNew()) return base; // 如果当前模型具有id属性, 可能是调用了save或destroy方法, 将在base后面追加模型的id // 下面将判断base最后一个字符是否是\"/\", 生成的url格式为[base/id] return base + (base.charAt(base.length - 1) == '/' ? '' : '/') + encodeURIComponent(this.id); &#125;, // parse方法用于解析从服务器获取的数据, 返回一个能够被set方法解析的模型数据 // 一般parse方法会根据服务器返回的数据进行重载, 以便构建与服务器的无缝连接 // 当服务器返回的数据结构与set方法所需的数据结构不一致(例如服务器返回XML格式数据时), 可使用parse方法进行转换 parse : function(resp, xhr) &#123; return resp; &#125;, // 创建一个新的模型, 它具有和当前模型相同的数据 clone : function() &#123; return new this.constructor(this.attributes); &#125;, // 检查当前模型是否是客户端创建的新模型 // 检查方式是根据模型是否存在id标识, 客户端创建的新模型没有id标识 // 因此服务器响应的模型数据中必须包含id标识, 标识的属性名默认为\"id\", 也可以通过修改idAttribute属性自定义标识 isNew : function() &#123; return this.id == null; &#125;, // 数据被更新时触发change事件绑定的函数 // 当set方法被调用, 会自动调用change方法, 如果在set方法被调用时指定了silent配置, 则需要手动调用change方法 change : function(options) &#123; // options必须是一个对象 options || ( options = &#123;&#125;); // this._changing相关的逻辑有些问题 // this._changing在方法最后被设置为false, 因此方法上面changing变量的值始终为false(第一次为undefined) // 作者的初衷应该是想用该变量标示change方法是否执行完毕, 对于浏览器端单线程的脚本来说没有意义, 因为该方法被执行时会阻塞其它脚本 // changing获取上一次执行的状态, 如果上一次脚本没有执行完毕, 则值为true var changing = this._changing; // 开始执行标识, 执行过程中值始终为true, 执行完毕后this._changing被修改为false this._changing = true; // 将非本次改变的数据状态添加到_pending对象中 for(var attr in this._silent) this._pending[attr] = true; // changes对象包含了当前数据上一次执行change事件至今, 已被改变的所有数据 // 如果之前使用silent未触发change事件, 则本次会被放到changes对象中 var changes = _.extend(&#123;&#125;, options.changes, this._silent); // 重置_silent对象 this._silent = &#123;&#125;; // 遍历changes对象, 分别针对每一个属性触发单独的change事件 for(var attr in changes) &#123; // 将Model对象, 属性值, 配置项作为参数以此传递给事件的监听函数 this.trigger('change:' + attr, this, this.get(attr), options); &#125; // 如果方法处于执行中, 则停止执行 if(changing) return this; // 触发change事件, 任意数据被改变后, 都会依次触发\"change:属性\"事件和\"change\"事件 while(!_.isEmpty(this._pending)) &#123; this._pending = &#123;&#125;; // 触发change事件, 并将Model实例和配置项作为参数传递给监听函数 this.trigger('change', this, options); // 遍历changed对象中的数据, 并依次将已改变数据的状态从changed中移除 // 在此之后如果调用hasChanged检查数据状态, 将得到false(未改变) for(var attr in this.changed) &#123; if(this._pending[attr] || this._silent[attr]) continue; // 移除changed中数据的状态 delete this.changed[attr]; &#125; // change事件执行完毕, _previousAttributes属性将记录当前模型最新的数据副本 // 因此如果需要获取数据的上一个状态, 一般只通过在触发的change事件中通过previous或previousAttributes方法获取 this._previousAttributes = _.clone(this.attributes); &#125; // 执行完毕标识 this._changing = false; return this; &#125;, // 检查某个数据是否在上一次执行change事件后被改变过 /** * 一般在change事件中配合previous或previousAttributes方法使用, 如: * if(model.hasChanged('attr')) &#123; * var attrPrev = model.previous('attr'); * &#125; */ hasChanged : function(attr) &#123; if(!arguments.length) return !_.isEmpty(this.changed); return _.has(this.changed, attr); &#125;, // 获取当前模型中的数据与上一次数据中已经发生变化的数据集合 // (一般在使用silent属性时没有调用change方法, 因此数据会被临时抱存在changed属性中, 上一次的数据可通过previousAttributes方法获取) // 如果传递了diff集合, 将使用上一次模型数据与diff集合中的数据进行比较, 返回不一致的数据集合 // 如果比较结果中没有差异, 则返回false changedAttributes : function(diff) &#123; // 如果没有指定diff, 将返回当前模型较上一次状态已改变的数据集合, 这些数据已经被存在changed属性中, 因此返回changed集合的一个副本 if(!diff) return this.hasChanged() ? _.clone(this.changed) : false; // 指定了需要进行比较的diff集合, 将返回上一次的数据与diff集合的比较结果 // old变量存储了上一个状态的模型数据 var val, changed = false, old = this._previousAttributes; // 遍历diff集合, 并将每一项与上一个状态的集合进行比较 for(var attr in diff) &#123; // 将比较结果不一致的数据临时存储到changed变量 if(_.isEqual(old[attr], ( val = diff[attr]))) continue; (changed || (changed = &#123;&#125;))[attr] = val; &#125; // 返回比较结果 return changed; &#125;, // 在模型触发的change事件中, 获取某个属性被改变前上一个状态的数据, 一般用于进行数据比较或回滚 // 该方法一般在change事件中调用, change事件被触发后, _previousAttributes属性存放最新的数据 previous : function(attr) &#123; // attr指定需要获取上一个状态的属性名称 if(!arguments.length || !this._previousAttributes) return null; return this._previousAttributes[attr]; &#125;, // 在模型触发change事件中, 获取所有属性上一个状态的数据集合 // 该方法类似于previous()方法, 一般在change事件中调用, 用于数据比较或回滚 previousAttributes : function() &#123; // 将上一个状态的数据对象克隆为一个新对象并返回 return _.clone(this._previousAttributes); &#125;, // Check if the model is currently in a valid state. It's only possible to // get into an *invalid* state if you're using silent changes. // 验证当前模型中的数据是否能通过validate方法验证, 调用前请确保定义了validate方法 isValid : function() &#123; return !this.validate(this.attributes); &#125;, // 数据验证方法, 在调用set, save, add等数据更新方法时, 被自动执行 // 验证失败会触发模型对象的\"error\"事件, 如果在options中指定了error处理函数, 则只会执行options.error函数 // @param &#123;Object&#125; attrs 数据模型的attributes属性, 存储模型的对象化数据 // @param &#123;Object&#125; options 配置项 // @return &#123;Boolean&#125; 验证通过返回true, 不通过返回false _validate : function(attrs, options) &#123; // 如果在调用set, save, add等数据更新方法时设置了options.silent属性, 则忽略验证 // 如果Model中没有添加validate方法, 则忽略验证 if(options.silent || !this.validate) return true; // 获取对象中所有的属性值, 并放入validate方法中进行验证 // validate方法包含2个参数, 分别为模型中的数据集合与配置对象, 如果验证通过则不返回任何数据(默认为undefined), 验证失败则返回带有错误信息数据 attrs = _.extend(&#123;&#125;, this.attributes, attrs); var error = this.validate(attrs, options); // 验证通过 if(!error) return true; // 验证未通过 // 如果配置对象中设置了error错误处理方法, 则调用该方法并将错误数据和配置对象传递给该方法 if(options &amp;&amp; options.error) &#123; options.error(this, error, options); &#125; else &#123; // 如果对模型绑定了error事件监听, 则触发绑定事件 this.trigger('error', this, error, options); &#125; // 返回验证未通过标识 return false; &#125; &#125;); // Backbone.Collection 数据模型集合相关 // ------------------- // Collection集合存储一系列相同类的数据模型, 并提供相关方法对模型进行操作 var Collection = Backbone.Collection = function(models, options) &#123; // 配置对象 options || ( options = &#123;&#125;); // 在配置参数中设置集合的模型类 if(options.model) this.model = options.model; // 如果设置了comparator属性, 则集合中的数据将按照comparator方法中的排序算法进行排序(在add方法中会自动调用) if(options.comparator) this.comparator = options.comparator; // 实例化时重置集合的内部状态(第一次调用时可理解为定义状态) this._reset(); // 调用自定义初始化方法, 如果需要一般会重载initialize方法 this.initialize.apply(this, arguments); // 如果指定了models数据, 则调用reset方法将数据添加到集合中 // 首次调用时设置了silent参数, 因此不会触发\"reset\"事件 if(models) this.reset(models, &#123; silent : true, parse : options.parse &#125;); &#125;; // 通过extend方法定义集合类原型方法 _.extend(Collection.prototype, Events, &#123; // 定义集合的模型类, 模型类必须是一个Backbone.Model的子类 // 在使用集合相关方法(如add, create等)时, 允许传入数据对象, 集合方法会根据定义的模型类自动创建对应的实例 // 集合中存储的数据模型应该都是同一个模型类的实例 model : Model, // 初始化方法, 该方法在集合实例被创建后自动调用 // 一般会在定义集合类时重载该方法 initialize : function() &#123; &#125;, // 返回一个数组, 包含了集合中每个模型的数据对象 toJSON : function(options) &#123; // 通过Undersocre的map方法将集合中每一个模型的toJSON结果组成一个数组, 并返回 return this.map(function(model) &#123; // 依次调用每个模型对象的toJSON方法, 该方法默认将返回模型的数据对象(复制的副本) // 如果需要返回字符串等其它形式, 可以重载toJSON方法 return model.toJSON(options); &#125;); &#125;, // 向集合中添加一个或多个模型对象 // 默认会触发\"add\"事件, 如果在options中设置了silent属性, 可以关闭此次事件触发 // 传入的models可以是一个或一系列的模型对象(Model类的实例), 如果在集合中设置了model属性, 则允许直接传入数据对象(如 &#123;name: 'test'&#125;), 将自动将数据对象实例化为model指向的模型对象 add : function(models, options) &#123; // 局部变量定义 var i, index, length, model, cid, id, cids = &#123;&#125;, ids = &#123;&#125;, dups = []; options || ( options = &#123;&#125;); // models必须是一个数组, 如果只传入了一个模型, 则将其转换为数组 models = _.isArray(models) ? models.slice() : [models]; // 遍历需要添加的模型列表, 遍历过程中, 将执行以下操作: // - 将数据对象转化模型对象 // - 建立模型与集合之间的引用 // - 记录无效和重复的模型, 并在后面进行过滤 for( i = 0, length = models.length; i &lt; length; i++) &#123; // 将数据对象转换为模型对象, 简历模型与集合的引用, 并存储到model(同时models中对应的模型已经被替换为模型对象) if(!( model = models[i] = this._prepareModel(models[i], options))) &#123; throw new Error(\"Can't add an invalid model to a collection\"); &#125; // 当前模型的cid和id cid = model.cid; id = model.id; // dups数组中记录了无效或重复的模型索引(models数组中的索引), 并在下一步进行过滤删除 // 如果cids, ids变量中已经存在了该模型的索引, 则认为是同一个模型在传入的models数组中声明了多次 // 如果_byCid, _byId对象中已经存在了该模型的索引, 则认为同一个模型在当前集合中已经存在 // 对于上述两种情况, 将模型的索引记录到dups进行过滤删除 if(cids[cid] || this._byCid[cid] || ((id != null) &amp;&amp; (ids[id] || this._byId[id]))) &#123; dups.push(i); continue; &#125; // 将models中已经遍历过的模型记录下来, 用于在下一次循环时进行重复检查 cids[cid] = ids[id] = model; &#125; // 从models中删除无效或重复的模型, 保留目前集合中真正需要添加的模型列表 i = dups.length; while(i--) &#123; models.splice(dups[i], 1); &#125; // 遍历需要添加的模型, 监听模型事件并记录_byCid, _byId列表, 用于在调用get和getByCid方法时作为索引 for( i = 0, length = models.length; i &lt; length; i++) &#123; // 监听模型中的所有事件, 并执行_onModelEvent方法 // _onModelEvent方法中会对模型抛出的add, remove, destroy和change事件进行处理, 以便模型与集合中的状态保持同步 ( model = models[i]).on('all', this._onModelEvent, this); // 将模型根据cid记录到_byCid对象, 便于根据cid进行查找 this._byCid[model.cid] = model; // 将模型根据id记录到_byId对象, 便于根据id进行查找 if(model.id != null) this._byId[model.id] = model; &#125; // 改变集合的length属性, length属性记录了当前集合中模型的数量 this.length += length; // 设置新模型列表插入到集合中的位置, 如果在options中设置了at参数, 则在集合的at位置插入 // 默认将插入到集合的末尾 // 如果设置了comparator自定义排序方法, 则设置at后还将按照comparator中的方法进行排序, 因此最终的顺序可能并非在at指定的位置 index = options.at != null ? options.at : this.models.length; splice.apply(this.models, [index, 0].concat(models)); // 如果设置了comparator方法, 则将数据按照comparator中的算法进行排序 // 自动排序使用silent属性阻止触发reset事件 if(this.comparator) this.sort(&#123; silent : true &#125;); // 依次对每个模型对象触发\"add\"事件, 如果设置了silent属性, 则阻止事件触发 if(options.silent) return this; // 遍历新增加的模型列表 for( i = 0, length = this.models.length; i &lt; length; i++) &#123; if(!cids[( model = this.models[i]).cid]) continue; options.index = i; // 触发模型的\"add\"事件, 因为集合监听了模型的\"all\"事件, 因此在_onModelEvent方法中, 集合也将触发\"add\"事件 // 详细信息可参考Collection.prototype._onModelEvent方法 model.trigger('add', model, this, options); &#125; return this; &#125;, // 从集合中移除模型对象(支持移除多个模型) // 传入的models可以是需要移除的模型对象, 或模型的cid和模型的id // 移除模型并不会调用模型的destroy方法 // 如果没有设置options.silent参数, 将触发模型的remove事件, 同时将触发集合的remove事件(集合通过_onModelEvent方法监听了模型的所有事件) remove : function(models, options) &#123; var i, l, index, model; // options默认为空对象 options || ( options = &#123;&#125;); // models必须是数组类型, 当只移除一个模型时, 将其放入一个数组 models = _.isArray(models) ? models.slice() : [models]; // 遍历需要移除的模型列表 for( i = 0, l = models.length; i &lt; l; i++) &#123; // 所传入的models列表中可以是需要移除的模型对象, 或模型的cid和模型的id // (在getByCid和get方法中, 可通过cid, id来获取模型, 如果传入的是一个模型对象, 则返回模型本身) model = this.getByCid(models[i]) || this.get(models[i]); // 没有获取到模型 if(!model) continue; // 从_byId列表中移除模型的id引用 delete this._byId[model.id]; // 从_byCid列表中移除模型的cid引用 delete this._byCid[model.cid]; // indexOf是Underscore对象中的方法, 这里通过indexOf方法获取模型在集合中首次出现的位置 index = this.indexOf(model); // 从集合列表中移除该模型 this.models.splice(index, 1); // 重置当前集合的length属性(记录集合中模型的数量) this.length--; // 如果没有设置silent属性, 则触发模型的remove事件 if(!options.silent) &#123; // 将当前模型在集合中的位置添加到options对象并传递给remove监听事件, 以便在事件函数中可以使用 options.index = index; model.trigger('remove', model, this, options); &#125; // 解除模型与集合的关系, 包括集合中对模型的引用和事件监听 this._removeReference(model); &#125; return this; &#125;, // 向集合的末尾添加模型对象 // 如果集合类中定义了comparator排序方法, 则通过push方法添加的模型将按照comparator定义的算法进行排序, 因此模型顺序可能会被改变 push : function(model, options) &#123; // 通过_prepareModel方法将model实例化为模型对象, 这句代码是多余的, 因为在下面调用的add方法中还会通过_prepareModel获取一次模型 model = this._prepareModel(model, options); // 调用add方法将模型添加到集合中(默认添加到集合末尾) this.add(model, options); return model; &#125;, // 移除集合中最后一个模型对象 pop : function(options) &#123; // 获取集合中最后一个模型 var model = this.at(this.length - 1); // 通过remove方法移除该模型 this.remove(model, options); return model; &#125;, // 向集合的第一个位置插入模型 // 如果集合类中定义了comparator排序方法, 则通过unshift方法添加的模型将按照comparator定义的算法进行排序, 因此模型顺序可能会被改变 unshift : function(model, options) &#123; // 通过_prepareModel方法将model实例化为模型对象 model = this._prepareModel(model, options); // 调用add方法将模型插入到集合的第一个位置(设置at为0) // 如果定义了comparator排序方法, 集合的顺序将被重排 this.add(model, _.extend(&#123; at : 0 &#125;, options)); return model; &#125;, // 移除并返回集合中的第一个模型对象 shift : function(options) &#123; // 获得集合中的第一个模型 var model = this.at(0); // 从集合中删除该模型 this.remove(model, options); // 返回模型对象 return model; &#125;, // 根据id从集合中查找模型并返回 get : function(id) &#123; if(id == null) return void 0; return this._byId[id.id != null ? id.id : id]; &#125;, // 根据cid从集合中查找模型并返回 getByCid : function(cid) &#123; return cid &amp;&amp; this._byCid[cid.cid || cid]; &#125;, // 根据索引(下标, 从0开始)从集合中查找模型并返回 at : function(index) &#123; return this.models[index]; &#125;, // 对集合中的模型根据值进行筛选 // attrs是一个筛选对象, 如 &#123;name: 'Jack'&#125;, 将返回集合中所有name为\"Jack\"的模型(数组) where : function(attrs) &#123; // attrs不能为空值 if(_.isEmpty(attrs)) return []; // 通过filter方法对集合中的模型进行筛选 // filter方法是Underscore中的方法, 用于将遍历集合中的元素, 并将能通过处理器验证(返回值为true)的元素作为数组返回 return this.filter(function(model) &#123; // 遍历attrs对象中的验证规则 for(var key in attrs) &#123; // 将attrs中的验证规则与集合中的模型进行匹配 if(attrs[key] !== model.get(key)) return false; &#125; return true; &#125;); &#125;, // 对集合中的模型按照comparator属性指定的方法进行排序 // 如果没有在options中设置silent参数, 则排序后将触发reset事件 sort : function(options) &#123; // options默认是一个对象 options || ( options = &#123;&#125;); // 调用sort方法必须指定了comparator属性(排序算法方法), 否则将抛出一个错误 if(!this.comparator) throw new Error('Cannot sort a set without a comparator'); // boundComparator存储了绑定当前集合上下文对象的comparator排序算法方法 var boundComparator = _.bind(this.comparator, this); if(this.comparator.length == 1) &#123; this.models = this.sortBy(boundComparator); &#125; else &#123; // 调用Array.prototype.sort通过comparator算法对数据进行自定义排序 this.models.sort(boundComparator); &#125; // 如果没有指定silent参数, 则触发reset事件 if(!options.silent) this.trigger('reset', this, options); return this; &#125;, // 将集合中所有模型的attr属性值存放到一个数组并返回 pluck : function(attr) &#123; // map是Underscore中的方法, 用于遍历一个集合, 并将所有处理器的返回值作为一个数组返回 return _.map(this.models, function(model) &#123; // 返回当前模型的attr属性值 return model.get(attr); &#125;); &#125;, // 替换集合中的所有模型数据(models) // 该操作将删除集合中当前的所有数据和状态, 并重新将数据设置为models // models应该是一个数组, 可以包含一系列Model模型对象, 或原始对象(将在add方法中自动创建为模型对象) reset : function(models, options) &#123; // models是进行替换的模型(或数据)数组 models || ( models = []); // options默认是一个空对象 options || ( options = &#123;&#125;); // 遍历当前集合中的模型, 依次删除并解除它们与集合的引用关系 for(var i = 0, l = this.models.length; i &lt; l; i++) &#123; this._removeReference(this.models[i]); &#125; // 删除集合数据并重置状态 this._reset(); // 通过add方法将新的模型数据添加到集合 // 这里通过exnted方法将配置项覆盖到一个新的对象, 该对象默认silent为true, 因此不会触发\"add\"事件 // 如果在调用reset方法时没有设置silent属性则会触发reset事件, 如果设置为true则不会触发任何事件, 如果设置为false, 将依次触发\"add\"和\"reset\"事件 this.add(models, _.extend(&#123; silent : true &#125;, options)); // 如果在调用reset方法时没有设置silent属性, 则触发reset事件 if(!options.silent) this.trigger('reset', this, options); return this; &#125;, // 从服务器获取集合的初始化数据 // 如果在options中设置参数add=true, 则获取到的数据会被追加到集合中, 否则将以服务器返回的数据替换集合中的当前数据 fetch : function(options) &#123; // 复制options对象, 因为options对象在后面会被修改用于临时存储数据 options = options ? _.clone(options) : &#123;&#125;; if(options.parse === undefined) options.parse = true; // collection记录当前集合对象, 用于在success回调函数中使用 var collection = this; // 自定义回调函数, 数据请求成功后并添加完成后, 会调用自定义success函数 var success = options.success; // 当从服务器请求数据成功时执行options.success, 该函数中将解析并添加数据 options.success = function(resp, status, xhr) &#123; // 通过parse方法对服务器返回的数据进行解析, 如果需要自定义数据结构, 可以重载parse方法 // 如果在options中设置add=true, 则调用add方法将数据添加到集合, 否则将通过reset方法将集合中的数据替换为服务器的返回数据 collection[options.add ? 'add' : 'reset'](collection.parse(resp, xhr), options); // 如果设置了自定义成功回调, 则执行 if(success) success(collection, resp); &#125;; // 当服务器返回状态错误时, 通过wrapError方法处理错误事件 options.error = Backbone.wrapError(options.error, collection, options); // 调用Backbone.sync方法发送请求从服务器获取数据 // 如果需要的数据并不是从服务器获取, 或获取方式不使用AJAX, 可以重载Backbone.sync方法 return (this.sync || Backbone.sync).call(this, 'read', this, options); &#125;, // 向集合中添加并创建一个模型, 同时将该模型保存到服务器 // 如果是通过数据对象来创建模型, 需要在集合中声明model属性对应的模型类 // 如果在options中声明了wait属性, 则会在服务器创建成功后再将模型添加到集合, 否则先将模型添加到集合, 再保存到服务器(无论保存是否成功) create : function(model, options) &#123; var coll = this; // 定义options对象 options = options ? _.clone(options) : &#123;&#125;; // 通过_prepareModel获取模型类的实例 model = this._prepareModel(model, options); // 模型创建失败 if(!model) return false; // 如果没有声明wait属性, 则通过add方法将模型添加到集合中 if(!options.wait) coll.add(model, options); // success存储保存到服务器成功之后的自定义回调函数(通过options.success声明) var success = options.success; // 监听模型数据保存成功后的回调函数 options.success = function(nextModel, resp, xhr) &#123; // 如果声明了wait属性, 则在只有在服务器保存成功后才会将模型添加到集合中 if(options.wait) coll.add(nextModel, options); // 如果声明了自定义成功回调, 则执行自定义函数, 否则将默认触发模型的sync事件 if(success) &#123; success(nextModel, resp); &#125; else &#123; nextModel.trigger('sync', model, resp, options); &#125; &#125;; // 调用模型的save方法, 将模型数据保存到服务器 model.save(null, options); return model; &#125;, // 数据解析方法, 用于将服务器数据解析为模型和集合可用的结构化数据 // 默认将返回resp本身, 这需要与服务器定义Backbone支持的数据格式, 如果需要自定义数据格式, 可以重载parse方法 parse : function(resp, xhr) &#123; return resp; &#125;, // chain用于构建集合数据的链式操作, 它将集合中的数据转换为一个Underscore对象, 并使用Underscore的chain方法转换为链式结构 // 关于chain方法的转换方式, 可参考Underscore中chain方法的注释 chain : function() &#123; return _(this.models).chain(); &#125;, // 删除所有集合元素并重置集合中的数据状态 _reset : function(options) &#123; // 删除集合元素 this.length = 0; this.models = []; // 重置集合状态 this._byId = &#123;&#125;; this._byCid = &#123;&#125;; &#125;, // 将模型添加到集合中之前的一些准备工作 // 包括将数据实例化为一个模型对象, 和将集合引用到模型的collection属性 _prepareModel : function(model, options) &#123; options || ( options = &#123;&#125;); // 检查model是否是一个模型对象(即Model类的实例) if(!( model instanceof Model)) &#123; // 传入的model是模型数据对象, 而并非模型对象 // 将数据作为参数传递给Model, 以创建一个新的模型对象 var attrs = model; // 设置模型引用的集合 options.collection = this; // 将数据转化为模型 model = new this.model(attrs, options); // 对模型中的数据进行验证 if(!model._validate(model.attributes, options)) model = false; &#125; else if(!model.collection) &#123; // 如果传入的是一个模型对象但没有建立与集合的引用, 则设置模型的collection属性为当前集合 model.collection = this; &#125; return model; &#125;, // 解绑某个模型与集合的关系, 包括对集合的引用和事件监听 // 一般在调用remove方法删除模型或调用reset方法重置状态时自动调用 _removeReference : function(model) &#123; // 如果模型引用了当前集合, 则移除该引用(必须确保所有对模型的引用已经解除, 否则模型可能无法从内存中释放) if(this == model.collection) &#123; delete model.collection; &#125; // 取消集合中监听的所有模型事件 model.off('all', this._onModelEvent, this); &#125;, // 在向集合中添加模型时被自动调用 // 用于监听集合中模型的事件, 当模型在触发事件(add, remove, destroy, change事件)时集合进行相关处理 _onModelEvent : function(event, model, collection, options) &#123; // 添加和移除模型的事件, 必须确保模型所属的集合为当前集合对象 if((event == 'add' || event == 'remove') &amp;&amp; collection != this) return; // 模型触发销毁事件时, 从集合中移除 if(event == 'destroy') &#123; this.remove(model, options); &#125; // 当模型的id被修改时, 集合修改_byId中存储对模型的引用, 保持与模型id的同步, 便于使用get()方法获取模型对象 if(model &amp;&amp; event === 'change:' + model.idAttribute) &#123; // 获取模型在改变之前的id, 并根据此id从集合的_byId列表中移除 delete this._byId[model.previous(model.idAttribute)]; // 以模型新的id作为key, 在_byId列表中存放对模型的引用 this._byId[model.id] = model; &#125; // 在集合中触发模型对应的事件, 无论模型触发任何事件, 集合都会触发对应的事件 // (例如当模型被添加到集合中时, 会触发模型的\"add\"事件, 同时也会在此方法中触发集合的\"add\"事件) // 这对于监听并处理集合中模型状态的变化非常有效 // 在监听的集合事件中, 触发对应事件的模型会被作为参数传递给集合的监听函数 this.trigger.apply(this, arguments); &#125; &#125;); // 定义Underscore中的集合操作的相关方法 // 将Underscore中一系列集合操作方法复制到Collection集合类的原型对象中 // 这样就可以直接通过集合对象调用Underscore相关的集合方法 // 这些方法在调用时所操作的集合数据是当前Collection对象的models数据 var methods = ['forEach', 'each', 'map', 'reduce', 'reduceRight', 'find', 'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke', 'max', 'min', 'sortBy', 'sortedIndex', 'toArray', 'size', 'first', 'initial', 'rest', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf', 'isEmpty', 'groupBy']; // 遍历已经定义的方法列表 _.each(methods, function(method) &#123; // 将方法复制到Collection集合类的原型对象 Collection.prototype[method] = function() &#123; // 调用时直接使用Underscore的方法, 上下文对象保持为Underscore对象 // 需要注意的是这里传递给Underscore方法的集合参数是 this.models, 因此在使用这些方法时, 所操作的集合对象是当前Collection对象的models数据 return _[method].apply(_, [this.models].concat(_.toArray(arguments))); &#125;; &#125;); // Backbone.Router URL路由器 // ------------------- // 通过继承Backbone.Router类实现自定义的路由器 // 路由器允许定义路由规则, 通过URL片段进行导航, 并将每一个规则对应到一个方法, 当URL匹配某个规则时会自动执行该方法 // 路由器通过URL进行导航, 导航方式分为pushState, Hash, 和监听方式(详细可参考Backbone.History类) // 在创建Router实例时, 通过options.routes来设置某个路由规则对应的监听方法 // options.routes中的路由规则按照 &#123;规则名称: 方法名称&#125;进行组织, 每一个路由规则所对应的方法, 都必须是在Router实例中的已经声明的方法 // options.routes定义的路由规则按照先后顺序进行匹配, 如果当前URL能被多个规则匹配, 则只会执行第一个匹配的事件方法 var Router = Backbone.Router = function(options) &#123; // options默认是一个空对象 options || ( options = &#123;&#125;); // 如果在options中设置了routes对象(路由规则), 则赋给当前实例的routes属性 // routes属性记录了路由规则与事件方法的绑定关系, 当URL与某一个规则匹配时, 会自动调用关联的事件方法 if(options.routes) this.routes = options.routes; // 解析和绑定路由规则 this._bindRoutes(); // 调用自定义的初始化方法 this.initialize.apply(this, arguments); &#125;; // 定义用于将字符串形式的路由规则, 转换为可执行的正则表达式规则时的查找条件 // (字符串形式的路由规则, 通过\\w+进行匹配, 因此只支持字母数字和下划线组成的字符串) // 匹配一个URL片段中(以/\"斜线\"为分隔)的动态路由规则 // 如: (topic/:id) 匹配 (topic/1228), 监听事件function(id) &#123; // id为1228 &#125; var namedParam = /:\\w+/g; // 匹配整个URL片段中的动态路由规则 // 如: (topic*id) 匹配 (url#/topic1228), 监听事件function(id) &#123; // id为1228 &#125; var splatParam = /\\*\\w+/g; // 匹配URL片段中的特殊字符, 并在字符前加上转义符, 防止特殊字符在被转换为正则表达式后变成元字符 // 如: (abc)^[,.] 将被转换为 \\(abc\\)\\^\\[\\,\\.\\] var escapeRegExp = /[-[\\]&#123;&#125;()+?.,\\\\^$|#\\s]/g; // 向Router类的原型对象中扩展属性和方法 _.extend(Router.prototype, Events, &#123; // 自定义初始化方法, 在路由器Router实例化后被自动调用 initialize : function() &#123; &#125;, // 将一个路由规则绑定给一个监听事件, 当URL片段匹配该规则时, 会自动调用触发该事件 route : function(route, name, callback) &#123; // 创建history实例, Backbone.history是一个单例对象, 只在第一次创建路由器对象时被实例化 Backbone.history || (Backbone.history = new History); // 检查route规则名称是否为一个字符串(当手动调用route方法创建路由规则时, 允许传递一个正则表达式或字符串作为规则) // 在构造Router实例时传入options.routes中的规则, 都应该是一个字符串(因为在_bindRoutes方法中将routes配置中的key作为路由规则) // 如果传入的是字符串类型的路由规则, 通过_routeToRegExp方法将其转换为一个正则表达式, 用于匹配URL片段 if(!_.isRegExp(route)) route = this._routeToRegExp(route); // 如果没有设置callback(事件方法), 则根据name从当前Router实例中获取与name同名的方法 // 这是因为在手动调用route方法时可能不会传递callback方法, 但必须传递name事件名称, 并在Router实例中已经定义了该方法 if(!callback) callback = this[name]; // 调用history实例的route方法, 该方法会将转换后的正则表达式规则, 和监听事件方法绑定到history.handlers列表中, 以便history进行路由和控制 // 当history实例匹配到对应的路由规则而调用该事件时, 会将URL片段作为字符串(即fragment参数)传递给该事件方法 // 这里并没有直接将监听事件传递给history的route方法, 而是使用bind方法封装了另一个函数, 该函数的执行上下文为当前Router对象 Backbone.history.route(route, _.bind(function(fragment) &#123; // 调用_extractParameters方法获取匹配到的规则中的参数 var args = this._extractParameters(route, fragment); // 调用callback路由监听事件, 并将参数传递给监听事件 callback &amp;&amp; callback.apply(this, args); // 触发route:name事件, name为调用route时传递的事件名称 // 如果对当前Router实例使用on方法绑定了route:name事件, 则会收到该事件的触发通知 this.trigger.apply(this, ['route:' + name].concat(args)); // 触发history实例中绑定的route事件, 当路由器匹配到任何规则时, 均会触发该事件 Backbone.history.trigger('route', this, name, args); /** * 事件绑定如: * var router = new MyRouter(); * router.on('route:routename', function(param) &#123; * // 绑定到Router实例中某个规则的事件, 当匹配到该规则时触发 * &#125;); * Backbone.history.on('route', function(router, name, args) &#123; * // 绑定到history实例中的事件, 当匹配到任何规则时触发 * &#125;); * Backbone.history.start(); */ &#125;, this)); return this; &#125;, // 通过调用history.navigate方法, 手动设置跳转到URL navigate : function(fragment, options) &#123; // 代理到history实例的navigate方法 Backbone.history.navigate(fragment, options); &#125;, // 解析当前实例定义的路由(this.routes)规则, 并调用route方法将每一个规则绑定到对应的方法 _bindRoutes : function() &#123; // 如果在创建对象时没有设置routes规则, 则不进行解析和绑定 if(!this.routes) return; // routes变量以二维数组的形式存储倒序排列的路由规则 // 如[['', 'homepage'], ['controller:name', 'toController']] var routes = []; // 遍历routes配置 for(var route in this.routes) &#123; // 将路由规则放入一个新的数组, 按照[规则名称, 绑定方法]组织 // 将该数组通过unshift方法放置到routes顶部, 实现倒序排列 // 这里将routes中的规则倒序排列, 在后面调用route方法时会再次调用unshift将顺序倒过来, 以保证最终的顺序是按照routes配置中定义的顺序来执行的 // 倒换两次顺序后, 会重新恢复最初调用前的顺序, 之所以这样做, 是因为用户可以手动调用route方法动态添加路由规则, 而手动添加的路由规则会被添加到列表的第一个, 因此要在route方法中使用unshift来插入规则 // 而构造Router实例时自动添加的规则, 为了保持定义顺序, 因此在此处将定义的规则倒序排列 routes.unshift([route, this.routes[route]]); &#125; // 循环完毕, 此时routes中存储了倒序排列的路由规则 // 循环路由规则, 并依次调用route方法, 将规则名称绑定到具体的事件函数 for(var i = 0, l = routes.length; i &lt; l; i++) &#123; // 调用route方法, 并分别传递(规则名称, 事件函数名, 事件函数对象) this.route(routes[i][0], routes[i][1], this[routes[i][1]]); &#125; &#125;, // 将字符串形式的路由规则转换为正则表达式对象 // (在route方法中检查到字符串类型的路由规则后, 会自动调用该方法进行转换) _routeToRegExp : function(route) &#123; // 为字符串中特殊字符添加转义符, 防止特殊字符在被转换为正则表达式后变成元字符(这些特殊字符包括-[\\]&#123;&#125;()+?.,\\\\^$|#\\s) // 将字符串中以/\"斜线\"为分隔的动态路由规则转换为([^\\/]+), 在正则中表示以/\"斜线\"开头的多个字符 // 将字符串中的*\"星号\"动态路由规则转换为(.*?), 在正则中表示0或多个任意字符(这里使用了非贪婪模式, 因此你可以使用例如这样的组合路由规则: *list/:id, 将匹配 orderlist/123 , 同时会将\"order\"和\"123\"作为参数传递给事件方法 ) // 请注意namedParam和splatParam替换后的正则表达式都是用()括号将匹配的内容包含起来, 这是为了方便取出匹配的内容作为参数传递给事件方法 // 请注意namedParam和splatParam匹配的字符串 :str, *str中的str字符串是无意义的, 它们会在下面替换后被忽略, 但一般写作和监听事件方法的参数同名, 以便进行标识 route = route.replace(escapeRegExp, '\\\\$&amp;').replace(namedParam, '([^\\/]+)').replace(splatParam, '(.*?)'); // 将转换后的字符串创建为正则表达式对象并返回 // 这个正则表达式将根据route字符串中的规则, 用于匹配URL片段 return new RegExp('^' + route + '$'); &#125;, // 传入一个路由规则(正则表达式)和URL片段(字符串)进行匹配, 并返回从匹配的字符串中获取参数 /** * 例如路由规则为 'teams/:type/:id', 对应的正则表达式会被转换为/^teams/([^/]+)/([^/]+)$/ , (对路由规则转换为正则表达式的过程可参考_routeToRegExp方法) * URL片段为 'teams/35/1228' * 则通过exec执行后的结果为 [\"teams/35/1228\", \"35\", \"1228\"] * 数组中的一个元素是URL片段字符串本身, 从第二个开始则依次为路由规则表达式中的参数 */ _extractParameters : function(route, fragment) &#123; return route.exec(fragment).slice(1); &#125; &#125;); // Backbone.History 路由器管理 // ---------------- // History类提供路由管理相关操作, 包括监听URL的变化, (通过popstate和onhashchange事件进行监听, 对于不支持事件的浏览器通过setInterval心跳监控) // 提供路由规则与当前URL的匹配验证, 和触发相关的监听事件 // History一般不会被直接调用, 在第一次实例化Router对象时, 将自动创建一个History的单例(通过Backbone.history访问) var History = Backbone.History = function() &#123; // handlers属性记录了当前所有路由对象中已经设置的规则和监听列表 // 形式如: [&#123;route: route, callback: callback&#125;], route记录了正则表达式规则, callback记录了匹配规则时的监听事件 // 当history对象监听到URL发生变化时, 会自动与handlers中定义的规则进行匹配, 并调用监听事件 this.handlers = []; // 将checkUrl方法的上下文对象绑定到history对象, 因为checkUrl方法被作为popstate和onhashchange事件或setInterval的回调函数, 在执行回调时, 上下文对象会被改变 // checkUrl方法用于在监听到URL发生变化时检查并调用loadUrl方法 _.bindAll(this, 'checkUrl'); &#125;; // 定义用于匹配URL片段中首字符是否为\"#\"或\"/\"的正则 var routeStripper = /^[#\\/]/; // 定义用于匹配从userAgent中获取的字符串是否包含IE浏览器的标识, 用于判断当前浏览器是否为IE var isExplorer = /msie [\\w.]+/; // 记录当前history单例对象是否已经被初始化过(调用start方法) History.started = false; // 向History类的原型对象中添加方法, 这些方法可以通过History的实例调用(即Backbone.history对象) _.extend(History.prototype, Events, &#123; // 当用户使用低版本的IE浏览器(不支持onhashchange事件)时, 通过心跳监听路由状态的变化 // interval属性设置心跳频率(毫秒), 该频率如果太低可能会导致延迟, 如果太高可能会消耗CPU资源(需要考虑用户使用低端浏览器时的设备配置) interval : 50, // 获取location中Hash字符串(锚点#后的片段) getHash : function(windowOverride) &#123; // 如果传入了一个window对象, 则从该对象中获取, 否则默认从当前window对象中获取 var loc = windowOverride ? windowOverride.location : window.location; // 将锚点(#)后的字符串提取出来并返回 var match = loc.href.match(/#(.*)$/); // 如果没有找到匹配的内容, 则返回空字符串 return match ? match[1] : ''; &#125;, // 根据当前设置的路由方式, 处理并返回当前URL中的路由片段 getFragment : function(fragment, forcePushState) &#123; // fragment是通过getHash或从URL中已经提取的待处理路由片段(如 #/id/1288) if(fragment == null) &#123;// 如果没有传递fragment, 则根据当前路由方式进行提取 if(this._hasPushState || forcePushState) &#123; // 使用了pushState方式进行路由 // fragment记录当前域名后的URL路径 fragment = window.location.pathname; // search记录当前页面后的参数内容 var search = window.location.search; // 将路径和参数合并在一起, 作为待处理的路由片段 if(search) fragment += search; &#125; else &#123; // 使用了hash方式进行路由 // 通过getHash方法获取当前锚点(#)后的字符串作为路由片段 fragment = this.getHash(); &#125; &#125; // 根据配置项中设置的root参数, 则从路由片段取出root路径之后的内容 if(!fragment.indexOf(this.options.root)) fragment = fragment.substr(this.options.root.length); // 如果URL片段首字母为\"#\"或\"/\", 则去除该字符 // 返回处理之后的URL片段 return fragment.replace(routeStripper, ''); &#125;, // 初始化History实例, 该方法只会被调用一次, 应该在创建并初始化Router对象之后被自动调用 // 该方法作为整个路由的调度器, 它将针对不同浏览器监听URL片段的变化, 负责验证并通知到监听函数 start : function(options) &#123; // 如果history对象已经被初始化过, 则抛出错误 if(History.started) throw new Error(\"Backbone.history has already been started\"); // 设置history对象的初始化状态 History.started = true; // 设置配置项, 使用调用start方法时传递的options配置项覆盖默认配置 this.options = _.extend(&#123;&#125;, &#123; // root属性设置URL导航中的路由根目录 // 如果使用pushState方式进行路由, 则root目录之后的地址会根据不同的路由产生不同的地址(这可能会定位到不同的页面, 因此需要确保服务器支持) // 如果使用Hash锚点的方式进行路由, 则root表示URL后锚点(#)的位置 root : '/' &#125;, this.options, options); /** * history针对不同浏览器特性, 实现了3种方式的监听: * - 对于支持HTML5中popstate事件的浏览器, 通过popstate事件进行监听 * - 对于不支持popstate的浏览器, 使用onhashchange事件进行监听(通过改变hash(锚点)设置的URL在被载入时会触发onhashchange事件) * - 对于不支持popstate和onhashchange事件的浏览器, 通过保持心跳监听 * * 关于HTML5中popstate事件的相关方法: * - pushState可以将指定的URL添加一个新的history实体到浏览器历史里 * - replaceState方法可以将当前的history实体替换为指定的URL * 使用pushState和replaceState方法时仅替换当前URL, 而并不会真正转到这个URL(当使用后退或前进按钮时, 也不会跳转到该URL) * (这两个方法可以解决在AJAX单页应用中浏览器前进, 后退操作的问题) * 当使用pushState或replaceState方法替换的URL, 在被载入时会触发onpopstate事件 * 浏览器支持情况: * Chrome 5, Firefox 4.0, IE 10, Opera 11.5, Safari 5.0 * * 注意: * - history.start方法默认使用Hash方式进行导航 * - 如果需要启用pushState方式进行导航, 需要在调用start方法时, 手动传入配置options.pushState * (设置前请确保浏览器支持pushState特性, 否则将默认转换为Hash方式) * - 当使用pushState方式进行导航时, URL可能会从options.root指定的根目录后发生变化, 这可能会导航到不同页面, 因此请确保服务器已经支持pushState方式的导航 */ // _wantsHashChange属性记录是否希望使用hash(锚点)的方式来记录和导航路由器 // 除非在options配置项中手动设置hashChange为false, 否则默认将使用hash锚点的方式 // (如果手动设置了options.pushState为true, 且浏览器支持pushState特性, 则会使用pushState方式) this._wantsHashChange = this.options.hashChange !== false; // _wantsPushState属性记录是否希望使用pushState方式来记录和导航路由器 // pushState是HTML5中为window.history添加的新特性, 如果没有手动声明options.pushState为true, 则默认将使用hash方式 this._wantsPushState = !!this.options.pushState; // _hasPushState属性记录浏览器是否支持pushState特性 // 如果在options中设置了pushState(即希望使用pushState方式), 则检查浏览器是否支持该特性 this._hasPushState = !!(this.options.pushState &amp;&amp; window.history &amp;&amp; window.history.pushState); // 获取当前URL中的路由字符串 var fragment = this.getFragment(); // documentMode是IE浏览器的独有属性, 用于标识当前浏览器使用的渲染模式 var docMode = document.documentMode; // oldIE用于检查当前浏览器是否为低版本的IE浏览器(即IE 7.0以下版本) // 这句代码可理解为: 当前浏览器为IE, 但不支持documentMode属性, 或documentMode属性返回的渲染模式为IE7.0以下 var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) &amp;&amp; (!docMode || docMode &lt;= 7)); if(oldIE) &#123; // 如果用户使用低版本的IE浏览器, 不支持popstate和onhashchange事件 // 向DOM中插入一个隐藏的iframe, 并通过改变和心跳监听该iframe的URL实现路由 this.iframe = $('&lt;iframe src=\"javascript:0\" tabindex=\"-1\" /&gt;').hide().appendTo('body')[0].contentWindow; // 通过navigate将iframe设置到当前的URL片段, 这并不会真正加载到一个页面, 因为fragment并非一个完整的URL this.navigate(fragment); &#125; // 开始监听路由状态变化 if(this._hasPushState) &#123; // 如果使用了pushState方式路由, 且浏览器支持该特性, 则将popstate事件监听到checkUrl方法 $(window).bind('popstate', this.checkUrl); &#125; else if(this._wantsHashChange &amp;&amp; ('onhashchange' in window) &amp;&amp; !oldIE) &#123; // 如果使用Hash方式进行路由, 且浏览器支持onhashchange事件, 则将hashchange事件监听到checkUrl方法 $(window).bind('hashchange', this.checkUrl); &#125; else if(this._wantsHashChange) &#123; // 对于低版本的浏览器, 通过setInterval方法心跳监听checkUrl方法, interval属性标识心跳频率 this._checkUrlInterval = setInterval(this.checkUrl, this.interval); &#125; // 记录当前的URL片段 this.fragment = fragment; // 验证当前是否处于根路径(即options.root中所配置的路径) var loc = window.location; var atRoot = loc.pathname == this.options.root; // 如果用户通过pushState方式的URL访问到当前地址, 但用户此时所使用的浏览器并不支持pushState特性 // (这可能是某个用户通过pushState方式访问该应用, 然后将地址分享给其他用户, 而其他用户的浏览器并不支持该特性) if(this._wantsHashChange &amp;&amp; this._wantsPushState &amp;&amp; !this._hasPushState &amp;&amp; !atRoot) &#123; // 获取当前pushState方式中的URL片段, 并通过Hash方式重新打开页面 this.fragment = this.getFragment(null, true); // 例如hashState方式的URL为 /root/topic/12001, 重新打开的Hash方式的URL则为 /root#topic/12001 window.location.replace(this.options.root + '#' + this.fragment); return true; // 如果用户通过Hash方式的URL访问到当前地址, 但调用Backbone.history.start方法时设置了pushState(希望通过pushState方式进行路由) // 且用户浏览器支持pushState特性, 则将当前URL替换为pushState方式(注意, 这里使用replaceState方式进行替换URL, 而页面不会被刷新) // 以下分支条件可理解为: 如果我们希望使用pushState方式进行路由, 且浏览器支持该特性, 同时用户还使用了Hash方式打开当前页面 // (这可能是某个用户使用Hash方式浏览到一个URL, 并将URL分享给另一个浏览器支持pushState特性的用户, 当该用户访问时会执行此分支) &#125; else if(this._wantsPushState &amp;&amp; this._hasPushState &amp;&amp; atRoot &amp;&amp; loc.hash) &#123; // 获取URL中的Hash片段, 并清除字符串首个\"#\"或\"/\" this.fragment = this.getHash().replace(routeStripper, ''); // 使用replaceState方法将当前浏览器的URL替换为pushState支持的方式, 即: 协议//主机地址/URL路径/Hash参数, 例如: // 当用户访问Hash方式的URL为 /root/#topic/12001, 将被替换为 /root/topic/12001 // 注: // pushState和replaceState方法的参数有3个, 分别是state, title, url // -state: 用于存储插入或修改的history实体信息 // -title: 用于设置浏览器标题(属于保留参数, 目前浏览器还没有实现该特性) // -url: 设置history实体的URL地址(可以是绝对或相对路径, 但无法设置跨域URL) window.history.replaceState(&#123;&#125;, document.title, loc.protocol + '//' + loc.host + this.options.root + this.fragment); &#125; // 一般调用start方法时会自动调用loadUrl, 匹配当前URL片段对应的路由规则, 调用该规则的方法 // 如果设置了silent属性为true, 则loadUrl方法不会被调用 // 这种情况一般出现在调用了stop方法重置history对象状态后, 再次调用start方法启动(实际上此时并非为页面初始化, 因此会设置silent属性) if(!this.options.silent) &#123; return this.loadUrl(); &#125; &#125;, // 停止history对路由的监控, 并将状态恢复为未监听状态 // 调用stop方法之后, 可重新调用start方法开始监听, stop方法一般用户在调用start方法之后, 需要重新设置start方法的参数, 或用于单元测试 stop : function() &#123; // 解除对浏览器路由的onpopstate和onhashchange事件的监听 $(window).unbind('popstate', this.checkUrl).unbind('hashchange', this.checkUrl); // 停止对于低版本的IE浏览器的心跳监控 clearInterval(this._checkUrlInterval); // 恢复started状态, 便于下次重新调用start方法 History.started = false; &#125;, // 向handlers中绑定一个路由规则(参数route, 类型为正则表达式)与事件(参数callback)的映射关系(该方法由Router的实例自动调用) route : function(route, callback) &#123; // 将route和callback插入到handlers列表的第一个位置 // 这是为了确保最后调用route时传入的规则被优先进行匹配 this.handlers.unshift(&#123; // 路由规则(正则) route : route, // 匹配规则时执行的方法 callback : callback &#125;); &#125;, // 检查当前的URL相对上一次的状态是否发生了变化 // 如果发生变化, 则记录新的URL状态, 并调用loadUrl方法触发新URL与匹配路由规则的方法 // 该方法在onpopstate和onhashchange事件被触发后自动调用, 或者在低版本的IE浏览器中由setInterval心跳定时调用 checkUrl : function(e) &#123; // 获取当前的URL片段 var current = this.getFragment(); // 对低版本的IE浏览器, 将从iframe中获取最新的URL片段并赋给current变量 if(current == this.fragment &amp;&amp; this.iframe) current = this.getFragment(this.getHash(this.iframe)); // 如果当前URL与上一次的状态没有发生任何变化, 则停止执行 if(current == this.fragment) return false; // 执行到这里, URL已经发生改变, 调用navigate方法将URL设置为当前URL // 这里在自动调用navigate方法时, 并没有传递options参数, 因此不会触发navigate方法中的loadUrl方法 if(this.iframe) this.navigate(current); // 调用loadUrl方法, 检查匹配的规则, 并执行规则绑定的方法 // 如果调用this.loadUrl方法没有成功, 则试图在调用loadUrl方法时, 将重新获取的当前Hash传递给该方法 this.loadUrl() || this.loadUrl(this.getHash()); &#125;, // 根据当前URL, 与handler路由列表中的规则进行匹配 // 如果URL符合某一个规则, 则执行这个规则所对应的方法, 函数将返回true // 如果没有找到合适的规则, 将返回false // loadUrl方法一般在页面初始化时调用start方法会被自动调用(除非设置了silent参数为true) // - 或当用户改变URL后, 由checkUrl监听到URL发生变化时被调用 // - 或当调用navigate方法手动导航到某个URL时被调用 loadUrl : function(fragmentOverride) &#123; // 获取当前URL片段 var fragment = this.fragment = this.getFragment(fragmentOverride); // 调用Undersocre的any方法, 将URL片段与handlers中的所有规则依次进行匹配 var matched = _.any(this.handlers, function(handler) &#123; // 如果handlers中的规则与当前URL片段匹配, 则执行该归额对应的方法, 并返回true if(handler.route.test(fragment)) &#123; handler.callback(fragment); return true; &#125; &#125;); // matched是any方法的返回值, 如果匹配到规则则返回true, 没有匹配到返回false return matched; &#125;, // 导航到指定的URL // 如果在options中设置了trigger, 将触发导航的URL与对应路由规则的事件 // 如果在options中设置了replace, 将使用需要导航的URL替换当前的URL在history中的位置 navigate : function(fragment, options) &#123; // 如果没有调用start方法, 或已经调用stop方法, 则无法导航 if(!History.started) return false; // 如果options参数不是一个对象, 而是true值, 则默认trigger配置项为true(即触发导航的URL与对应路由规则的事件) if(!options || options === true) options = &#123; trigger : options &#125;; // 将传递的fragment(URL片段)去掉首字符的\"#\"或\"/\" var frag = (fragment || '').replace(routeStripper, ''); // 如果当前URL与需要导航的URL没有变化, 则不继续执行 if(this.fragment == frag) return; // 如果当前支持并使用了pushState方式进行导航 if(this._hasPushState) &#123; // 构造一个完整的URL, 如果当前URL片段中没有包含根路径, 则使用根路径连接URL片段 if(frag.indexOf(this.options.root) != 0) frag = this.options.root + frag; // 设置新的URL this.fragment = frag; // 如果在options选项中设置了replace属性, 则将新的URL替换到history中的当前URL, 否则默认将新的URL追加到history中 window.history[options.replace ? 'replaceState' : 'pushState'](&#123;&#125;, document.title, frag); // 如果使用hash方式进行导航 &#125; else if(this._wantsHashChange) &#123; // 设置新的hash this.fragment = frag; // 调用_updateHash方法更新当前URL为新的hash, 并将options中的replace配置传递给_updateHash方法(在该方法中实现替换或追加新的hash) this._updateHash(window.location, frag, options.replace); // 对于低版本的IE浏览器, 当Hash发生变化时, 更新iframe URL中的Hash if(this.iframe &amp;&amp; (frag != this.getFragment(this.getHash(this.iframe)))) &#123; // 如果使用了replace参数替换当前URL, 则直接将iframe替换为新的文档 // 调用document.open打开一个新的文档, 以擦除当前文档中的内容(这里调用close方法是为了关闭文档的状态) // open和close方法之间没有使用write或writeln方法输出内容, 因此这是一个空文档 if(!options.replace) this.iframe.document.open().close(); // 调用_updateHash方法更新iframe中的URL this._updateHash(this.iframe.location, frag, options.replace); &#125; &#125; else &#123; // 如果在调用start方法时, 手动设置hashChange参数为true, 不希望使用pushState和hash方式导航 // 则直接将页面跳转到新的URL window.location.assign(this.options.root + fragment); &#125; // 如果在options配置项中设置了trigger属性, 则调用loadUrl方法查找路由规则, 并执行规则对应的事件 // 在URL发生变化时, 通过checkUrl方法监听到的状态, 会在checkUrl方法中自动调用loadUrl方法 // 在手动调用navigate方法时, 如果需要触发路由事件, 则需要传递trigger参数 if(options.trigger) this.loadUrl(fragment); &#125;, // 更新或设置当前URL中的Has串, _updateHash方法在使用hash方式导航时被自动调用(navigate方法中) // location是需要更新hash的window.location对象 // fragment是需要更新的hash串 // 如果需要将新的hash替换到当前URL, 可以设置replace为true _updateHash : function(location, fragment, replace) &#123; // 如果设置了replace为true, 则使用location.replace方法替换当前的URL // 使用replace方法替换URL后, 新的URL将占有原有URL在history历史中的位置 if(replace) &#123; // 将当前URL与hash组合为一个完整的URL并替换 location.replace(location.toString().replace(/(javascript:|#).*$/, '') + '#' + fragment); &#125; else &#123; // 没有使用替换方式, 直接设置location.hash为新的hash串 location.hash = fragment; &#125; &#125; &#125;); // Backbone.View 视图相关 // ------------- // 视图类用于创建与数据低耦合的界面控制对象, 通过将视图的渲染方法绑定到数据模型的change事件, 当数据发生变化时会通知视图进行渲染 // 视图对象中的el用于存储当前视图所需要操作的DOM最父层元素, 这主要是为了提高元素的查找和操作效率, 其优点包括: // - 查找或操作元素时, 将操作的范围限定在el元素内, 不需要再整个文档树中搜索 // - 在为元素绑定事件时, 可以方便地将事件绑定到el元素(默认也会绑定到el元素)或者是其子元素 // - 在设计模式中, 将一个视图相关的元素, 事件, 和逻辑限定在该视图的范围中, 降低视图与视图间的耦合(至少在逻辑上是这样) var View = Backbone.View = function(options) &#123; // 为每一个视图对象创建一个唯一标识, 前缀为\"view\" this.cid = _.uniqueId('view'); // 设置初始化配置 this._configure(options || &#123;&#125;); // 设置或创建视图中的元素 this._ensureElement(); // 调用自定义的初始化方法 this.initialize.apply(this, arguments); // 解析options中设置的events事件列表, 并将事件绑定到视图中的元素 this.delegateEvents(); &#125;; // 定义用于解析events参数中事件名称和元素的正则 var delegateEventSplitter = /^(\\S+)\\s*(.*)$/; // viewOptions列表记录一些列属性名, 在构造视图对象时, 如果传递的配置项中包含这些名称, 则将属性复制到对象本身 var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName']; // 向视图类的原型对象中添加一些方法 _.extend(View.prototype, Events, &#123; // 如果在创建视图对象时, 没有设置指定的el元素, 则会通过make方法创建一个元素, tagName为创建元素的默认标签 // 也可以通过在options中自定义tagName来覆盖默认的\"div\"标签 tagName : 'div', // 每个视图中都具有一个$选择器方法, 该方法与jQuery或Zepto类似, 通过传递一个表达式来获取元素 // 但该方法只会在视图对象的$el元素范围内进行查找, 因此会提高匹配效率 $ : function(selector) &#123; return this.$el.find(selector); &#125;, // 初始化方法, 在对象被实例化后自动调用 initialize : function() &#123; &#125;, // render方法与initialize方法类似, 默认没有实现任何逻辑 // 一般会重载该方法, 以实现对视图中元素的渲染 render : function() &#123; // 返回当前视图对象, 以支持方法的链式操作 // 因此如果重载了该方法, 建议在方法最后也返回视图对象(this) return this; &#125;, // 移除当前视图的$el元素 remove : function() &#123; // 通过调用jQuery或Zepto的remove方法, 因此在第三方库中会同时移除该元素绑定的所有事件和数据 this.$el.remove(); return this; &#125;, // 根据传入的标签名称, 属性和内容, 创建并返回一个DOM元素 // 该方法用于在内部创建this.el时自动调用 make : function(tagName, attributes, content) &#123; // 根据tagName创建元素 var el = document.createElement(tagName); // 设置元素属性 if(attributes) $(el).attr(attributes); // 设置元素内容 if(content) $(el).html(content); // 返回元素 return el; &#125;, // 为视图对象设置标准的$el及el属性, 该方法在对象创建时被自动调用 // $el是通过jQuery或Zepto创建的对象, el是标准的DOM对象 setElement : function(element, delegate) &#123; // 如果已经存在了$el属性(可能是手动调用了setElement方法切换视图的元素), 则取消之前对$el绑定的events事件(详细参考undelegateEvents方法) if(this.$el) this.undelegateEvents(); // 将元素创建为jQuery或Zepto对象, 并存放在$el属性中 this.$el = ( element instanceof $) ? element : $(element); // this.el存放标准的DOM对象 this.el = this.$el[0]; // 如果设置了delegate参数, 则为元素绑定视图中events参数设置的事件 // 在视图类的构造函数中, 已经调用了delegateEvents方法进行绑定, 因此在初始化的_ensureElement方法中调用setElement方法时没有传递delegate参数 // 在手动调用setElemen方法设置视图元素时, 允许传递delegate绑定事件 if(delegate !== false) this.delegateEvents(); return this; &#125;, // 为视图元素绑定事件 // events参数配置了需要绑定事件的集合, 格式如('事件名称 元素选择表达式' : '事件方法名称/或事件函数'): // &#123; // 'click #title': 'edit', // 'click .save': 'save' // 'click span': function() &#123;&#125; // &#125; // 该方法在视图对象初始化时会被自动调用, 并将对象中的events属性作为events参数(事件集合) delegateEvents : function(events) &#123; // 如果没有手动传递events参数, 则从视图对象获取events属性作为事件集合 if(!(events || ( events = getValue(this, 'events')))) return; // 取消当前已经绑定过的events事件 this.undelegateEvents(); // 遍历需要绑定的事件列表 for(var key in events) &#123; // 获取需要绑定的方法(允许是方法名称或函数) var method = events[key]; // 如果是方法名称, 则从对象中获取该函数对象, 因此该方法名称必须是视图对象中已定义的方法 if(!_.isFunction(method)) method = this[events[key]]; // 对无效的方法抛出一个错误 if(!method) throw new Error('Method \"' + events[key] + '\" does not exist'); // 解析事件表达式(key), 从表达式中解析出事件的名字和需要操作的元素 // 例如 'click #title'将被解析为 'click' 和 '#title' 两部分, 均存放在match数组中 var match = key.match(delegateEventSplitter); // eventName为解析后的事件名称 // selector为解析后的事件元素选择器表达式 var eventName = match[1], selector = match[2]; // bind方法是Underscore中用于绑定函数上下文的方法 // 这里将method事件方法的上下文绑定到当前视图对象, 因此在事件被触发后, 事件方法中的this始终指向视图对象本身 method = _.bind(method, this); // 设置事件名称, 在事件名称后追加标识, 用于传递给jQuery或Zepto的事件绑定方法 eventName += '.delegateEvents' + this.cid; // 通过jQuery或Zepto绑定事件 if(selector === '') &#123; // 如果没有设置子元素选择器, 则通过bind方法将事件和方法绑定到当前$el元素本身 this.$el.bind(eventName, method); &#125; else &#123; // 如果当前设置了子元素选择器表达式, 则通过delegate方式绑定 // 该方法将查找当前$el元素下的子元素, 并将于selector表达式匹配的元素进行事件绑定 // 如果该选择器的元素不属于当前$el的子元素, 则事件绑定无效 this.$el.delegate(selector, eventName, method); &#125; &#125; &#125;, // 取消视图中当前元素绑定的events事件, 该方法一般不会被使用 // 除非调用delegateEvents方法重新为视图中的元素绑定事件, 在重新绑定之前会清除当前的事件 // 或通过setElement方法重新设置试图的el元素, 也会清除当前元素的事件 undelegateEvents : function() &#123; this.$el.unbind('.delegateEvents' + this.cid); &#125;, // 在实例化视图对象时设置初始配置 // 将传递的配置覆盖到对象的options中 // 将配置中与viewOptions列表相同的配置复制到对象本身, 作为对象的属性 _configure : function(options) &#123; // 如果对象本身设置了默认配置, 则使用传递的配置进行合并 if(this.options) options = _.extend(&#123;&#125;, this.options, options); // 遍历viewOptions列表 for(var i = 0, l = viewOptions.length; i &lt; l; i++) &#123; // attr依次为viewOptions中的属性名 var attr = viewOptions[i]; // 将options配置中与viewOptions相同的配置复制到对象本身, 作为对象的属性 if(options[attr]) this[attr] = options[attr]; &#125; // 设置对象的options配置 this.options = options; &#125;, // 每一个视图对象都应该有一个el元素, 作为渲染的元素 // 在构造视图时, 可以设置对象的el属性来指定一个元素 // 如果设置的el是一个字符串或DOM对象, 则通过$方法将其创建为一个jQuery或Zepto对象 // 如果没有设置el属性, 则根据传递的tagName, id和className, 调用mak方法创建一个元素 // (新创建的元素不会被添加到文档树中, 而始终存储在内存, 当处理完毕需要渲染到页面时, 一般会在重写的render方法, 或自定义方法中, 访问this.el将其追加到文档) // (如果我们需要向页面添加一个目前还没有的元素, 并且需要为其添加一些子元素, 属性, 样式或事件时, 可以通过该方式先将元素创建到内存, 在完成所有操作之后再手动渲染到文档, 可以提高渲染效率) _ensureElement : function() &#123; // 如果没有设置el属性, 则创建默认元素 if(!this.el) &#123; // 从对象获取attributes属性, 作为新创建元素的默认属性列表 var attrs = getValue(this, 'attributes') || &#123;&#125;; // 设置新元素的id if(this.id) attrs.id = this.id; // 设置新元素的class if(this.className) attrs['class'] = this.className; // 通过make方法创建元素, 并调用setElement方法将元素设置为视图所使用的标准元素 this.setElement(this.make(this.tagName, attrs), false); &#125; else &#123; // 如果设置了el属性, 则直接调用setElement方法将el元素设置为视图的标准元素 this.setElement(this.el, false); &#125; &#125; &#125;); // 实现对象继承的函数, 该函数内部使用inherits实现继承, 请参考inherits函数 var extend = function(protoProps, classProps) &#123; // child存储已经实现继承自当前类的子类(Function) // protoProps设置子类原型链中的属性 // classProps设置子类的静态属性 var child = inherits(this, protoProps, classProps); // 将extend函数添加到子类, 因此调用子类的extend方法便可实现对子类的继承 child.extend = this.extend; // 返回实现继承的子类 return child; &#125;; // 为Model, Collection, Router和View类实现继承机制 Model.extend = Collection.extend = Router.extend = View.extend = extend; // Backbone.sync 与服务器异步交互相关 // ------------- // 定义Backbone中与服务器交互方法和请求type的对应关系 var methodMap = &#123; 'create' : 'POST', 'update' : 'PUT', 'delete' : 'DELETE', 'read' : 'GET' &#125;; // sync用于在Backbone中操作数据时, 向服务器发送请求同步数据状态, 以建立与服务器之间的无缝连接 // sync发送默认通过第三方库(jQuery, Zepto等) $.ajax方法发送请求, 因此如果要调用状态同步相关的方法, 需要第三方库支持 // Backbone默认定义了一套与服务器交互的数据格式(JSON)和结构, 服务器响应的数据应该遵循该约定 // 如果数据不需要保存在服务器, 或与服务器交互方法, 数据格式结构与约定不一致, 可以通过重载sync方法实现 // @param &#123;String&#125; method 在Backbone中执行的CRUD操作名称 // @param &#123;Model Obejct&#125; model 需要与服务器同步状态的模型对象 // @param &#123;Object&#125; options Backbone.sync = function(method, model, options) &#123; // 根据CRUD方法名定义与服务器交互的方法(POST, GET, PUT, DELETE) var type = methodMap[method]; // options默认为一个空对象 options || ( options = &#123;&#125;); // params将作为请求参数对象传递给第三方库的$.ajax方法 var params = &#123; // 请求类型 type : type, // 数据格式默认为json dataType : 'json' &#125;; // 如果在发送请求时没有在options中设置url地址, 将会通过模型对象的url属性或方法来获取url // 模型所获取url的方式可参考模型的url方法 if(!options.url) &#123; // 获取请求地址失败时会调用urlError方法抛出一个错误 params.url = getValue(model, 'url') || urlError(); &#125; // 如果调用create和update方法, 且没有在options中定义请求数据, 将序列化模型中的数据对象传递给服务器 if(!options.data &amp;&amp; model &amp;&amp; (method == 'create' || method == 'update')) &#123; // 定义请求的Content-Type头, 默认为application/json params.contentType = 'application/json'; // 序列化模型中的数据, 并作为请求数据传递给服务器 params.data = JSON.stringify(model.toJSON()); &#125; // 对于不支持application/json编码的浏览器, 可以通过设置Backbone.emulateJSON参数为true实现兼容 if(Backbone.emulateJSON) &#123; // 不支持Backbone.emulateJSON编码的浏览器, 将类型设置为application/x-www-form-urlencoded params.contentType = 'application/x-www-form-urlencoded'; // 将需要同步的数据存放在key为\"model\"参数中发送到服务器 params.data = params.data ? &#123; model : params.data &#125; : &#123;&#125;; &#125; // 对于不支持REST方式的浏览器, 可以设置Backbone.emulateHTTP参数为true, 以POST方式发送数据, 并在数据中加入_method参数标识操作名称 // 同时也将发送X-HTTP-Method-Override头信息 if(Backbone.emulateHTTP) &#123; // 如果操作类型为PUT或DELETE if(type === 'PUT' || type === 'DELETE') &#123; // 将操作名称存放到_method参数发送到服务器 if(Backbone.emulateJSON) params.data._method = type; // 实际以POST方式进行提交, 并发送X-HTTP-Method-Override头信息 params.type = 'POST'; params.beforeSend = function(xhr) &#123; xhr.setRequestHeader('X-HTTP-Method-Override', type); &#125;; &#125; &#125; // 对非GET方式的请求, 将不对数据进行转换, 因为传递的数据可能是一个JSON映射 if(params.type !== 'GET' &amp;&amp; !Backbone.emulateJSON) &#123; // 通过设置processData为false来关闭数据转换 // processData参数是$.ajax方法中的配置参数, 详细信息可参考jQuery或Zepto相关文档 params.processData = false; &#125; // 通过第三方库的$.ajax方法向服务器发送请求同步数据状态 // 传递给$.ajax方法的参数使用extend方法将options对象中的参数覆盖到了params对象, 因此在调用sync方法时设置了与params同名的options参数, 将以options为准 return $.ajax(_.extend(params, options)); &#125;; // 包装一个统一的模型错误处理方法, 会在模型与服务器交互发生错误时被调用 // onError是在调用与服务器的交互方法时(如fetch, destory等), options中指定的自定义错误处理函数 // originalModel是发生错误的模型或集合对象 Backbone.wrapError = function(onError, originalModel, options) &#123; return function(model, resp) &#123; resp = model === originalModel ? resp : model; if(onError) &#123; // 如果设置了自定义错误处理方法, 则调用自定义方法 onError(originalModel, resp, options); &#125; else &#123; // 默认将触发发生错误的模型或集合的error事件 originalModel.trigger('error', originalModel, resp, options); &#125; &#125;; &#125;; // Helpers 定义一些供Backbone内部使用的帮助函数 // ------- // ctor是一个共享的空函数, 用于在调用inherits方法实现继承时, 承载父类的原型链以便设置到子类原型中 var ctor = function() &#123; &#125;; // 实现OOP继承特性 // @param &#123;Function&#125; parent 被继承的父类Function // @param &#123;Object&#125; protoProps 扩展子类原型中的属性(或方法)对象 // @param &#123;Object&#125; staticProps 扩展子类的静态属性(或方法)对象 var inherits = function(parent, protoProps, staticProps) &#123; var child; // 如果在protoProps中指定了\"constructor\"属性, 则\"constructor\"属性被作为子类的构造函数 // 如果没有指定构造子类构造函数, 则默认调用父类的构造函数 if(protoProps &amp;&amp; protoProps.hasOwnProperty('constructor')) &#123; // 使用\"constructor\"属性指定的子类构造函数 child = protoProps.constructor; &#125; else &#123; // 使用父类的构造函数 child = function() &#123; parent.apply(this, arguments); &#125;; &#125; // 将父类中的静态属性复制为子类静态属性 _.extend(child, parent); // 将父类原型链设置到子类的原型对象中, 子类以此继承父类原型链中的所有属性 ctor.prototype = parent.prototype; child.prototype = new ctor(); // 将protoProps对象中的属性复制到子类的原型对象, 子类以此拥有protoProps中的属性 if(protoProps) _.extend(child.prototype, protoProps); // 将staticProps对象中的属性复制到子类的构造函数本身, 将staticProps中的属性作为子类的静态属性 if(staticProps) _.extend(child, staticProps); // 在复制父类原型链到子类原型时, 子类原型链中的构造函数已经被覆盖, 因此此处重新设置子类的构造函数 child.prototype.constructor = child; // 如果子类设置了constructor属性, 则子类构造函数为constructor指定的函数 // 如果需要在子类构造函数中调用父类构造函数, 则需要在子类构造函数中手动调用父类的构造函数 // 此处将子类的__super__属性指向父类的构造函数, 方便在子类中调用: 子类.__super__.constructor.call(this); child.__super__ = parent.prototype; // 返回子类 return child; &#125;; // 获取对象prop属性的值, 如果prop属性是一个函数, 则执行并返回该函数的返回值 var getValue = function(object, prop) &#123; // 如果object为空或object不存在prop属性, 则返回null if(!(object &amp;&amp; object[prop])) return null; // 返回prop属性值, 如果prop是一个函数, 则执行并返回该函数的返回值 return _.isFunction(object[prop]) ? object[prop]() : object[prop]; &#125;; // 抛出一个Error异常, 在Backbone内部会频繁执行, 因此独立为一个公共函数 var urlError = function() &#123; throw new Error('A \"url\" property or function must be specified'); &#125;;&#125;).call(this);","tags":[{"name":"backbone","slug":"backbone","permalink":"http://zqianduan.com/tags/backbone/"}]},{"title":"JavaScript 实现简单的双向数据绑定（译）","date":"2016-03-02T09:04:05.000Z","path":"2016/03/02/easy-two-way-data-binding-in-javascript/","text":"双向数据绑定指的就是，绑定对象属性的改变到用户界面的变化的能力，反之亦然。换种说法，如果我们有一个 user 对象和一个 name 属性，一旦我们赋了一个新值给 user.name，在 UI 上就会显示新的姓名了。同样地，如果 UI 包含了一个输入用户姓名的输入框，输入一个新值就应该会使 user 对象的 name 属性做出相应的改变。 很多热门的 JS 框架客户端如 Ember.js，Angular.js 或者 KnockoutJS，都在最新特性上刊登了双向数据绑定。这并不意味着从零实现它很难，也不是说需要这些功能的时候，采用这些框架是唯一的选择。下面的想法实际上很基础，可以被认为是3步走计划： 我们需要一个 UI 元素和属性相互绑定的方法 我们需要监视属性和 UI 元素的变化 我们需要让所有绑定的对象和元素都能感知到变化 还是有很多方法能够实现上面的想法，有一个简单有效的方法就是使用 PubSub 模式。 这个思路很简单：我们使用数据特性来为 HTML 代码进行绑定，所有被绑定在一起的 JavaScript 对象和 DOM 元素都会订阅一个 PubSub 对象。只要 JavaScript 对象或者一个 HTML 输入元素监听到数据的变化时，就会触发绑定到 PubSub 对象上的事件，从而其他绑定的对象和元素都会做出相应的变化。 用 jQuery 做一个简单的实现对于DOM事件的订阅和发布，用 jQuery 实现起来是非常简单的，接下来我们就是用 jQuery 比如下面： 123456789101112131415161718192021222324252627282930313233function DataBinder(object_id) &#123; // Use a jQuery object as simple PubSub var pubSub = jQuery(&#123;&#125;); // We expect a `data` element specifying the binding // in the form: data-bind-&lt;object_id&gt;=\"&lt;property_name&gt;\" var data_attr = \"bind-\" + object_id, message = object_id + \":change\"; // Listen to change events on elements with the data-binding attribute and proxy // them to the PubSub, so that the change is \"broadcasted\" to all connected objects jQuery(document).on(\"change\", \"[data-\" + data_attr + \"]\", function(evt) &#123; var $input = jQuery(this); pubSub.trigger(message, [$input.data(data_attr), $input.val()]); &#125;); // PubSub propagates changes to all bound elements, setting value of // input tags or HTML content of other tags pubSub.on(message, function(evt, prop_name, new_val) &#123; jQuery(\"[data-\" + data_attr + \"=\" + prop_name + \"]\").each(function() &#123; var $bound = jQuery(this); if ($bound.is(\"input, textarea, select\")) &#123; $bound.val(new_val); &#125; else &#123; $bound.html(new_val); &#125; &#125;); &#125;); return pubSub;&#125; 对于上面这个实现来说，下面是一个 User 模型的最简单的实现方法： 12345678910111213141516171819202122232425262728function User(uid) &#123; var binder = new DataBinder(uid), user = &#123; attributes: &#123;&#125;, // The attribute setter publish changes using the DataBinder PubSub set: function(attr_name, val) &#123; this.attributes[attr_name] = val; binder.trigger(uid + \":change\", [attr_name, val, this]); &#125;, get: function(attr_name) &#123; return this.attributes[attr_name]; &#125;, _binder: binder &#125;; // Subscribe to the PubSub binder.on(uid + \":change\", function(evt, attr_name, new_val, initiator) &#123; if (initiator !== user) &#123; user.set(attr_name, new_val); &#125; &#125;); return user;&#125; 现在我们如果想要将 User 模型属性绑定到UI上，我们只需要将适合的数据特性绑定到对应的 HTML 元素上。 12345678// javascript&lt;script&gt; var user = new User( 123 ); user.set( \"name\", \"Wolfgang\" ); &lt;/script&gt; // html&lt;input type=\"number\" data-bind-123=\"name\" /&gt; 不需要 jQuery 的实现在如今的大多数项目里，可能已经使用了 jQuery，因此上面的例子完全可以接受。不过，如果我们需要试着向另一个极端做，并且还删除对 jQuery 的依赖，那么怎么做呢？好，证实一下这么做并不难（尤其是在我们限制只支持 IE8 及以上版本的情况下）。最终，我们必须使用一般的 javascript 实现一个定制的 PubSub 并且保留了 DOM 事件: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function DataBinder(object_id) &#123; // Create a simple PubSub object var pubSub = &#123; callbacks: &#123;&#125;, on: function(msg, callback) &#123; this.callbacks[msg] = this.callbacks[msg] || []; this.callbacks[msg].push(callback); &#125;, publish: function(msg) &#123; this.callbacks[msg] = this.callbacks[msg] || [] for (var i = 0, len = this.callbacks[msg].length; i &lt; len; i++) &#123; this.callbacks[msg][i].apply(this, arguments); &#125; &#125; &#125;, data_attr = \"data-bind-\" + object_id, message = object_id + \":change\", changeHandler = function(evt) &#123; var target = evt.target || evt.srcElement, // IE8 compatibility prop_name = target.getAttribute(data_attr); if (prop_name &amp;&amp; prop_name !== \"\") &#123; pubSub.publish(message, prop_name, target.value); &#125; &#125;; // Listen to change events and proxy to PubSub if (document.addEventListener) &#123; document.addEventListener(\"change\", changeHandler, false); &#125; else &#123; // IE8 uses attachEvent instead of addEventListener document.attachEvent(\"onchange\", changeHandler); &#125; // PubSub propagates changes to all bound elements pubSub.on(message, function(evt, prop_name, new_val) &#123; var elements = document.querySelectorAll(\"[\" + data_attr + \"=\" + prop_name + \"]\"), tag_name; for (var i = 0, len = elements.length; i &lt; len; i++) &#123; tag_name = elements[i].tagName.toLowerCase(); if (tag_name === \"input\" || tag_name === \"textarea\" || tag_name === \"select\") &#123; elements[i].value = new_val; &#125; else &#123; elements[i].innerHTML = new_val; &#125; &#125; &#125;); return pubSub;&#125; 除了设置器里调用 jQuery 的 trigger 方法外，模型可以保持一样。调用 trigger 方法将替代为调用我们定制的具有不同特征的 PubSub 的 publish 方法： 1234567891011121314// In the model's setter:function User(uid) &#123; // ... user = &#123; // ... set: function(attr_name, val) &#123; this.attributes[attr_name] = val; // Use the `publish` method binder.publish(uid + \":change\", attr_name, val, this); &#125; &#125; // ...&#125; 再次说明一下，我们用一般的纯 javascript 的少于 100 行的维护代码获得了同样的结果。 英文原文：Easy Two-Way Data Binding in JavaScript本文转载自：http://www.oschina.net/translate/easy-two-way-data-binding-in-javascript","tags":[{"name":"angular","slug":"angular","permalink":"http://zqianduan.com/tags/angular/"},{"name":"jquery","slug":"jquery","permalink":"http://zqianduan.com/tags/jquery/"}]},{"title":"(翻译)使用200行代码创建属于你自己的精简版angular","date":"2016-03-02T06:15:19.000Z","path":"2016/03/02/use-200-line-code-to-implementation-a-simple-angular/","text":"第一次翻译外文，就拿这篇作为第一次练习。加上一些自己的理解并且做了些删减。 正文开始： 我的实践经验证明有两种好方法来学习一项新技术 自己重新实现这个项目 分析那些你所知道的技术概念是如何运用在这个项目里的 在一些情况下第一种方式很难做到。比如，如果你为了理解 kernel（linux内核）的工作原理而去重新实现一次它会很困难很慢。往往更有效的是你去实现一个轻量的版本，去除掉那些你没兴趣的技术细节，只关注核心功能。 第二种方法一般是很有效的，特别是当你具有一些相似的技术经验的时候。最好的证明就是我写的 angularjs-in-patterns，对于有经验的工程师来说这是个对 angular 框架非常好的介绍。 不管怎么说，从头开始实现一些东西并且去理解代码使用的技术细节是非常好的学习方式。整个 angularjs 框架大概有 20k 行代码，其中有很多特别难懂的地方。这是很多聪明的程序员夜以继日的工作做出来的伟大的壮举。然而为了理解这个框架还有它主要的设计原则，我们可以仅仅简单的实现一个“模型”。 我们可以通过下面这些步骤来实现这个模型： 简化 api 去除掉对于理解核心功能无关的组件代码 这就是我在 Lightweight AngularJS 里面做的事情。 在开始阅读下面的内容之前，建议先了解下angularjs的基本用法，可以看这篇文章 下面是一些 demo 例子还有代码片段： Lightweight AngularJS source code Very simple todo application built with Lightweight AngularJS 让我们开始我们的实现： 主要的组件：我们不完全实现 angularjs 的那套技术，我们就仅仅定义一部分的组件并且实现大部分的 angularjs 里面的时尚特性。可能会接口变得简单点，或者减少些功能特性。 我们会实现的 angular 的组件包括： Controllers Directives Services 为了达到这些功能我们需要实现 $compile service(我们称之为 DOMCompiler)，还有 $provider 跟 $injector(在我们的实现里统称为 Provider)。为了实现双向绑定我们还要实现 scope。 下面是 Provider, Scope 跟 DOMCompiler 的依赖关系： Provider就像上面提到的，我们的 Provider 会包括原生 angular 里面的两个组件的内容： $provide $injector 他是一个具有如下功能特性的单例： 注册组件（directives, services 和 controllers） 解决各个组件之间的依赖关系 初始化所有组件 DOMCompilerDOMCompiler 也是一个单例，他会遍历 dom 树去查找对应的 directives 节点。我们这里仅仅支持那种用在 dom 元素属性上的 directive。当 DOMCompiler 发现 directive 的时候会给他提供 scope 的功能特性（因为对应的 directive 可能需要一个新的 scope）并且调用关联在它上面对应的逻辑代码（也就是 link 函数里面的逻辑）。所以这个组件的主要职责就是： 编译 dom： 遍历dom树的所有节点 找到注册的属性类型的 directives 指令 调用对应的 directive 对应的 link 逻辑 管理 scope Scope我们的轻量级 angular 的最后一个主要的组件就是 scope。为了实现双向绑定的功能，我们需要有一个 $scope 对象来挂载属性。我们可以把这些属性组合成表达式并且监控它们。当我们发现监控的某个表达式的值改变了，我们就调用对应的回调函数。 scope 的职责： 监控表达式 在每次 $digest 循环的时候执行所有的表达式，直到稳定（译者注：稳定就是说，表达式的值不再改变的时候） 在表达式的值发生改变时，调用对应的所有的回调函数 下面本来还有些图论的讲解，但是认为意义不大，这边就略去了。 开始实现让我们开始实现我们的轻量版 angular Provider正如我们上面说的，Provide 会： 注册组件（directives, services 和 controllers） 解决各个组件之间的依赖关系 初始化所有组件 所以它具有下面这些接口： get(name, locals) - 通过名称 还有本地依赖 返回对应的 service invoke(fn, locals) - 通过 service 对应的工厂函数还有本地依赖初始化 service directive(name, fn) - 通过名称还有工厂函数注册一个 directive controller(name, fn) - 通过名称还有工厂函数注册一个 controller。注意 angularjs 的代码里并没有 controllers 对应的代码，他们是通过 $controller 来实现的 service(name, fn) - 通过名称还有工厂函数注册一个 service annotate(fn) - 返回一个数组，数组里是当前 service 依赖的模块的名称 组件的注册： 12345678910111213141516171819202122var Provider = &#123; _providers: &#123;&#125;, directive: function(name, fn) &#123; this._register(name + Provider.DIRECTIVES_SUFFIX, fn); &#125;, controller: function(name, fn) &#123; this._register(name + Provider.CONTROLLERS_SUFFIX, function() &#123; return fn; &#125;); &#125;, service: function(name, fn) &#123; this._register(name, fn); &#125;, _register: function(name, factory) &#123; this._providers[name] = factory; &#125; //...&#125;;Provider.DIRECTIVES_SUFFIX = 'Directive';Provider.CONTROLLERS_SUFFIX = 'Controller'; 译者注：看到这里容易对 controller 的包装一层有疑问，先忽略，看完 invoke 的实现后，下面我再给出解释。 上面的代码提供了一个针对注册组件的简单的实现。我们定义了一个私有属性 _provides 用来存储所有的组件的工厂函数。我们还定义了 directive, service 和 controller 这些方法。这些方法本质上内部会调用 _register 来实现。在 controller 方法里面我们简单的在给的工厂函数外面包装了一层函数，因为我们希望可以多次实例化同一个 controller 而不去缓存返回的值。在我们看了下面的 get 和 ngl-controller 方法实现后会对 controller 方法有更加清晰的认识。下面还剩下的方法就是： invoke get annotate 123456789101112131415161718192021222324252627282930313233var Provider = &#123; // ... get: function(name, locals) &#123; if (this._cache[name]) &#123; return this._cache[name]; &#125; var provider = this._providers[name]; if (!provider || typeof provider !== 'function') &#123; return null; &#125; return (this._cache[name] = this.invoke(provider, locals)); &#125;, annotate: function(fn) &#123; var res = fn.toString().replace(/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg, '').match(/\\((.*?)\\)/); if (res &amp;&amp; res[1]) &#123; return res[1].split(',').map(function(d) &#123; return d.trim(); &#125;); &#125; return []; &#125;, invoke: function(fn, locals) &#123; locals = locals || &#123;&#125;; var deps = this.annotate(fn).map(function(s) &#123; return locals[s] || this.get(s, locals); &#125;, this); return fn.apply(null, deps); &#125;, _cache: &#123; $rootScope: new Scope() &#125;&#125;; 我们写了更多的逻辑，下面我们看看 get 的实现。在 get 方法中我们先检测下一个组件是不是已经缓存在了私有属性 _cache 里面： 如果缓存了就直接返回（译者注：这边其实就是个单例模式，只会调用注册的工厂函数一次，以后直接调用缓存的生成好的对象）。$rootScope 默认就会被缓存，因为我们需要一个单独的全局的并且唯一的超级 scope。一旦整个应用启动了，他就会被实例化 如果不在缓存里，就从私有属性 _providers 里面拿到它的工厂函数，并且调用 invoke 去执行工厂函数实例化它 在 invoke 函数里，我们做的第一件事就是判断如果没有 locals 对象就赋值一个空的值，这些 locals 对象 叫做局部依赖，什么是局部依赖呢？ 在 angularjs 里面我们可以想到两种依赖： 局部依赖 全局依赖 全局依赖是我们使用 factory, service, filter 等等注册的组件。他们可以被所有应用里的其他组件依赖使用。但是 $scope 呢？对于每一个 controller（具有相同执行函数的 controller）我们希望拥有不同的 scope，$scope 对象不像 $http, $resource，它不是全局的依赖对象，而是跟 $delegate 对象一样是局部依赖，针对当前的组件。 让我们呢回到 invoke 的实现上。通过合理的规避 null, undefined 这些值，我们可以获取到当前组件的依赖项的名字。注意我们的实现仅仅支持解析那种作为参数属性的依赖写法： 1234function Controller($scope, $http) &#123; // ...&#125;angular.controller('Controller', Controller); 一旦把 controller 的定义转换成字符串，我们就可以很简单的通过 annotate 里面的正则匹配出它的依赖项。但是万一 controller 的定义里面有注释呢？ 1234function Controller($scope /* only local scope, for the component */, $http) &#123; // ...&#125;angular.controller('Controller', Controller); 这边简单的正则就不起作用了，因为执行 Controller.toString() 也会返回注释，所以这就是我们为什么最开始要使用下面的正则先去掉注释： 1.replace(/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg, ''). 当我们拿到依赖项的名称后，我们需要去实例化他们。所以我们使用 map 来循环遍历，挨个的调用 get 来获取实例。你注意到这边的问题了吗？ 如果我们有个组件 A，A 依赖 B 和 C。并且假设 C 依赖 A？在这种情况下我们就会发生无止境的循环，也就是循环依赖。在这个实现里面我们不会处理这种问题，但是你应该小心点，尽量避免。 所以上面就是我们的 provider 的实现，现在我们可以这样注册组件： 1234567891011Provider.service('RESTfulService', function() &#123; return function(url) &#123; // make restful call &amp; return promise &#125;;&#125;);Provider.controller('MainCtrl', function(RESTfulService) &#123; RESTfulService(url).then(function(data) &#123; alert(data); &#125;);&#125;); 然后我们可以这样执行 MainCtrl： 12var ctrl = Provider.get('MainCtrl' + Provider.CONTROLLERS_SUFFIX);Provider.invoke(ctrl); 译者注： 这边可以开始解释下上面的 Provider 里面 controller 方法里为啥要包装一层了。 首先我们注意到 controller 的调用方式是特殊的，Provider.get 内部已经调用了一次 invoke，但是我们还要再调用一次 invoke 才能执行 MainCtrl 的真正执行函数。这是因为我们包装了一层，导致 _cache 里面单例存储的是 MainCtrl 的执行函数。而不是执行函数的结果。 想想这才是合理的，因为 MainCtrl 可能会有多个调用，这些调用只有执行函数是一致的，但是执行函数的执行结果根据不同的 scope 环境是不一样的。换句话说对于 controller 来说 执行函数才是单列的，执行结果是差异的。如果我们不包装一层，就会导致第一次的执行结果会直接缓存，这样下次再使用 MainCtrl 的时候得到的值就是上一次的。 当然带来的问题就是我们需要 get 到执行函数后，再次调用 invoke 来获取结果。 这边的 controller 初始化，需要看下面的 ngl-controller 的实现，可以到时再回过头来看这边会理解的更清楚。 DOMCompilerDOMCompiler的主要职责是： 编译dom 遍历 dom 树的所有节点 找到注册的属性类型的 directives 指令 调用对应的 directive 对应的 link 逻辑 管理 scope 下面的这些接口就够了： bootstrap() - 启动整个项目（类似 angularjs 里面的 angular.bootstrap，不过一直使用 html 根节点作为启动的节点） compile(el, scope) - 执行所有依附在当前 html 节点上的 directives 的代码，并且递归执行子元素的组件逻辑。我们需要一个 scope 对象关联当前的 html 节点，这样才能实现双向绑定。因为每个 directive 可能都会生成一个不同的 scope，所以我们需要在递归调用的时候传入当前的 scope 对象 下面是对应的实现： 1234567891011121314151617181920212223242526var DOMCompiler = &#123; bootstrap: function() &#123; this.compile(document.children[0], Provider.get('$rootScope')); &#125;, compile: function(el, scope) &#123; // 获取某个元素上的所有指令 var dirs = this._getElDirectives(el); var dir; var scopeCreated; dirs.forEach(function(d) &#123; dir = Provider.get(d.name + Provider.DIRECTIVES_SUFFIX); // dir.scope代表当前 directive是否需要生成新的scope // 这边的情况是只要有一个指令需要单独的scope，其他的directive也会变成具有新的scope对象，这边是不是不太好 if (dir.scope &amp;&amp; !scopeCreated) &#123; scope = scope.$new(); scopeCreated = true; &#125; dir.link(el, scope, d.value); &#125;); Array.prototype.slice.call(el.children).forEach(function(c) &#123; this.compile(c, scope); &#125;, this); &#125;, // ...&#125;; bootstrap 的实现很简单，就是调用了一下 compile，传递的是 html 的根节点，以及全局的 $rootScope。 在 compile 里面的代码就很有趣了，最开始我们使用了一个辅助方法来获取某个节点上面的所有指令，我们后面再来看这个 _getElDirectives 的实现。 当我们获取到当前节点的所有指令后，我们循环遍历下并且使用 Provider.get 获取到对应的 directive 的工厂函数的执行返回对象。然后我们检查当前的 directive 是否需要一个新的 scope，如果需要并且我们还没有为当前的节点初始化过新的 scope 对象，我们就执行 scope.$new() 来生成一个新的 scope 对象，这个对象会原型继承当前的 scope 对象。然后我们执行当前 directive 的 link 方法。最后我们递归执行子节点，因为 el.children 是一个 nodelist 对象，所以我们使用 Array.prototype.slice.call 将它转换成数组，之后对它递归调用 compile。 再让我们看看 _getElDirectives： 123456789101112131415// ..._getElDirectives: function(el) &#123; var attrs = el.attributes; var result = []; for (var i = 0; i &lt; attrs.length; i += 1) &#123; if (Provider.get(attrs[i].name + Provider.DIRECTIVES_SUFFIX)) &#123; result.push(&#123; name: attrs[i].name, value: attrs[i].value &#125;); &#125; &#125; return result;&#125;// ... 主要就是遍历当前节点 el 的所有属性，发现一个注册过的指令就把它的名字和值加入到返回的数组里。 好了，到这里我们的 DOMCompiler 就完成了，下面我们看看最后一个重要的组件： Scope为了实现脏检测的功能，于是 scope 可能是整个实现里面最复杂的部分了，在 angularjs 里面我们称为 $digest 循环。 笼统的讲双向绑定的最主要原理，就是在 $digest 循环里面执行监控表达式。一旦这个循环开始调用，就会执行所有监控的表达式并且检测最后的执行结果是不是跟当前的执行结果不同，如果 angularjs 发现他们不同，它就会执行这个表达式对应的回调函数。 一个监控者就是一个对象，像这样 { expr, fn, last }，expr 是对应的监控表达试，fn 是对应的回调函数会在值变化后执行，last 是上一次的表达式的执行结果。 scope 对象有下面这些方法： $watch(expr, fn) - 监控表达式 expr。一旦发现 expr 的值有变化就只行回调函数fn，并且传入新的值 $destroy() - 销毁当前的 scope 对象 $eval(expr) - 根据上下文执行当前的表达式 $new() - 原型继承当前的 scope 对象，生成一个新的 scope 对象 $digest() - 运行脏检测 让我们来深入的看看 scope 的实现： 1234567function Scope(parent, id) &#123; this.$$watchers = []; this.$$children = []; this.$parent = parent; this.$id = id || 0;&#125;Scope.counter = 0; 我们大幅度的简化了 angularjs 的 scope，我们仅仅有一个监控者的列表，一个子 scope 对象的列表，一个父 scope 对象，还有个当前 scope 的 id。我们添加了一个静态属性 counter 用来跟踪最后一个 scope，并且为下一个 scope 对象提供一个唯一的标识。 我们来实现 $watch 方法： 1234567Scope.prototype.$watch = function(exp, fn) &#123; this.$$watchers.push(&#123; exp: exp, fn: fn, last: Utils.clone(this.$eval(exp)) &#125;);&#125;; 在 $watch 方法中，我们添加了一个新对象到 this.$$watchers 监控者列表里。这个对象包括一个表达式，一个执行的回调还有最后一次表达式执行的结果 last。因为我们使用 this.$eval 执行表达式得到的结果有可能是个引用，所以我们需要克隆一份新的。 下面我们看看如何新建 scope，和销毁 scope： 12345678910111213Scope.prototype.$new = function() &#123; Scope.counter += 1; var obj = new Scope(this, Scope.counter); // 设置原型链，把当前的scope对象作为新scope的原型，这样新的scope对象可以访问到父scope的属性方法 Object.setPrototypeOf(obj, this); this.$$children.push(obj); return obj;&#125;;Scope.prototype.$destroy = function() &#123; var pc = this.$parent.$$children; pc.splice(pc.indexOf(this), 1);&#125;; \\$new 用来创建一个新的 scope 对象，并且具有独一无二的标识，原型被设置为当前 scope 对象。然后我们把新生成的 scope 对象放到子 scope 对象列表（this.$$children）里。 在 destroy 方法里，我们把当前 scope 对象从父级 scope 对象里的子 scope 对象列表（this.$$children）移除掉。 下面我们看看传说中的脏检测 $digest 的实现： 123456789101112131415161718Scope.prototype.$digest = function() &#123; var dirty, watcher, current, i; do &#123; dirty = false; for (i = 0; i &lt; this.$$watchers.length; i += 1) &#123; watcher = this.$$watchers[i]; current = this.$eval(watcher.exp); if (!Utils.equals(watcher.last, current)) &#123; watcher.last = Utils.clone(current); dirty = true; watcher.fn(current); &#125; &#125; &#125; while ( dirty ); for (i = 0; i &lt; this.$$children.length; i += 1) &#123; this.$$children[i].$digest(); &#125;&#125;; 基本上我们一直循环运行检测一直到没有脏数据，默认情况下就是没有脏数据的。一旦我们发现当前表达式的执行结果跟上一次的结果不一样我们就任务有了脏数据，一旦我们发现一个脏数据我们就要重新执行一次所有的监控表达式。为什么呢？因为我们可能会有一些内部表达式依赖，所以一个表达式的结果可能会影响到另外一个的结果。这就是为什么我们需要一遍一遍的运行脏检测一直到所有的表达式都没有变化也就是稳定了。一旦我们发现数据改变了，我们就立即执行对应的回调并且更新对应的 last 值，并且标识当前有脏数据，这样就会再次调用脏检测。 然后我们会继续递归调用子 scope 对象的脏数据检测，一个需要注意的情况就是这边也会发生循环依赖： 12345678910111213function Controller($scope) &#123; $scope.i = $scope.j = 0; $scope.$watch('i', function(val) &#123; $scope.j += 1; &#125;); $scope.$watch('j', function(val) &#123; $scope.i += 1; &#125;); $scope.i += 1; $scope.$digest();&#125; 这种情况下我们就会看到： 最后一个方法是 $eval. 最好不要在生产环境里使用这个，这个是一个 hack 手段用来避免我们还需要自己做个表达式解析引擎。 1234567891011121314151617181920212223// In the complete implementation there're// lexer, parser and interpreter.// Note that this implementation is pretty evil!// It uses two dangerouse features:// - eval// - with// The reason the 'use strict' statement is// omitted is because of `with`Scope.prototype.$eval = function(exp) &#123; var val; if (typeof exp === 'function') &#123; val = exp.call(this); &#125; else &#123; try &#123; with(this) &#123; val = eval(exp); &#125; &#125; catch(e) &#123; val = undefined; &#125; &#125; return val;&#125;; 我们检测监控的表达式是不是一个函数，如果是的话我们就使用当前的上下文执行它。否则我们就通过 with 把当前的执行环境改成当前 scope 的上下文并且使用 eval 来得到结果。这个可以允许我们执行类似 foo + bar * baz() 的表达式，甚至是更复杂的。当然我们不会支持 filters，因为他们是 angularjs 扩展的功能。 Directive到目前为止使用已有的元素我们做不了什么。为了让它跑起来我们需要添加一些指令（directive）还有服务（service）。让我们来实现 ngl-bind (ng-bind ), ngl-model (ng-model), ngl-controller (ng-controller) and ngl-click (ng-click)。括号里代表在 angularjs 里面的对应 directive ng-bind 123456789101112Provider.directive('ngl-bind', function() &#123; return &#123; scope: false, link: function(el, scope, exp) &#123; el.innerHTML = scope.$eval(exp); scope.$watch(exp, function(val) &#123; el.innerHTML = val; &#125;); &#125; &#125;;&#125;); ngl-bind 并不需要一个新的 scope，它仅仅对当前节点添加了一个监控。当脏检测发现有了改变，回调函数就会把新的值赋值到 innerHTML 更新 dom ngl-model 我们的 ng-model 只会支持 input 框的改变检测，所以它的实现是这样： 1234567891011121314Provider.directive('ngl-model', function() &#123; return &#123; link: function(el, scope, exp) &#123; el.onkeyup = function() &#123; scope[exp] = el.value; scope.$digest(); &#125;; scope.$watch(exp, function(val) &#123; el.value = val; &#125;); &#125; &#125;;&#125;); 我们对当前的 input 框添加了一个 onkeyup 的监听，一旦当前 input 的值变化了，我们就调用当前 scope 对象的 $digest 脏检测循环，这样就可以保证这个改变会应用到所有 scope 的监控表达式，当值改变了我们就改变对应的节点的值。 ngl-controller 1234567891011Provider.directive('ngl-controller', function() &#123; return &#123; scope: true, link: function(el, scope, exp) &#123; var ctrl = Provider.get(exp + Provider.CONTROLLERS_SUFFIX); Provider.invoke(ctrl, &#123; $scope: scope &#125;); &#125; &#125;;&#125;); 我们需要针对每个 controller 生成一个新的 scope 对象，所以它的 scope 的值是 true。我们使用 Provide.get 来获取到需要的 controller 执行函数，然后使用当前的 scope 来执行它。在 controller 里面我们可以给 scope 对象添加属性，我们可以使用 ngl-bind/ngl-model 绑定这些属性。一旦我们改变了属性值我们需要确保我们执行 $digest 脏检测来保证监控这些属性的表达式会执行。 ngl-click 在我们可以做一个有用的 todo 应用之前，这是我们最后要看的指令 1234567891011Provider.directive('ngl-click', function() &#123; return &#123; scope: false, link: function(el, scope, exp) &#123; el.onclick = function() &#123; scope.$eval(exp); scope.$digest(); &#125;; &#125; &#125;;&#125;); 这里我们不需要新建个 scope 对象，我们需要的就是当用户点击按钮时执行当前 ngl-click 后面跟着的表达式并且调用脏检测。 一个完整的例子为了保证我们可以理解双向绑定是怎么工作的，我们来看个下面的例子： 123456789&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;/head&gt;&lt;body ngl-controller=\"MainCtrl\"&gt; &lt;span ngl-bind=\"bar\"&gt;&lt;/span&gt; &lt;button ngl-click=\"foo()\"&gt;Increment&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 123456Provider.controller('MainCtrl', function ($scope) &#123; $scope.bar = 0; $scope.foo = function () &#123; $scope.bar += 1; &#125;;&#125;); 让我们看看使用这些会发生什么： 首先 DOMCompiler 会先发现我们的 ngl-controller 指令，然后会调用这个指令的 link 函数生成一个新的 scope 对象传递给 controller 的执行函数。我们增加了一个值为 0 的 bar 属性，还有一个叫做 foo 的方法，foo 方法会不断增加 bar。DOMCompiler 会发现 ngl-bind 然后为 bar 添加监控。并且还发现了 ngl-click 同时添加 click 事件到按钮上。 一旦用户点击了按钮，foo 函数就会通过 $scope.$eval 执行。使用的 scope 对象就是传递给 MainCtrl 的 scope 对象。这之后 ngl-click 会执行脏检测 $scope.$digest，脏检测循环会遍历所有的监控表达式，发现 bar 的值变化了，因为我们添加了对应的回调函数，所以就执行它更新 span 的内容。 结论这个框架离实际的生产环境应用还有很大差距，但是它还是实现了不少功能： 双向绑定 依赖注入 作用域分离 跟在 angular 里面的运行方式差不多，这些可以帮助我们更容易理解 angularjs。 但是你还是要记住的是不要把这些代码用在生产环境，最好还是直接使用 bower install angular 使用最新的 anguar。 本文转载自：http://purplebamboo.github.io/2015/05/27/use-200-line-code-to-implementation-a-simple-angular/","tags":[{"name":"angular","slug":"angular","permalink":"http://zqianduan.com/tags/angular/"},{"name":"mvvm","slug":"mvvm","permalink":"http://zqianduan.com/tags/mvvm/"}]},{"title":"javascript实现数据双向绑定的三种方式","date":"2016-03-02T04:52:29.000Z","path":"2016/03/02/js-data-two-way-binding/","text":"前端数据的双向绑定方法前端的视图层和数据层有时需要实现双向绑定(two-way-binding)，例如 mvvm 框架，数据驱动视图，视图状态机等，研究了几个目前主流的数据双向绑定框架，总结了下。目前实现数据双向绑定主要有以下三种。 1、手动绑定比较老的实现方式，有点像观察者编程模式，主要思路是通过在数据对象上定义 get 和 set 方法(当然还有其它方法)，调用时手动调用 get 或 set 数据，改变数据后出发 UI 层的渲染操作；以视图驱动数据变化的场景主要应用于 input、select、textarea 等元素，当 UI 层变化时，通过监听 dom 的 change，keypress，keyup 等事件来出发事件改变数据层的数据。整个过程均通过函数调用完成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;data-binding-method-set&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input q-value=\"value\" type=\"text\" id=\"input\"&gt; &lt;div q-text=\"value\" id=\"el\"&gt;&lt;/div&gt; &lt;script&gt; var elems = [document.getElementById('el'), document.getElementById('input')]; var data = &#123; value: 'hello!' &#125;; var command = &#123; text: function(str)&#123; this.innerHTML = str; &#125;, value: function(str)&#123; this.setAttribute('value', str); &#125; &#125;; var scan = function()&#123; /** * 扫描带指令的节点属性 */ for(var i = 0, len = elems.length; i &lt; len; i++)&#123; var elem = elems[i]; elem.command = []; for(var j = 0, len1 = elem.attributes.length; j &lt; len1; j++)&#123; var attr = elem.attributes[j]; if(attr.nodeName.indexOf('q-') &gt;= 0)&#123; /** * 调用属性指令，这里可以使用数据改变检测 */ command[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]); elem.command.push(attr.nodeName.slice(2)); &#125; &#125; &#125; &#125; /** * 设置数据后扫描 */ function mvSet(key, value)&#123; data[key] = value; scan(); &#125; /** * 数据绑定监听 */ elems[1].addEventListener('keyup', function(e)&#123; mvSet('value', e.target.value); &#125;, false); scan(); /** * 改变数据更新视图 */ setTimeout(function()&#123; mvSet('value', 'fuck'); &#125;,1000) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、脏检查机制以典型的 mvvm 框架 angularjs 为代表，angular 通过检查脏数据来进行 UI 层的操作更新。关于 angular 的脏检测，有几点需要了解些： 脏检测机制并不是使用定时检测 脏检测的时机是在数据发生变化时进行 angular 对常用的 dom 事件，xhr 事件等做了封装， 在里面触发进入 angular 的 digest 流程 在 digest 流程里面， 会从 rootscope 开始遍历， 检查所有的 watcher 关于 angular 的具体设计可以看其他文档，这里只讨论数据绑定，那我们看下脏检测该如何去做：主要是通过设置的数据来寻找与该数据相关的所有元素，然后再比较数据变化，如果变化则进行指令操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;data-binding-drity-check&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input q-event=\"value\" ng-bind=\"value\" type=\"text\" id=\"input\"&gt; &lt;div q-event=\"text\" ng-bind=\"value\" id=\"el\"&gt;&lt;/div&gt; &lt;script&gt; var elems = [document.getElementById('el'), document.getElementById('input')]; var data = &#123; value: 'hello!' &#125;; var command = &#123; text: function(str) &#123; this.innerHTML = str; &#125;, value: function(str) &#123; this.setAttribute('value', str); &#125; &#125;; var scan = function(elems) &#123; /** * 扫描带指令的节点属性 */ for (var i = 0, len = elems.length; i &lt; len; i++) &#123; var elem = elems[i]; elem.command = &#123;&#125;; for (var j = 0, len1 = elem.attributes.length; j &lt; len1; j++) &#123; var attr = elem.attributes[j]; if (attr.nodeName.indexOf('q-event') &gt;= 0) &#123; /** * 调用属性指令 */ var dataKey = elem.getAttribute('ng-bind') || undefined; /** * 进行数据初始化 */ command[attr.nodeValue].call(elem, data[dataKey]); elem.command[attr.nodeValue] = data[dataKey]; &#125; &#125; &#125; &#125; /** * 脏循环检测 * @param &#123;[type]&#125; elems [description] * @return &#123;[type]&#125; [description] */ var digest = function(elems) &#123; /** * 扫描带指令的节点属性 */ for (var i = 0, len = elems.length; i &lt; len; i++) &#123; var elem = elems[i]; for (var j = 0, len1 = elem.attributes.length; j &lt; len1; j++) &#123; var attr = elem.attributes[j]; if (attr.nodeName.indexOf('q-event') &gt;= 0) &#123; /** * 调用属性指令 */ var dataKey = elem.getAttribute('ng-bind') || undefined; /** * 进行脏数据检测，如果数据改变，则重新执行指令，否则跳过 */ if(elem.command[attr.nodeValue] !== data[dataKey])&#123; command[attr.nodeValue].call(elem, data[dataKey]); elem.command[attr.nodeValue] = data[dataKey]; &#125; &#125; &#125; &#125; &#125; /** * 初始化数据 */ scan(elems); /** * 可以理解为做数据劫持监听 */ function $digest(value)&#123; var list = document.querySelectorAll('[ng-bind='+ value + ']'); digest(list); &#125; /** * 输入框数据绑定监听 */ if(document.addEventListener)&#123; elems[1].addEventListener('keyup', function(e) &#123; data.value = e.target.value; $digest(e.target.getAttribute('ng-bind')); &#125;, false); &#125;else&#123; elems[1].attachEvent('onkeyup', function(e) &#123; data.value = e.target.value; $digest(e.target.getAttribute('ng-bind')); &#125;, false); &#125; setTimeout(function() &#123; data.value = 'fuck'; /** * 这里问啥还要执行$digest这里关键的是需要手动调用$digest方法来启动脏检测 */ $digest('value'); &#125;, 2000) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、前端数据劫持(Hijacking)第三种方法则是 avalon 等框架使用的数据劫持方式。基本思路是使用 Object.defineProperty 对数据对象做属性 get 和 set 的监听，当有数据读取和赋值操作时则调用节点的指令，这样使用最通用的=等号赋值就可以了。具体实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;data-binding-hijacking&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input q-value=\"value\" type=\"text\" id=\"input\"&gt; &lt;div q-text=\"value\" id=\"el\"&gt;&lt;/div&gt; &lt;script&gt; var elems = [document.getElementById('el'), document.getElementById('input')]; var data = &#123; value: 'hello!' &#125;; var command = &#123; text: function(str) &#123; this.innerHTML = str; &#125;, value: function(str) &#123; this.setAttribute('value', str); &#125; &#125;; var scan = function() &#123; /** * 扫描带指令的节点属性 */ for (var i = 0, len = elems.length; i &lt; len; i++) &#123; var elem = elems[i]; elem.command = []; for (var j = 0, len1 = elem.attributes.length; j &lt; len1; j++) &#123; var attr = elem.attributes[j]; if (attr.nodeName.indexOf('q-') &gt;= 0) &#123; /** * 调用属性指令 */ command[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]); elem.command.push(attr.nodeName.slice(2)); &#125; &#125; &#125; &#125; var bValue; /** * 定义属性设置劫持 */ var defineGetAndSet = function(obj, propName) &#123; try &#123; Object.defineProperty(obj, propName, &#123; get: function() &#123; return bValue; &#125;, set: function(newValue) &#123; bValue = newValue; scan(); &#125;, enumerable: true, configurable: true &#125;); &#125; catch (error) &#123; console.log(\"browser not supported.\"); &#125; &#125; /** * 初始化数据 */ scan(); /** * 可以理解为做数据劫持监听 */ defineGetAndSet(data, 'value'); /** * 数据绑定监听 */ if(document.addEventListener)&#123; elems[1].addEventListener('keyup', function(e) &#123; data.value = e.target.value; &#125;, false); &#125;else&#123; elems[1].attachEvent('onkeyup', function(e) &#123; data.value = e.target.value; &#125;, false); &#125; setTimeout(function() &#123; data.value = 'fuck'; &#125;, 2000) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; defineProperty 支持 IE8 及以上的浏览器(MDN)，IE8 只支持 DOM 对象的 defineProperty，要兼容低版本浏览器，参考如下代码(来源)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* * Super amazing, cross browser property function, based on http://thewikies.com/ */function addProperty(obj, name, onGet, onSet) &#123; /** * wrapper functions */ var oldValue = obj[name], getFn = function () &#123; return onGet.apply(obj, [oldValue]); &#125;, setFn = function (newValue) &#123; return oldValue = onSet.apply(obj, [newValue]); &#125;; /* * Modern browsers, IE9+, and IE8 (must be a DOM object) */ if (Object.defineProperty) &#123; Object.defineProperty(obj, name, &#123; get: getFn, set: setFn &#125;); &#125; /** * Older Mozilla */ else if (obj.__defineGetter__) &#123; obj.__defineGetter__(name, getFn); obj.__defineSetter__(name, setFn); &#125; /** * IE6-7 * must be a real DOM object (to have attachEvent) * and must be attached to document (for onpropertychange to fire) */ else &#123; var onPropertyChange = function (e) &#123; if (event.propertyName == name) &#123; // temporarily remove the event so it doesn't fire again and create a loop obj.detachEvent(\"onpropertychange\", onPropertyChange); // get the changed value, run it through the set function var newValue = setFn(obj[name]); // restore the get function obj[name] = getFn; obj[name].toString = getFn; // restore the event obj.attachEvent(\"onpropertychange\", onPropertyChange); &#125; &#125;; obj[name] = getFn; obj[name].toString = getFn; obj.attachEvent(\"onpropertychange\", onPropertyChange); &#125;&#125; /** * must be a DOM object (even if it's not a real tag) attached to document */var myObject = document.createElement('fake');document.body.appendChild(myObject); // create propertymyObject.firstName = 'John';myObject.lastName = 'Dyer';addProperty(myObject, 'fullname', function() &#123; return this.firstName + ' ' + this.lastName; &#125;, function(value) &#123; var parts = value.split(' '); this.firstName = parts[0]; this.lastName = (parts.length &gt; 1) ? parts[1] : ''; &#125;); console.log(myObject.fullname); // returns 'John Dyer' 4、 小结首先这里的例子只是简单的实现，读者可以深入感受三种方式的异同点，复杂的框架也是通过这样的基本思路滚雪球滚大的。 参考资料 &amp;&amp; 相关资料： https://gist.github.com/brettz9/4093766#file_html5_dataset.js https://github.com/xufei/blog/issues/10 http://johndyer.name/native-browser-get-set-properties-in-javascript/ https://msdn.microsoft.com/zh-CN/library/dd229916(VS.85).aspx JS中的双向数据绑定及Object.defineProperty方法 Object.observe()带来的数据绑定变革 本文转载自：http://ouvens.github.io/frontend-javascript/2015/11/29/js-data-two-ways-binding.html","tags":[{"name":"angular","slug":"angular","permalink":"http://zqianduan.com/tags/angular/"},{"name":"mvvm","slug":"mvvm","permalink":"http://zqianduan.com/tags/mvvm/"}]},{"title":"2015～2016前端知识体系","date":"2016-03-01T09:09:29.000Z","path":"2016/03/01/front-end-knowledge-system/","text":"总结了下前端这两年的主流技术，大部分技术在我的博客里有较深入的研究学习，对应技术博客地址：http://ouvens.github.io ，博客持续更新中，欢迎大家关注~ 一、框架与组件bootstrap等UI框架设计与实现 伸缩布局：grid网格布局 基础UI样式：元素reset、按钮、图片、菜单、表单 组件UI样式：按钮组、字体图标、下拉菜单、输入框组、导航组、面包屑、分页、标签、轮播、弹出框、列表、多媒体、警告 响应式布局：布局、结构、样式、媒体、javascript响应式 第三方插件：插件管理 jQuery、zepto使用原理以及插件开发 支持amd、cmd、全局变量的模块化封装 $.fn.method = function(){} mvc/mvvm框架原理设计，vue/angular/avalon等 directive设计：html、text、class、html、attr、repeat、ref，可扩展 filter设计：bool、upperCase、lowerCase，可扩展 表达式设计：if-else等实现 viewmodel结构设计：例如数据，元素，方法的挂载与作用域 数据更变检测：函数触发，脏数据检测、对象hijacking polymer/angular2思想与设计思路 import技术 template和script引入方式 css样式命名空间隔离 简单复用第三方库 reactjs原理与使用 virtual dom单向数据绑定 js执行语法方式 UI由状态控制 commonJS/AMD/CMD 模块引入 模块定义 模块标识 UMD解决不同规范兼容性的问题，例如webpack封装 模块懒执行(CMD)与与预执行(AMD) loadJs模块化加载原理与实现 创建script标签，需要id映射到资源url onload加载模块队列判断 全部加载完成后触发 加载失败问题优化 requirejs、modjs、seajs polyfill、shim原理与实现 polyfill提供了开发者们希望浏览器原生提供支持的功能特性 shim将新的API引入到旧的环境中,且仅靠旧环境中已有的手段实现 virtual Dom、Incremental DOM 1.用js对象树表示dom树结构，根据该对象树构建dom树 2.状态改变时，重新构建对象，和旧的对象对比，记录两个对象树差异 3.将对象树差异应用到dom中 小结:js对象模拟dom(elem.js)，virtual dom diff算法(diff.js)、差异渲染dom(patch.js) incremental dom在状态改变时扫描旧对象树将差异直接应用到dom中 shadow dom 隔离外部环境用于封装组件：结构、样式、行为 实现形式：新标签、class类属性 + 构建编译 webwork与service Worker webwork与主线程机制，on/post serviceworker可作为浏览器请求代理 应用场景 ES6转ES5、Babel与ES6开发规范体系 ES6编码规范全 ES6在babel下兼容性 ES6在node下兼容性与性能 ES6新特性：看编码规范 aurelia ES6前端框架 Isomorphic JavaScript 同构原理 同构方案 Rendr nodejs: 服务器 hapi: 应用服务 backbone.js: 后台mvc requirejs: 模块加载 jquery: dom处理 reactjs同构:React + Flux + Koa 双向数据绑定 函数触发:vuejs 脏数据检测:angular 对象hijacking:avalon browserify运行原理 1.从入口模块开始分析require函数调用 2.根据依赖生成AST 3.根据AST找到每个模块的模块名 4.得到每个模块的依赖关系，生成一个依赖字典 5.包装每个模块（传入依赖字典以及export和require函数），生成执行的js performance timing performance timing api performance timing 过程 performance timing 性能计算 performanceTrace库 组件UI与js组件规范化 组件编码规范 组件目录规范：组件目录与公用目录 组件构建规范：构建环境支持 组件模块化管理：spm，bowserify 组件复用性管理 第三方组件接入成本 immutable JavaScriptgenerator与promise原理与使用二、构建生态grunt/gulp开发环境任务编写 文件处理插件：html、scss、js、image、font、其它 优化插件：雪碧图、图片压缩、iconfont构建 发布替换插件 打包、压缩包插件：组件自动分析 白名单配置 自定义插件编写 npm、jspm、bower包管理工具r.js、browserify、webpack、Rollup打包工具使用 原理：根据依赖配置文件对文件进行依赖打包 webpack支持更多的规范打包，AMD,Commonjs webpack+babel/reactjs+reflux fis3构建与插件开发、构建环境、fis3构建离线包web Component：rosetta-org、x-view、Q、riot、novabrunch构建工具三、开发技巧与调试fiddler加willow基础组合调试 常见配置与分析 结合浏览器调试 werien、vorlonjs远程调试，chrome inspectmockjs，F.M.S(Front Mock Server)模拟调试使用与cgi自动调试macha/phantomjs/casperjs/karma测试自动化任务使用自动化UI测试，海豚node-supervior、node-inspector、karma开发发布系统流程sublime高效插件 emmet工具使用、 sublimelinter、 babel snippets、 sublimeLint、 SassBeautify 、 emmet 快速编辑、 jsxlint、 SideBarEnhancements、 SnippetsMaker、 SublimeCodeIntel、 css snippets、 ColorPicker、 html/css/js Pretty、 SpinnetMacker、 DocBlockr、 MultiEditUtils、 javascript &amp; node spinnet、 JavaScript &amp; NodeJS Snippets、 jsLint、cssLint 代码自动化检查fecs四、html、css与重构jpeg、webp、apng、bpg图片 编码原理 特点与优劣势 适用场景 iconfont使用与实现原理 自动打包构建方法 iconfont兼容性写法 fonthello、fontawesome、icomoon.io、iconfont.cn线上工具 页面响应式设计 layout布局响应式 html结构响应式 css样式响应式 image媒体响应式 javascript响应式 media query与平台判断 css重置 reset nomalize neat sass/compass/less/postcss常用语法与使用 常用语法功能 组件化UI设计管理 构建工具实现方案 雪碧图自动合成 iconfont自动接入等等 media query与常见页面尺寸了解 媒体类型引入和媒体特性引入 device-width适应 retina屏幕适应 em,rem原理与实现 rem计算：width*retina/10，相当于屏幕宽度为10rem 字体在rem情况下仍然使用px code4ui、code4app、初页、maka等 前端dom操作即使刷新前端页面 根据dom操作生成组件config配置保存到db 根据config配置使用r.js或webpack打包 发布打包后输出文件 css3动画 transform animation transiction 3D加速与动画加速 动画库 缓动函数速查表： http://www.xuanfengge.com/easeing/easeing/ Ceaser： http://xuanfengge.com/easeing/ceaser/ cubic-bezier：http://cubic-bezier.com/ css网格布局 susy Responsive Grid System Fluid 960 Grid(adaptjs) Simple Grid 搜索引擎与前端SEO tdk优化 页面内容优化 唯一的H1标题 img设置alt属性 nofollow url优化 统一链接 301跳转 canonical robot优化 robots.txt meta robots sitemap SEO工具 各种站长工具等 浏览器缓存种类，resources,webSQL,indexDB, localstorage,cookie,app cache,cache storage store.js、cookie.js UI框架 bootstrap、jqwidgets、semantic ui、amaze ui 微信手Q ui: frozenui、weui、blend ui extjs、echart图表ui 五、native/hybrid/桌面开发ionic移动开发方案 运行架构 hybrid混合开发 cordova交互 离线包更新 性能瓶颈 nativescript移动开发方案react Native移动开发方案 运行架构：js引擎 性能缺陷与内存泄露 更新机制 使用场景 android/ios原生开发与框架 java oc、swift web与native交互 屏幕旋转 摇一摇 录像，拍照，选取本地图片 打电话，发短信 电池电量 地理位置 日期选择 开启硬件加速 桌面应用开发 nodewebkit atom-shell(后改名为electron) 网易Hex pomelo(游戏服务器框架) react desktop appjs:appjs.com 六、前端/H5优化(另一个图已给出)yslow、pagespeed移动web性能优化 手机浏览器”省流量”原理 增量更新原理及注意事项 本地存储的应用 加载优化 图片优化 单页面及路由实现 业内著名站点案例分析 七、全栈/全端开发express/node club + mongodb、thinkjs等框架node.js直出实时web开发，meteor/express.ioMEAN(mongodb/express/angular/nodejs)http与http2协议、bigpipe、pipeline离线缓存，cookie、localstorage、indexdbcdn与dns 动态域名加速 cdn原理与cdn combo 八、研究实验WebAssembly、webTRC、typescriptMaterial design规范的前端框架 交互动效库 AMP-HTML规范 使用受限HTML以及缓存技术来提高移动网络中静态内容的性能 添加自定义的元素代替禁用掉的元素：amp-audio, amp-img、amp-video等 九、数据分析与监控badjs数据上报 捕获错误两种方法：onerror、try-catch。抽样上报，先onerror统计语法错误，如果是script error，再使用tryjs。 后台统计方法、不同业务接入体系、抽样统计 onerror:可以捕捉语法错误和运行时错误；可以拿到出错的信息，堆栈，出错文件、行号、列号；当前页面执行的js脚本出错都会捕捉到；跨域的资源需要特殊头部支持。 try-catch:无法捕捉语法错误，只能捕捉运行时错误；可以拿到出错的信息，堆栈，出错文件、行号、列号；需要借助工具把function块以及文件块加入try,catch，可以在这个阶段打入更多的静态信息。 点击热力图clickHeat、heatMapjs加载失败优化方案 失败重发机制 加载源域名服务器文件 https反劫持 百度alog数据上报十、其它软技能 axure 原型图设计 xmind脑图管理 效率管理 can i use、github 知识管理/总结分享 产品思维与技能 十一、前端技术网站技术社区 w3c tech、w3c plus、w3 help div.io、nodeParty 稀土掘金、前端早读课 alloyteam、html5基地 W3 help 行业会议 segmentfault会议 深js、杭js GMIC(全球移动互联网大会) D2、webrebuild infoQ内容、Qcon、velocity 另外说明下，这里不仅仅是概念的罗列，过去也有些人有类似的总结，但是偏基础和概念罗列，没什么深度，这里有较多原理性的概述，博客有对应文章，较新热门的技术我的博客里也有很多，大家可以结合起来看，目前博客大概写了50%的总结文章。后面也会根据这个图去补齐我博客里的知识板块。 持续更新中，如果觉得不错，请点star支持下，甚至在您的团队里扩散下，谢谢~ 本文转载自：http://ouvens.github.io/frontend-resource/2016/01/26/front-end-learning-list.html","tags":[{"name":"css","slug":"css","permalink":"http://zqianduan.com/tags/css/"},{"name":"js","slug":"js","permalink":"http://zqianduan.com/tags/js/"},{"name":"frontend","slug":"frontend","permalink":"http://zqianduan.com/tags/frontend/"}]},{"title":"Nginx 开启 gzip 压缩","date":"2016-02-27T10:11:14.000Z","path":"2016/02/27/nginx-gzip/","text":"配置文件在 nginx 目录 nginx.conf gzip on; gzip_min_length 1k; gzip_buffers 4 16k; # gzip_http_version 1.0; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php; gzip_vary off; gzip_disable &quot;MSIE [1-6]\\.&quot;; gzip on 开启 Gzip gzip_min_length 当返回内容大于此值时才会使用 gzip 进行压缩，以 K 为单位，当值为 0 时，所有页面都进行压缩 gzip_buffers 设置 gzip 申请内存的大小，其作用是按块大小的倍数申请内存空间 gzip_http_version 用于识别 http 协议的版本，早期的浏览器不支持 gzip 压缩，用户会看到乱码，所以为了支持前期版本加了此选项，目前此项基本可以忽略 gzip_comp_level 设置 gzip 压缩等级，等级越底压缩速度越快文件压缩比越小，反之速度越慢文件压缩比越大 gzip_types 设置需要压缩的 MIME 类型，非设置值不进行压缩 注意：图片不要开启压缩，因为 jpg/gif/png 这些格式的图片本就是已压缩过的，再用 gzip 对他们进行压缩只是徒增服务器负担而已 gzip_vary 和 http 头有关系，加个 vary 头，给代理服务器用的，有的浏览器支持压缩，有的不支持，为避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩 gzip_disable 禁用 IE6 的 gzip 压缩（IE6 的某些版本对 gzip 的压缩支持很不好，会造成页面的假死）","tags":[{"name":"server","slug":"server","permalink":"http://zqianduan.com/tags/server/"},{"name":"gzip","slug":"gzip","permalink":"http://zqianduan.com/tags/gzip/"}]},{"title":"服务器301跳转","date":"2016-02-24T14:05:23.000Z","path":"2016/02/24/server-301-redirect/","text":"301重定向：页面永久性移走（301重定向）是一种非常重要的“自动转向”技术。网址重定向最为可行的一种办法。当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。 将 test.baidu.com 重定向到 baidu.com 上 Apache 123RewriteEngine onRewriteCond %&#123;HTTP_HOST&#125; test.baidu.com$ [NC]RewriteRule ^(.*)$ http://baidu.com/$1 [R=301,L] Nginx 123if ($host != &apos;test.baidu.com&apos; ) &#123; rewrite ^/(.*)$ http://baidu.com/$1 permanent; &#125;","tags":[{"name":"server","slug":"server","permalink":"http://zqianduan.com/tags/server/"},{"name":"301","slug":"301","permalink":"http://zqianduan.com/tags/301/"},{"name":"重定向","slug":"重定向","permalink":"http://zqianduan.com/tags/重定向/"}]},{"title":"CSS box/flex 区别","date":"2016-02-19T09:01:52.000Z","path":"2016/02/19/display-box-flex/","text":"display: box 是 CSS 2009 年的语法，已经过时，需加上对应前缀 display: flex 是 2012 年的语法，也将是以后标准的语法，大部分浏览器已经实现了无前缀版本 兼容性的代码，大致如下： 123456display: -webkit-box; /* Chrome 4+, Safari 3.1, iOS Safari 3.2+ */display: -moz-box; /* Firefox 17- */display: -webkit-flex; /* Chrome 21+, Safari 6.1+, iOS Safari 7+, Opera 15/16 */display: -moz-flex; /* Firefox 18+ */display: -ms-flexbox; /* IE 10 */display: flex; /* Chrome 29+, Firefox 22+, IE 11+, Opera 12.1/17/18, Android 4.4+ */","tags":[{"name":"css","slug":"css","permalink":"http://zqianduan.com/tags/css/"},{"name":"snippet","slug":"snippet","permalink":"http://zqianduan.com/tags/snippet/"}]},{"title":"聊聊浏览器的渲染机制","date":"2016-02-18T14:47:54.000Z","path":"2016/02/18/browser-render-mechanism/","text":"几个概念 DOM：Document Object Model，浏览器将 HTML 解析成树形的数据结构，简称 DOM。 CSSOM：CSS Object Model，浏览器将 CSS 代码解析成树形的数据结构。 DOM 和 CSSOM 都是以 Bytes → characters → tokens →nodes → object model.这样的方式生成最终的数据。如下图所示： DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 Render Tree：DOM 和 CSSOM 合并后生成 Render Tree，如下图： Render Tree 和 DOM 一样，以多叉树的形式保存了每个节点的 css 属性、节点本身属性、以及节点的孩子节点。 注意：display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。 浏览器的渲染过程 Create/Update DOM And request css/image/js：浏览器请求到HTML代码后，在生成 DOM 的最开始阶段(应该是 Bytes → characters 后)，并行发起css、图片、js的请求，无论他们是否在 HEAD 里。 注意：发起 js 文件的下载 request 并不需要 DOM 处理到那个 script 节点，比如：简单的正则匹配就能做到这一点，虽然实际上并不一定是通过正则。这是很多人在理解渲染机制的时候存在的误区 Create/Update Render CSSOM：CSS 文件下载完成，开始构建 CSSOM Create/Update Render Tree：所有 CSS 文件下载完成，CSSOM 构建结束后，和 DOM 一起生成 Render Tree。 Layout：有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系。下一步操作称之为 Layout，顾名思义就是计算出每个节点在屏幕中的位置。 Painting：Layout 后，浏览器已经知道了哪些节点要显示(whichnodes are visible)、每个节点的 CSS 属性是什么(their computedstyles)、每个节点在屏幕中的位置是哪里(geometry)。就进入了最后一步：Painting，按照算出来的规则，通过显卡，把内容画到屏幕上。 以上五个步骤前3个步骤之所有使用 “Create/Update” 是因为 DOM、CSSOM、Render Tree 都可能在第一次 Painting 后又被更新多次，比如 JS 修改了 DOM 或者 CSS 属性。 Layout 和 Painting 也会被重复执行，除了 DOM、CSSOM 更新的原因外，图片下载完成后也需要调用 Layout 和 Painting 来更新网页。 问题script 标签的位置会影响首屏时间么? 不影响(如果这里里的首屏指的是页面从白板变成网页画面——也就是第一次 Painting)，但有可能截断首屏的内容，使其只显示上面一部分。 为什么说是“有可能”呢?，如果该 js 下载地比 css 还快，或者 script 标签不在第一屏的 html 里，实际上是不影响的。明白这一影响边界非常重要，这样我们在考察页面性能瓶颈的时候就有的放矢了。举个例子：在网页的第二屏有一个通用模块，实际上我们是可以把它的 js 逻辑独立成一个文件，将模块的 html 和 js 标签放在一起做成独立的模板引进来的(如果它的 js 比较小或者说因为多了一个文件会多占用一个 TCP 连接和带宽)。 总结 如果script标签的位置不在首屏范围内，不影响首屏时间 所有的script标签应该放在body底部是很有道理的 但从性能最优的角度考虑，即使在 body 底部的 script 标签也会拖慢首屏出来的速度，因为浏览器在最一开始就会请求它对应的 js 文件，而这，占用了有限的 TCP 链接数、带宽甚至运行它所需要的 CPU。这也是为什么 script 标签会有 async 或 defer 属性的原因之一。 可是，在复杂的实际应用场景中，要贯彻这几条结论可能会遇到问题，比如： 你的页面是分模块来写的，每一个模块都有自己的 html、js 甚至 css，当把这些模块凑到一个页面中的时候就会出现 js 自然而然地出现在 HTML 中间部分。你很难把 script 标签都放到底部 即使你把 script 标签都放到底部，但 script 标签的存在终究是拖慢了首屏时间、DomContendLoad 和 loaded 的时间。如果只有一个 script 标签，我们可以加一个 async，但多个 async 的 script 标签的结果会是 js 文件被乱序执行的，这显然不是我们想要的。 参考资料 前端必读：浏览器内部工作原理 从输入 URL 到页面加载完成的过程中都发生了什么事情？ JS 一定要放在 Body 的最底部么？聊聊浏览器的渲染机制 浅析渲染引擎与前端优化","tags":[]},{"title":"前端兼容问题解析","date":"2016-02-18T10:15:04.000Z","path":"2016/02/18/compat/","text":"1. Android 4.x placeholder line-height 对齐问题input 中的 placeholder 在 iOS 等设置 line-height 等于 height 的值即可保证垂直居中，而在 Android 4.x 中则会偏上。 使用 ::-webkit-input-placeholder 只能更改颜色，并不能修改 line-height， 解决办法是讲 input 的 line-height 设置成 normal 即可垂直居中。 MDN: line-height -webkit-overflow-scrolling: touch; (ios5+);","tags":[{"name":"css","slug":"css","permalink":"http://zqianduan.com/tags/css/"},{"name":"javascript","slug":"javascript","permalink":"http://zqianduan.com/tags/javascript/"}]},{"title":"Hello World","date":"2016-02-18T05:10:25.000Z","path":"2016/02/18/hello-world/","text":"Welcome to Zqianduan.com !","tags":[]}]