<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Backbone 0.9.2 源码分析 | 最前端</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Backbone.js 为复杂 WEB 应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API；视图可以声明事件处理函数，并通过 RESRful JSON 接口连接到应用程序。">
<meta name="keywords" content="backbone">
<meta property="og:type" content="article">
<meta property="og:title" content="Backbone 0.9.2 源码分析">
<meta property="og:url" content="http://zqianduan.com/2016/03/03/backbone-source-analysis/index.html">
<meta property="og:site_name" content="最前端">
<meta property="og:description" content="Backbone.js 为复杂 WEB 应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API；视图可以声明事件处理函数，并通过 RESRful JSON 接口连接到应用程序。">
<meta property="og:updated_time" content="2017-04-27T07:01:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Backbone 0.9.2 源码分析">
<meta name="twitter:description" content="Backbone.js 为复杂 WEB 应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API；视图可以声明事件处理函数，并通过 RESRful JSON 接口连接到应用程序。">
  
    <link rel="alternative" href="/atom.xml" title="最前端" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay">
	<div class="st-so-wrap">
		<input type="text" id="local-search-input" class="st-default-search-input st-so" placeholder="回车搜索 直接有效">
	</div>
</div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Jimco</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/jimco" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/515789799" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/301/" style="font-size: 10px;">301</a> <a href="/tags/algorithm/" style="font-size: 11.67px;">algorithm</a> <a href="/tags/angular/" style="font-size: 15px;">angular</a> <a href="/tags/async/" style="font-size: 10px;">async</a> <a href="/tags/backbone/" style="font-size: 10px;">backbone</a> <a href="/tags/bfc/" style="font-size: 10px;">bfc</a> <a href="/tags/browser/" style="font-size: 10px;">browser</a> <a href="/tags/cache/" style="font-size: 10px;">cache</a> <a href="/tags/class/" style="font-size: 10px;">class</a> <a href="/tags/comet/" style="font-size: 10px;">comet</a> <a href="/tags/css/" style="font-size: 18.33px;">css</a> <a href="/tags/dom/" style="font-size: 10px;">dom</a> <a href="/tags/emlog/" style="font-size: 10px;">emlog</a> <a href="/tags/es6/" style="font-size: 10px;">es6</a> <a href="/tags/event/" style="font-size: 10px;">event</a> <a href="/tags/flex/" style="font-size: 10px;">flex</a> <a href="/tags/frontend/" style="font-size: 10px;">frontend</a> <a href="/tags/gzip/" style="font-size: 11.67px;">gzip</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/https/" style="font-size: 11.67px;">https</a> <a href="/tags/iframe/" style="font-size: 10px;">iframe</a> <a href="/tags/image/" style="font-size: 10px;">image</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/jsonp/" style="font-size: 10px;">jsonp</a> <a href="/tags/layout/" style="font-size: 13.33px;">layout</a> <a href="/tags/media/" style="font-size: 10px;">media</a> <a href="/tags/memory/" style="font-size: 10px;">memory</a> <a href="/tags/meta/" style="font-size: 10px;">meta</a> <a href="/tags/mvvm/" style="font-size: 13.33px;">mvvm</a> <a href="/tags/oo/" style="font-size: 10px;">oo</a> <a href="/tags/pattern/" style="font-size: 10px;">pattern</a> <a href="/tags/promise/" style="font-size: 13.33px;">promise</a> <a href="/tags/router/" style="font-size: 10px;">router</a> <a href="/tags/samba/" style="font-size: 10px;">samba</a> <a href="/tags/server/" style="font-size: 16.67px;">server</a> <a href="/tags/setInterval/" style="font-size: 10px;">setInterval</a> <a href="/tags/snippet/" style="font-size: 10px;">snippet</a> <a href="/tags/socket-io/" style="font-size: 10px;">socket.io</a> <a href="/tags/ssl/" style="font-size: 10px;">ssl</a> <a href="/tags/this/" style="font-size: 10px;">this</a> <a href="/tags/typecho/" style="font-size: 10px;">typecho</a> <a href="/tags/ubb/" style="font-size: 10px;">ubb</a> <a href="/tags/uglify/" style="font-size: 10px;">uglify</a> <a href="/tags/waterflow/" style="font-size: 10px;">waterflow</a> <a href="/tags/wordpress/" style="font-size: 10px;">wordpress</a> <a href="/tags/二进制/" style="font-size: 10px;">二进制</a> <a href="/tags/运算符/" style="font-size: 10px;">运算符</a> <a href="/tags/重定向/" style="font-size: 10px;">重定向</a>
					</div>
				</section>
				
				
				

				
					
						<section class="switch-part switch-part3">
					
					<div id="js-aboutme">狼厂攻城师，爱打羽毛球，欢迎骚扰！</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Jimco</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/avatar.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Jimco</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jimco" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/515789799" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-backbone-source-analysis" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/03/backbone-source-analysis/" class="article-date">
  	<time datetime="2016-03-03T07:16:34.000Z" itemprop="datePublished">2016-03-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Backbone 0.9.2 源码分析
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Javascript/">Javascript</a>
	</div>


        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/backbone/">backbone</a></li></ul>
	</div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Backbone.js 为复杂 WEB 应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API；视图可以声明事件处理函数，并通过 RESRful JSON 接口连接到应用程序。<br><a id="more"></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div><div class="line">755</div><div class="line">756</div><div class="line">757</div><div class="line">758</div><div class="line">759</div><div class="line">760</div><div class="line">761</div><div class="line">762</div><div class="line">763</div><div class="line">764</div><div class="line">765</div><div class="line">766</div><div class="line">767</div><div class="line">768</div><div class="line">769</div><div class="line">770</div><div class="line">771</div><div class="line">772</div><div class="line">773</div><div class="line">774</div><div class="line">775</div><div class="line">776</div><div class="line">777</div><div class="line">778</div><div class="line">779</div><div class="line">780</div><div class="line">781</div><div class="line">782</div><div class="line">783</div><div class="line">784</div><div class="line">785</div><div class="line">786</div><div class="line">787</div><div class="line">788</div><div class="line">789</div><div class="line">790</div><div class="line">791</div><div class="line">792</div><div class="line">793</div><div class="line">794</div><div class="line">795</div><div class="line">796</div><div class="line">797</div><div class="line">798</div><div class="line">799</div><div class="line">800</div><div class="line">801</div><div class="line">802</div><div class="line">803</div><div class="line">804</div><div class="line">805</div><div class="line">806</div><div class="line">807</div><div class="line">808</div><div class="line">809</div><div class="line">810</div><div class="line">811</div><div class="line">812</div><div class="line">813</div><div class="line">814</div><div class="line">815</div><div class="line">816</div><div class="line">817</div><div class="line">818</div><div class="line">819</div><div class="line">820</div><div class="line">821</div><div class="line">822</div><div class="line">823</div><div class="line">824</div><div class="line">825</div><div class="line">826</div><div class="line">827</div><div class="line">828</div><div class="line">829</div><div class="line">830</div><div class="line">831</div><div class="line">832</div><div class="line">833</div><div class="line">834</div><div class="line">835</div><div class="line">836</div><div class="line">837</div><div class="line">838</div><div class="line">839</div><div class="line">840</div><div class="line">841</div><div class="line">842</div><div class="line">843</div><div class="line">844</div><div class="line">845</div><div class="line">846</div><div class="line">847</div><div class="line">848</div><div class="line">849</div><div class="line">850</div><div class="line">851</div><div class="line">852</div><div class="line">853</div><div class="line">854</div><div class="line">855</div><div class="line">856</div><div class="line">857</div><div class="line">858</div><div class="line">859</div><div class="line">860</div><div class="line">861</div><div class="line">862</div><div class="line">863</div><div class="line">864</div><div class="line">865</div><div class="line">866</div><div class="line">867</div><div class="line">868</div><div class="line">869</div><div class="line">870</div><div class="line">871</div><div class="line">872</div><div class="line">873</div><div class="line">874</div><div class="line">875</div><div class="line">876</div><div class="line">877</div><div class="line">878</div><div class="line">879</div><div class="line">880</div><div class="line">881</div><div class="line">882</div><div class="line">883</div><div class="line">884</div><div class="line">885</div><div class="line">886</div><div class="line">887</div><div class="line">888</div><div class="line">889</div><div class="line">890</div><div class="line">891</div><div class="line">892</div><div class="line">893</div><div class="line">894</div><div class="line">895</div><div class="line">896</div><div class="line">897</div><div class="line">898</div><div class="line">899</div><div class="line">900</div><div class="line">901</div><div class="line">902</div><div class="line">903</div><div class="line">904</div><div class="line">905</div><div class="line">906</div><div class="line">907</div><div class="line">908</div><div class="line">909</div><div class="line">910</div><div class="line">911</div><div class="line">912</div><div class="line">913</div><div class="line">914</div><div class="line">915</div><div class="line">916</div><div class="line">917</div><div class="line">918</div><div class="line">919</div><div class="line">920</div><div class="line">921</div><div class="line">922</div><div class="line">923</div><div class="line">924</div><div class="line">925</div><div class="line">926</div><div class="line">927</div><div class="line">928</div><div class="line">929</div><div class="line">930</div><div class="line">931</div><div class="line">932</div><div class="line">933</div><div class="line">934</div><div class="line">935</div><div class="line">936</div><div class="line">937</div><div class="line">938</div><div class="line">939</div><div class="line">940</div><div class="line">941</div><div class="line">942</div><div class="line">943</div><div class="line">944</div><div class="line">945</div><div class="line">946</div><div class="line">947</div><div class="line">948</div><div class="line">949</div><div class="line">950</div><div class="line">951</div><div class="line">952</div><div class="line">953</div><div class="line">954</div><div class="line">955</div><div class="line">956</div><div class="line">957</div><div class="line">958</div><div class="line">959</div><div class="line">960</div><div class="line">961</div><div class="line">962</div><div class="line">963</div><div class="line">964</div><div class="line">965</div><div class="line">966</div><div class="line">967</div><div class="line">968</div><div class="line">969</div><div class="line">970</div><div class="line">971</div><div class="line">972</div><div class="line">973</div><div class="line">974</div><div class="line">975</div><div class="line">976</div><div class="line">977</div><div class="line">978</div><div class="line">979</div><div class="line">980</div><div class="line">981</div><div class="line">982</div><div class="line">983</div><div class="line">984</div><div class="line">985</div><div class="line">986</div><div class="line">987</div><div class="line">988</div><div class="line">989</div><div class="line">990</div><div class="line">991</div><div class="line">992</div><div class="line">993</div><div class="line">994</div><div class="line">995</div><div class="line">996</div><div class="line">997</div><div class="line">998</div><div class="line">999</div><div class="line">1000</div><div class="line">1001</div><div class="line">1002</div><div class="line">1003</div><div class="line">1004</div><div class="line">1005</div><div class="line">1006</div><div class="line">1007</div><div class="line">1008</div><div class="line">1009</div><div class="line">1010</div><div class="line">1011</div><div class="line">1012</div><div class="line">1013</div><div class="line">1014</div><div class="line">1015</div><div class="line">1016</div><div class="line">1017</div><div class="line">1018</div><div class="line">1019</div><div class="line">1020</div><div class="line">1021</div><div class="line">1022</div><div class="line">1023</div><div class="line">1024</div><div class="line">1025</div><div class="line">1026</div><div class="line">1027</div><div class="line">1028</div><div class="line">1029</div><div class="line">1030</div><div class="line">1031</div><div class="line">1032</div><div class="line">1033</div><div class="line">1034</div><div class="line">1035</div><div class="line">1036</div><div class="line">1037</div><div class="line">1038</div><div class="line">1039</div><div class="line">1040</div><div class="line">1041</div><div class="line">1042</div><div class="line">1043</div><div class="line">1044</div><div class="line">1045</div><div class="line">1046</div><div class="line">1047</div><div class="line">1048</div><div class="line">1049</div><div class="line">1050</div><div class="line">1051</div><div class="line">1052</div><div class="line">1053</div><div class="line">1054</div><div class="line">1055</div><div class="line">1056</div><div class="line">1057</div><div class="line">1058</div><div class="line">1059</div><div class="line">1060</div><div class="line">1061</div><div class="line">1062</div><div class="line">1063</div><div class="line">1064</div><div class="line">1065</div><div class="line">1066</div><div class="line">1067</div><div class="line">1068</div><div class="line">1069</div><div class="line">1070</div><div class="line">1071</div><div class="line">1072</div><div class="line">1073</div><div class="line">1074</div><div class="line">1075</div><div class="line">1076</div><div class="line">1077</div><div class="line">1078</div><div class="line">1079</div><div class="line">1080</div><div class="line">1081</div><div class="line">1082</div><div class="line">1083</div><div class="line">1084</div><div class="line">1085</div><div class="line">1086</div><div class="line">1087</div><div class="line">1088</div><div class="line">1089</div><div class="line">1090</div><div class="line">1091</div><div class="line">1092</div><div class="line">1093</div><div class="line">1094</div><div class="line">1095</div><div class="line">1096</div><div class="line">1097</div><div class="line">1098</div><div class="line">1099</div><div class="line">1100</div><div class="line">1101</div><div class="line">1102</div><div class="line">1103</div><div class="line">1104</div><div class="line">1105</div><div class="line">1106</div><div class="line">1107</div><div class="line">1108</div><div class="line">1109</div><div class="line">1110</div><div class="line">1111</div><div class="line">1112</div><div class="line">1113</div><div class="line">1114</div><div class="line">1115</div><div class="line">1116</div><div class="line">1117</div><div class="line">1118</div><div class="line">1119</div><div class="line">1120</div><div class="line">1121</div><div class="line">1122</div><div class="line">1123</div><div class="line">1124</div><div class="line">1125</div><div class="line">1126</div><div class="line">1127</div><div class="line">1128</div><div class="line">1129</div><div class="line">1130</div><div class="line">1131</div><div class="line">1132</div><div class="line">1133</div><div class="line">1134</div><div class="line">1135</div><div class="line">1136</div><div class="line">1137</div><div class="line">1138</div><div class="line">1139</div><div class="line">1140</div><div class="line">1141</div><div class="line">1142</div><div class="line">1143</div><div class="line">1144</div><div class="line">1145</div><div class="line">1146</div><div class="line">1147</div><div class="line">1148</div><div class="line">1149</div><div class="line">1150</div><div class="line">1151</div><div class="line">1152</div><div class="line">1153</div><div class="line">1154</div><div class="line">1155</div><div class="line">1156</div><div class="line">1157</div><div class="line">1158</div><div class="line">1159</div><div class="line">1160</div><div class="line">1161</div><div class="line">1162</div><div class="line">1163</div><div class="line">1164</div><div class="line">1165</div><div class="line">1166</div><div class="line">1167</div><div class="line">1168</div><div class="line">1169</div><div class="line">1170</div><div class="line">1171</div><div class="line">1172</div><div class="line">1173</div><div class="line">1174</div><div class="line">1175</div><div class="line">1176</div><div class="line">1177</div><div class="line">1178</div><div class="line">1179</div><div class="line">1180</div><div class="line">1181</div><div class="line">1182</div><div class="line">1183</div><div class="line">1184</div><div class="line">1185</div><div class="line">1186</div><div class="line">1187</div><div class="line">1188</div><div class="line">1189</div><div class="line">1190</div><div class="line">1191</div><div class="line">1192</div><div class="line">1193</div><div class="line">1194</div><div class="line">1195</div><div class="line">1196</div><div class="line">1197</div><div class="line">1198</div><div class="line">1199</div><div class="line">1200</div><div class="line">1201</div><div class="line">1202</div><div class="line">1203</div><div class="line">1204</div><div class="line">1205</div><div class="line">1206</div><div class="line">1207</div><div class="line">1208</div><div class="line">1209</div><div class="line">1210</div><div class="line">1211</div><div class="line">1212</div><div class="line">1213</div><div class="line">1214</div><div class="line">1215</div><div class="line">1216</div><div class="line">1217</div><div class="line">1218</div><div class="line">1219</div><div class="line">1220</div><div class="line">1221</div><div class="line">1222</div><div class="line">1223</div><div class="line">1224</div><div class="line">1225</div><div class="line">1226</div><div class="line">1227</div><div class="line">1228</div><div class="line">1229</div><div class="line">1230</div><div class="line">1231</div><div class="line">1232</div><div class="line">1233</div><div class="line">1234</div><div class="line">1235</div><div class="line">1236</div><div class="line">1237</div><div class="line">1238</div><div class="line">1239</div><div class="line">1240</div><div class="line">1241</div><div class="line">1242</div><div class="line">1243</div><div class="line">1244</div><div class="line">1245</div><div class="line">1246</div><div class="line">1247</div><div class="line">1248</div><div class="line">1249</div><div class="line">1250</div><div class="line">1251</div><div class="line">1252</div><div class="line">1253</div><div class="line">1254</div><div class="line">1255</div><div class="line">1256</div><div class="line">1257</div><div class="line">1258</div><div class="line">1259</div><div class="line">1260</div><div class="line">1261</div><div class="line">1262</div><div class="line">1263</div><div class="line">1264</div><div class="line">1265</div><div class="line">1266</div><div class="line">1267</div><div class="line">1268</div><div class="line">1269</div><div class="line">1270</div><div class="line">1271</div><div class="line">1272</div><div class="line">1273</div><div class="line">1274</div><div class="line">1275</div><div class="line">1276</div><div class="line">1277</div><div class="line">1278</div><div class="line">1279</div><div class="line">1280</div><div class="line">1281</div><div class="line">1282</div><div class="line">1283</div><div class="line">1284</div><div class="line">1285</div><div class="line">1286</div><div class="line">1287</div><div class="line">1288</div><div class="line">1289</div><div class="line">1290</div><div class="line">1291</div><div class="line">1292</div><div class="line">1293</div><div class="line">1294</div><div class="line">1295</div><div class="line">1296</div><div class="line">1297</div><div class="line">1298</div><div class="line">1299</div><div class="line">1300</div><div class="line">1301</div><div class="line">1302</div><div class="line">1303</div><div class="line">1304</div><div class="line">1305</div><div class="line">1306</div><div class="line">1307</div><div class="line">1308</div><div class="line">1309</div><div class="line">1310</div><div class="line">1311</div><div class="line">1312</div><div class="line">1313</div><div class="line">1314</div><div class="line">1315</div><div class="line">1316</div><div class="line">1317</div><div class="line">1318</div><div class="line">1319</div><div class="line">1320</div><div class="line">1321</div><div class="line">1322</div><div class="line">1323</div><div class="line">1324</div><div class="line">1325</div><div class="line">1326</div><div class="line">1327</div><div class="line">1328</div><div class="line">1329</div><div class="line">1330</div><div class="line">1331</div><div class="line">1332</div><div class="line">1333</div><div class="line">1334</div><div class="line">1335</div><div class="line">1336</div><div class="line">1337</div><div class="line">1338</div><div class="line">1339</div><div class="line">1340</div><div class="line">1341</div><div class="line">1342</div><div class="line">1343</div><div class="line">1344</div><div class="line">1345</div><div class="line">1346</div><div class="line">1347</div><div class="line">1348</div><div class="line">1349</div><div class="line">1350</div><div class="line">1351</div><div class="line">1352</div><div class="line">1353</div><div class="line">1354</div><div class="line">1355</div><div class="line">1356</div><div class="line">1357</div><div class="line">1358</div><div class="line">1359</div><div class="line">1360</div><div class="line">1361</div><div class="line">1362</div><div class="line">1363</div><div class="line">1364</div><div class="line">1365</div><div class="line">1366</div><div class="line">1367</div><div class="line">1368</div><div class="line">1369</div><div class="line">1370</div><div class="line">1371</div><div class="line">1372</div><div class="line">1373</div><div class="line">1374</div><div class="line">1375</div><div class="line">1376</div><div class="line">1377</div><div class="line">1378</div><div class="line">1379</div><div class="line">1380</div><div class="line">1381</div><div class="line">1382</div><div class="line">1383</div><div class="line">1384</div><div class="line">1385</div><div class="line">1386</div><div class="line">1387</div><div class="line">1388</div><div class="line">1389</div><div class="line">1390</div><div class="line">1391</div><div class="line">1392</div><div class="line">1393</div><div class="line">1394</div><div class="line">1395</div><div class="line">1396</div><div class="line">1397</div><div class="line">1398</div><div class="line">1399</div><div class="line">1400</div><div class="line">1401</div><div class="line">1402</div><div class="line">1403</div><div class="line">1404</div><div class="line">1405</div><div class="line">1406</div><div class="line">1407</div><div class="line">1408</div><div class="line">1409</div><div class="line">1410</div><div class="line">1411</div><div class="line">1412</div><div class="line">1413</div><div class="line">1414</div><div class="line">1415</div><div class="line">1416</div><div class="line">1417</div><div class="line">1418</div><div class="line">1419</div><div class="line">1420</div><div class="line">1421</div><div class="line">1422</div><div class="line">1423</div><div class="line">1424</div><div class="line">1425</div><div class="line">1426</div><div class="line">1427</div><div class="line">1428</div><div class="line">1429</div><div class="line">1430</div><div class="line">1431</div><div class="line">1432</div><div class="line">1433</div><div class="line">1434</div><div class="line">1435</div><div class="line">1436</div><div class="line">1437</div><div class="line">1438</div><div class="line">1439</div><div class="line">1440</div><div class="line">1441</div><div class="line">1442</div><div class="line">1443</div><div class="line">1444</div><div class="line">1445</div><div class="line">1446</div><div class="line">1447</div><div class="line">1448</div><div class="line">1449</div><div class="line">1450</div><div class="line">1451</div><div class="line">1452</div><div class="line">1453</div><div class="line">1454</div><div class="line">1455</div><div class="line">1456</div><div class="line">1457</div><div class="line">1458</div><div class="line">1459</div><div class="line">1460</div><div class="line">1461</div><div class="line">1462</div><div class="line">1463</div><div class="line">1464</div><div class="line">1465</div><div class="line">1466</div><div class="line">1467</div><div class="line">1468</div><div class="line">1469</div><div class="line">1470</div><div class="line">1471</div><div class="line">1472</div><div class="line">1473</div><div class="line">1474</div><div class="line">1475</div><div class="line">1476</div><div class="line">1477</div><div class="line">1478</div><div class="line">1479</div><div class="line">1480</div><div class="line">1481</div><div class="line">1482</div><div class="line">1483</div><div class="line">1484</div><div class="line">1485</div><div class="line">1486</div><div class="line">1487</div><div class="line">1488</div><div class="line">1489</div><div class="line">1490</div><div class="line">1491</div><div class="line">1492</div><div class="line">1493</div><div class="line">1494</div><div class="line">1495</div><div class="line">1496</div><div class="line">1497</div><div class="line">1498</div><div class="line">1499</div><div class="line">1500</div><div class="line">1501</div><div class="line">1502</div><div class="line">1503</div><div class="line">1504</div><div class="line">1505</div><div class="line">1506</div><div class="line">1507</div><div class="line">1508</div><div class="line">1509</div><div class="line">1510</div><div class="line">1511</div><div class="line">1512</div><div class="line">1513</div><div class="line">1514</div><div class="line">1515</div><div class="line">1516</div><div class="line">1517</div><div class="line">1518</div><div class="line">1519</div><div class="line">1520</div><div class="line">1521</div><div class="line">1522</div><div class="line">1523</div><div class="line">1524</div><div class="line">1525</div><div class="line">1526</div><div class="line">1527</div><div class="line">1528</div><div class="line">1529</div><div class="line">1530</div><div class="line">1531</div><div class="line">1532</div><div class="line">1533</div><div class="line">1534</div><div class="line">1535</div><div class="line">1536</div><div class="line">1537</div><div class="line">1538</div><div class="line">1539</div><div class="line">1540</div><div class="line">1541</div><div class="line">1542</div><div class="line">1543</div><div class="line">1544</div><div class="line">1545</div><div class="line">1546</div><div class="line">1547</div><div class="line">1548</div><div class="line">1549</div><div class="line">1550</div><div class="line">1551</div><div class="line">1552</div><div class="line">1553</div><div class="line">1554</div><div class="line">1555</div><div class="line">1556</div><div class="line">1557</div><div class="line">1558</div><div class="line">1559</div><div class="line">1560</div><div class="line">1561</div><div class="line">1562</div><div class="line">1563</div><div class="line">1564</div><div class="line">1565</div><div class="line">1566</div><div class="line">1567</div><div class="line">1568</div><div class="line">1569</div><div class="line">1570</div><div class="line">1571</div><div class="line">1572</div><div class="line">1573</div><div class="line">1574</div><div class="line">1575</div><div class="line">1576</div><div class="line">1577</div><div class="line">1578</div><div class="line">1579</div><div class="line">1580</div><div class="line">1581</div><div class="line">1582</div><div class="line">1583</div><div class="line">1584</div><div class="line">1585</div><div class="line">1586</div><div class="line">1587</div><div class="line">1588</div><div class="line">1589</div><div class="line">1590</div><div class="line">1591</div><div class="line">1592</div><div class="line">1593</div><div class="line">1594</div><div class="line">1595</div><div class="line">1596</div><div class="line">1597</div><div class="line">1598</div><div class="line">1599</div><div class="line">1600</div><div class="line">1601</div><div class="line">1602</div><div class="line">1603</div><div class="line">1604</div><div class="line">1605</div><div class="line">1606</div><div class="line">1607</div><div class="line">1608</div><div class="line">1609</div><div class="line">1610</div><div class="line">1611</div><div class="line">1612</div><div class="line">1613</div><div class="line">1614</div><div class="line">1615</div><div class="line">1616</div><div class="line">1617</div><div class="line">1618</div><div class="line">1619</div><div class="line">1620</div><div class="line">1621</div><div class="line">1622</div><div class="line">1623</div><div class="line">1624</div><div class="line">1625</div><div class="line">1626</div><div class="line">1627</div><div class="line">1628</div><div class="line">1629</div><div class="line">1630</div><div class="line">1631</div><div class="line">1632</div><div class="line">1633</div><div class="line">1634</div><div class="line">1635</div><div class="line">1636</div><div class="line">1637</div><div class="line">1638</div><div class="line">1639</div><div class="line">1640</div><div class="line">1641</div><div class="line">1642</div><div class="line">1643</div><div class="line">1644</div><div class="line">1645</div><div class="line">1646</div><div class="line">1647</div><div class="line">1648</div><div class="line">1649</div><div class="line">1650</div><div class="line">1651</div><div class="line">1652</div><div class="line">1653</div><div class="line">1654</div><div class="line">1655</div><div class="line">1656</div><div class="line">1657</div><div class="line">1658</div><div class="line">1659</div><div class="line">1660</div><div class="line">1661</div><div class="line">1662</div><div class="line">1663</div><div class="line">1664</div><div class="line">1665</div><div class="line">1666</div><div class="line">1667</div><div class="line">1668</div><div class="line">1669</div><div class="line">1670</div><div class="line">1671</div><div class="line">1672</div><div class="line">1673</div><div class="line">1674</div><div class="line">1675</div><div class="line">1676</div><div class="line">1677</div><div class="line">1678</div><div class="line">1679</div><div class="line">1680</div><div class="line">1681</div><div class="line">1682</div><div class="line">1683</div><div class="line">1684</div><div class="line">1685</div><div class="line">1686</div><div class="line">1687</div><div class="line">1688</div><div class="line">1689</div><div class="line">1690</div><div class="line">1691</div><div class="line">1692</div><div class="line">1693</div><div class="line">1694</div><div class="line">1695</div><div class="line">1696</div><div class="line">1697</div><div class="line">1698</div><div class="line">1699</div><div class="line">1700</div><div class="line">1701</div><div class="line">1702</div><div class="line">1703</div><div class="line">1704</div><div class="line">1705</div><div class="line">1706</div><div class="line">1707</div><div class="line">1708</div><div class="line">1709</div><div class="line">1710</div><div class="line">1711</div><div class="line">1712</div><div class="line">1713</div><div class="line">1714</div><div class="line">1715</div><div class="line">1716</div><div class="line">1717</div><div class="line">1718</div><div class="line">1719</div><div class="line">1720</div><div class="line">1721</div><div class="line">1722</div><div class="line">1723</div><div class="line">1724</div><div class="line">1725</div><div class="line">1726</div><div class="line">1727</div><div class="line">1728</div><div class="line">1729</div><div class="line">1730</div><div class="line">1731</div><div class="line">1732</div><div class="line">1733</div><div class="line">1734</div><div class="line">1735</div><div class="line">1736</div><div class="line">1737</div><div class="line">1738</div><div class="line">1739</div><div class="line">1740</div><div class="line">1741</div><div class="line">1742</div><div class="line">1743</div><div class="line">1744</div><div class="line">1745</div><div class="line">1746</div><div class="line">1747</div><div class="line">1748</div><div class="line">1749</div><div class="line">1750</div><div class="line">1751</div><div class="line">1752</div><div class="line">1753</div><div class="line">1754</div><div class="line">1755</div><div class="line">1756</div><div class="line">1757</div><div class="line">1758</div><div class="line">1759</div><div class="line">1760</div><div class="line">1761</div><div class="line">1762</div><div class="line">1763</div><div class="line">1764</div><div class="line">1765</div><div class="line">1766</div><div class="line">1767</div><div class="line">1768</div><div class="line">1769</div><div class="line">1770</div><div class="line">1771</div><div class="line">1772</div><div class="line">1773</div><div class="line">1774</div><div class="line">1775</div><div class="line">1776</div><div class="line">1777</div><div class="line">1778</div><div class="line">1779</div><div class="line">1780</div><div class="line">1781</div><div class="line">1782</div><div class="line">1783</div><div class="line">1784</div><div class="line">1785</div><div class="line">1786</div><div class="line">1787</div><div class="line">1788</div><div class="line">1789</div><div class="line">1790</div><div class="line">1791</div><div class="line">1792</div><div class="line">1793</div><div class="line">1794</div><div class="line">1795</div><div class="line">1796</div><div class="line">1797</div><div class="line">1798</div><div class="line">1799</div><div class="line">1800</div><div class="line">1801</div><div class="line">1802</div><div class="line">1803</div><div class="line">1804</div><div class="line">1805</div><div class="line">1806</div><div class="line">1807</div><div class="line">1808</div><div class="line">1809</div><div class="line">1810</div><div class="line">1811</div><div class="line">1812</div><div class="line">1813</div><div class="line">1814</div><div class="line">1815</div><div class="line">1816</div><div class="line">1817</div><div class="line">1818</div><div class="line">1819</div><div class="line">1820</div><div class="line">1821</div><div class="line">1822</div><div class="line">1823</div><div class="line">1824</div><div class="line">1825</div><div class="line">1826</div><div class="line">1827</div><div class="line">1828</div><div class="line">1829</div><div class="line">1830</div><div class="line">1831</div><div class="line">1832</div><div class="line">1833</div><div class="line">1834</div><div class="line">1835</div><div class="line">1836</div><div class="line">1837</div><div class="line">1838</div><div class="line">1839</div><div class="line">1840</div><div class="line">1841</div><div class="line">1842</div><div class="line">1843</div><div class="line">1844</div><div class="line">1845</div><div class="line">1846</div><div class="line">1847</div><div class="line">1848</div><div class="line">1849</div><div class="line">1850</div><div class="line">1851</div><div class="line">1852</div><div class="line">1853</div><div class="line">1854</div><div class="line">1855</div><div class="line">1856</div><div class="line">1857</div><div class="line">1858</div><div class="line">1859</div><div class="line">1860</div><div class="line">1861</div><div class="line">1862</div><div class="line">1863</div><div class="line">1864</div><div class="line">1865</div><div class="line">1866</div><div class="line">1867</div><div class="line">1868</div><div class="line">1869</div><div class="line">1870</div><div class="line">1871</div><div class="line">1872</div><div class="line">1873</div><div class="line">1874</div><div class="line">1875</div><div class="line">1876</div><div class="line">1877</div><div class="line">1878</div><div class="line">1879</div><div class="line">1880</div><div class="line">1881</div><div class="line">1882</div><div class="line">1883</div><div class="line">1884</div><div class="line">1885</div><div class="line">1886</div><div class="line">1887</div><div class="line">1888</div><div class="line">1889</div><div class="line">1890</div><div class="line">1891</div><div class="line">1892</div><div class="line">1893</div><div class="line">1894</div><div class="line">1895</div><div class="line">1896</div><div class="line">1897</div><div class="line">1898</div><div class="line">1899</div><div class="line">1900</div><div class="line">1901</div><div class="line">1902</div><div class="line">1903</div><div class="line">1904</div><div class="line">1905</div><div class="line">1906</div><div class="line">1907</div><div class="line">1908</div><div class="line">1909</div><div class="line">1910</div><div class="line">1911</div><div class="line">1912</div><div class="line">1913</div><div class="line">1914</div><div class="line">1915</div><div class="line">1916</div><div class="line">1917</div><div class="line">1918</div><div class="line">1919</div><div class="line">1920</div><div class="line">1921</div><div class="line">1922</div><div class="line">1923</div><div class="line">1924</div><div class="line">1925</div><div class="line">1926</div><div class="line">1927</div><div class="line">1928</div><div class="line">1929</div><div class="line">1930</div><div class="line">1931</div><div class="line">1932</div><div class="line">1933</div><div class="line">1934</div><div class="line">1935</div><div class="line">1936</div><div class="line">1937</div><div class="line">1938</div><div class="line">1939</div><div class="line">1940</div><div class="line">1941</div><div class="line">1942</div><div class="line">1943</div><div class="line">1944</div><div class="line">1945</div><div class="line">1946</div><div class="line">1947</div><div class="line">1948</div><div class="line">1949</div><div class="line">1950</div><div class="line">1951</div><div class="line">1952</div><div class="line">1953</div><div class="line">1954</div><div class="line">1955</div><div class="line">1956</div><div class="line">1957</div><div class="line">1958</div><div class="line">1959</div><div class="line">1960</div><div class="line">1961</div><div class="line">1962</div><div class="line">1963</div><div class="line">1964</div><div class="line">1965</div><div class="line">1966</div><div class="line">1967</div><div class="line">1968</div><div class="line">1969</div><div class="line">1970</div><div class="line">1971</div><div class="line">1972</div><div class="line">1973</div><div class="line">1974</div><div class="line">1975</div><div class="line">1976</div><div class="line">1977</div><div class="line">1978</div><div class="line">1979</div><div class="line">1980</div><div class="line">1981</div><div class="line">1982</div><div class="line">1983</div><div class="line">1984</div><div class="line">1985</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Backbone.js 0.9.2</span></div><div class="line"><span class="comment">// (c) 2010-2012 Jeremy Ashkenas, DocumentCloud Inc.</span></div><div class="line"><span class="comment">// Backbone may be freely distributed under the MIT license.</span></div><div class="line"><span class="comment">// For all details and documentation:</span></div><div class="line"><span class="comment">// http://backbonejs.org</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">    <span class="comment">// 创建一个全局对象, 在浏览器中表示为window对象, 在Node.js中表示global对象</span></div><div class="line">    <span class="keyword">var</span> root = <span class="keyword">this</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// 保存"Backbone"变量被覆盖之前的值</span></div><div class="line">    <span class="comment">// 如果出现命名冲突或考虑到规范, 可通过Backbone.noConflict()方法恢复该变量被Backbone占用之前的值, 并返回Backbone对象以便重新命名</span></div><div class="line">    <span class="keyword">var</span> previousBackbone = root.Backbone;</div><div class="line"> </div><div class="line">    <span class="comment">// 将Array.prototype中的slice和splice方法缓存到局部变量以供调用</span></div><div class="line">    <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</div><div class="line">    <span class="keyword">var</span> splice = <span class="built_in">Array</span>.prototype.splice;</div><div class="line"> </div><div class="line">    <span class="keyword">var</span> Backbone;</div><div class="line">    <span class="keyword">if</span>( <span class="keyword">typeof</span> exports !== <span class="string">'undefined'</span>) &#123;</div><div class="line">        Backbone = exports;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Backbone = root.Backbone = &#123;&#125;;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// 定义Backbone版本</span></div><div class="line">    Backbone.VERSION = <span class="string">'0.9.2'</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// 在服务器环境下自动导入Underscore, 在Backbone中部分方法依赖或继承自Underscore</span></div><div class="line">    <span class="keyword">var</span> _ = root._;</div><div class="line">    <span class="keyword">if</span>(!_ &amp;&amp; ( <span class="keyword">typeof</span> <span class="built_in">require</span> !== <span class="string">'undefined'</span>))</div><div class="line">        _ = <span class="built_in">require</span>(<span class="string">'underscore'</span>);</div><div class="line"> </div><div class="line">    <span class="comment">// 定义第三方库为统一的变量"$", 用于在视图(View), 事件处理和与服务器数据同步(sync)时调用库中的方法</span></div><div class="line">    <span class="comment">// 支持的库包括jQuery, Zepto等, 它们语法相同, 但Zepto更适用移动开发, 它主要针对Webkit内核浏览器</span></div><div class="line">    <span class="comment">// 也可以通过自定义一个与jQuery语法相似的自定义库, 供Backbone使用(有时我们可能需要一个比jQuery, Zepto更轻巧的自定义版本)</span></div><div class="line">    <span class="comment">// 这里定义的"$"是局部变量, 因此不会影响在Backbone框架之外第三方库的正常使用</span></div><div class="line">    <span class="keyword">var</span> $ = root.jQuery || root.Zepto || root.ender;</div><div class="line"> </div><div class="line">    <span class="comment">// 手动设置第三方库</span></div><div class="line">    <span class="comment">// 如果在导入了Backbone之前并没有导入第三方库, 可以通过setDomLibrary方法设置"$"局部变量</span></div><div class="line">    <span class="comment">// setDomLibrary方法也常用于在Backbone中动态导入自定义库</span></div><div class="line">    Backbone.setDomLibrary = <span class="function"><span class="keyword">function</span>(<span class="params">lib</span>) </span>&#123;</div><div class="line">        $ = lib;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 放弃以"Backbone"命名框架, 并返回Backbone对象, 一般用于避免命名冲突或规范命名方式</span></div><div class="line">    <span class="comment">// 例如:</span></div><div class="line">    <span class="comment">// var bk = Backbone.noConflict(); // 取消"Backbone"命名, 并将Backbone对象存放于bk变量中</span></div><div class="line">    <span class="comment">// console.log(Backbone); // 该变量已经无法再访问Backbone对象, 而恢复为Backbone定义前的值</span></div><div class="line">    <span class="comment">// var MyBackbone = bk; // 而bk存储了Backbone对象, 我们将它重命名为MyBackbone</span></div><div class="line">    Backbone.noConflict = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        root.Backbone = previousBackbone;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 对于不支持REST方式的浏览器, 可以设置Backbone.emulateHTTP = true</span></div><div class="line">    <span class="comment">// 与服务器请求将以POST方式发送, 并在数据中加入_method参数标识操作名称, 同时也将发送X-HTTP-Method-Override头信息</span></div><div class="line">    Backbone.emulateHTTP = <span class="literal">false</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// 对于不支持application/json编码的浏览器, 可以设置Backbone.emulateJSON = true;</span></div><div class="line">    <span class="comment">// 将请求类型设置为application/x-www-form-urlencoded, 并将数据放置在model参数中实现兼容</span></div><div class="line">    Backbone.emulateJSON = <span class="literal">false</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// Backbone.Events 自定义事件相关</span></div><div class="line">    <span class="comment">// -----------------</span></div><div class="line"> </div><div class="line">    <span class="comment">// eventSplitter指定处理多个事件时, 事件名称的解析规则</span></div><div class="line">    <span class="keyword">var</span> eventSplitter = <span class="regexp">/\s+/</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// 自定义事件管理器</span></div><div class="line">    <span class="comment">// 通过在对象中绑定Events相关方法, 允许向对象添加, 删除和触发自定义事件</span></div><div class="line">    <span class="keyword">var</span> Events = Backbone.Events = &#123;</div><div class="line"> </div><div class="line">        <span class="comment">// 将自定义事件(events)和回调函数(callback)绑定到当前对象</span></div><div class="line">        <span class="comment">// 回调函数中的上下文对象为指定的context, 如果没有设置context则上下文对象默认为当前绑定事件的对象</span></div><div class="line">        <span class="comment">// 该方法类似与DOM Level2中的addEventListener方法</span></div><div class="line">        <span class="comment">// events允许指定多个事件名称, 通过空白字符进行分隔(如空格, 制表符等)</span></div><div class="line">        <span class="comment">// 当事件名称为"all"时, 在调用trigger方法触发任何事件时, 均会调用"all"事件中绑定的所有回调函数</span></div><div class="line">        on : <span class="function"><span class="keyword">function</span>(<span class="params">events, callback, context</span>) </span>&#123;</div><div class="line">            <span class="comment">// 定义一些函数中使用到的局部变量</span></div><div class="line">            <span class="keyword">var</span> calls, event, node, tail, list;</div><div class="line">            <span class="comment">// 必须设置callback回调函数</span></div><div class="line">            <span class="keyword">if</span>(!callback)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">            <span class="comment">// 通过eventSplitter对事件名称进行解析, 使用split将多个事件名拆分为一个数组</span></div><div class="line">            <span class="comment">// 一般使用空白字符指定多个事件名称</span></div><div class="line">            events = events.split(eventSplitter);</div><div class="line">            <span class="comment">// calls记录了当前对象中已绑定的事件与回调函数列表</span></div><div class="line">            calls = <span class="keyword">this</span>._callbacks || (<span class="keyword">this</span>._callbacks = &#123;&#125;);</div><div class="line"> </div><div class="line">            <span class="comment">// 循环事件名列表, 从头至尾依次将事件名存放至event变量</span></div><div class="line">            <span class="keyword">while</span>( event = events.shift()) &#123;</div><div class="line">                <span class="comment">// 获取已经绑定event事件的回调函数</span></div><div class="line">                <span class="comment">// list存储单个事件名中绑定的callback回调函数列表</span></div><div class="line">                <span class="comment">// 函数列表并没有通过数组方式存储, 而是通过多个对象的next属性进行依次关联</span></div><div class="line">                <span class="comment">/** 数据格式如:</span></div><div class="line">                 * &#123;</div><div class="line">                 *     tail: &#123;Object&#125;,</div><div class="line">                 *     next: &#123;</div><div class="line">                 *         callback: &#123;Function&#125;,</div><div class="line">                 *         context: &#123;Object&#125;,</div><div class="line">                 *         next: &#123;</div><div class="line">                 *             callback: &#123;Function&#125;,</div><div class="line">                 *             context: &#123;Object&#125;,</div><div class="line">                 *             next: &#123;Object&#125;</div><div class="line">                 *         &#125;</div><div class="line">                 *     &#125;</div><div class="line">                 * &#125;</div><div class="line">                 */</div><div class="line">                <span class="comment">// 列表每一层next对象存储了一次回调事件相关信息(函数体, 上下文和下一次回调事件)</span></div><div class="line">                <span class="comment">// 事件列表最顶层存储了一个tail对象, 它存储了最后一次绑定回调事件的标识(与最后一次回调事件的next指向同一个对象)</span></div><div class="line">                <span class="comment">// 通过tail标识, 可以在遍历回调列表时得知已经到达最后一个回调函数</span></div><div class="line">                list = calls[event];</div><div class="line">                <span class="comment">// node变量用于记录本次回调函数的相关信息</span></div><div class="line">                <span class="comment">// tail只存储最后一次绑定回调函数的标识</span></div><div class="line">                <span class="comment">// 因此如果之前已经绑定过回调函数, 则将之前的tail指定给node作为一个对象使用, 然后创建一个新的对象标识给tail</span></div><div class="line">                <span class="comment">// 这里之所以要将本次回调事件添加到上一次回调的tail对象, 是为了让回调函数列表的对象层次关系按照绑定顺序排列(最新绑定的事件将被放到最底层)</span></div><div class="line">                node = list ? list.tail : &#123;&#125;;</div><div class="line">                node.next = tail = &#123;&#125;;</div><div class="line">                <span class="comment">// 记录本次回调的函数体及上下文信息</span></div><div class="line">                node.context = context;</div><div class="line">                node.callback = callback;</div><div class="line">                <span class="comment">// 重新组装当前事件的回调列表, 列表中已经加入了本次回调事件</span></div><div class="line">                calls[event] = &#123;</div><div class="line">                    <span class="attr">tail</span> : tail,</div><div class="line">                    <span class="attr">next</span> : list ? list.next : node</div><div class="line">                &#125;;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 返回当前对象, 方便进行方法链调用</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 移除对象中已绑定的事件或回调函数, 可以通过events, callback和context对需要删除的事件或回调函数进行过滤</span></div><div class="line">        <span class="comment">// - 如果context为空, 则移除所有的callback指定的函数</span></div><div class="line">        <span class="comment">// - 如果callback为空, 则移除事件中所有的回调函数</span></div><div class="line">        <span class="comment">// - 如果events为空, 但指定了callback或context, 则移除callback或context指定的回调函数(不区分事件名称)</span></div><div class="line">        <span class="comment">// - 如果没有传递任何参数, 则移除对象中绑定的所有事件和回调函数</span></div><div class="line">        off : <span class="function"><span class="keyword">function</span>(<span class="params">events, callback, context</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> event, calls, node, tail, cb, ctx;</div><div class="line"> </div><div class="line">            <span class="comment">// No events, or removing *all* events.</span></div><div class="line">            <span class="comment">// 当前对象没有绑定任何事件</span></div><div class="line">            <span class="keyword">if</span>(!( calls = <span class="keyword">this</span>._callbacks))</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="comment">// 如果没有指定任何参数, 则移除所有事件和回调函数(删除_callbacks属性)</span></div><div class="line">            <span class="keyword">if</span>(!(events || callback || context)) &#123;</div><div class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>._callbacks;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">// 解析需要移除的事件列表</span></div><div class="line">            <span class="comment">// - 如果指定了events, 则按照eventSplitter对事件名进行解析</span></div><div class="line">            <span class="comment">// - 如果没有指定events, 则解析已绑定所有事件的名称列表</span></div><div class="line">            events = events ? events.split(eventSplitter) : _.keys(calls);</div><div class="line"> </div><div class="line">            <span class="comment">// 循环事件名列表</span></div><div class="line">            <span class="keyword">while</span>( event = events.shift()) &#123;</div><div class="line">                <span class="comment">// 将当前事件对象从列表中移除, 并缓存到node变量中</span></div><div class="line">                node = calls[event];</div><div class="line">                <span class="keyword">delete</span> calls[event];</div><div class="line">                <span class="comment">// 如果不存在当前事件对象(或没有指定移除过滤条件, 则认为将移除当前事件及所有回调函数), 则终止此次操作(事件对象在上一步已经移除)</span></div><div class="line">                <span class="keyword">if</span>(!node || !(callback || context))</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                <span class="comment">// Create a new list, omitting the indicated callbacks.</span></div><div class="line">                <span class="comment">// 根据回调函数或上下文过滤条件, 组装一个新的事件对象并重新绑定</span></div><div class="line">                tail = node.tail;</div><div class="line">                <span class="comment">// 遍历事件中的所有回调对象</span></div><div class="line">                <span class="keyword">while</span>(( node = node.next) !== tail) &#123;</div><div class="line">                    cb = node.callback;</div><div class="line">                    ctx = node.context;</div><div class="line">                    <span class="comment">// 根据参数中的回调函数和上下文, 对回调函数进行过滤, 将不符合过滤条件的回调函数重新绑定到事件中(因为事件中的所有回调函数在上面已经被移除)</span></div><div class="line">                    <span class="keyword">if</span>((callback &amp;&amp; cb !== callback) || (context &amp;&amp; ctx !== context)) &#123;</div><div class="line">                        <span class="keyword">this</span>.on(event, cb, ctx);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 触发已经定义的一个或多个事件, 依次执行绑定的回调函数列表</span></div><div class="line">        trigger : <span class="function"><span class="keyword">function</span>(<span class="params">events</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> event, node, calls, tail, args, all, rest;</div><div class="line">            <span class="comment">// 当前对象没有绑定任何事件</span></div><div class="line">            <span class="keyword">if</span>(!( calls = <span class="keyword">this</span>._callbacks))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">            <span class="comment">// 获取回调函数列表中绑定的"all"事件列表</span></div><div class="line">            all = calls.all;</div><div class="line">            <span class="comment">// 将需要触发的事件名称, 按照eventSplitter规则解析为一个数组</span></div><div class="line">            events = events.split(eventSplitter);</div><div class="line">            <span class="comment">// 将trigger从第2个之后的参数, 记录到rest变量, 将依次传递给回调函数</span></div><div class="line">            rest = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line"> </div><div class="line">            <span class="comment">// 循环需要触发的事件列表</span></div><div class="line">            <span class="keyword">while</span>( event = events.shift()) &#123;</div><div class="line">                <span class="comment">// 此处的node变量记录了当前事件的所有回调函数列表</span></div><div class="line">                <span class="keyword">if</span>( node = calls[event]) &#123;</div><div class="line">                    <span class="comment">// tail变量记录最后一次绑定事件的对象标识</span></div><div class="line">                    tail = node.tail;</div><div class="line">                    <span class="comment">// node变量的值, 按照事件的绑定顺序, 被依次赋值为绑定的单个回调事件对象</span></div><div class="line">                    <span class="comment">// 最后一次绑定的事件next属性, 与tail引用同一个对象, 以此作为是否到达列表末尾的判断依据</span></div><div class="line">                    <span class="keyword">while</span>(( node = node.next) !== tail) &#123;</div><div class="line">                        <span class="comment">// 执行所有绑定的事件, 并将调用trigger时的参数传递给回调函数</span></div><div class="line">                        node.callback.apply(node.context || <span class="keyword">this</span>, rest);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 变量all记录了绑定时的"all"事件, 即在调用任何事件时, "all"事件中的回调函数均会被执行</span></div><div class="line">                <span class="comment">// - "all"事件中的回调函数无论绑定顺序如何, 都会在当前事件的回调函数列表全部执行完毕后再依次执行</span></div><div class="line">                <span class="comment">// - "all"事件应该在触发普通事件时被自动调用, 如果强制触发"all"事件, 事件中的回调函数将被执行两次</span></div><div class="line">                <span class="keyword">if</span>( node = all) &#123;</div><div class="line">                    tail = node.tail;</div><div class="line">                    <span class="comment">// 与调用普通事件的回调函数不同之处在于, all事件会将当前调用的事件名作为第一个参数传递给回调函数</span></div><div class="line">                    args = [event].concat(rest);</div><div class="line">                    <span class="comment">// 遍历并执行"all"事件中的回调函数列表</span></div><div class="line">                    <span class="keyword">while</span>(( node = node.next) !== tail) &#123;</div><div class="line">                        node.callback.apply(node.context || <span class="keyword">this</span>, args);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">    <span class="comment">// 绑定事件与释放事件的别名, 也为了同时兼容Backbone以前的版本</span></div><div class="line">    Events.bind = Events.on;</div><div class="line">    Events.unbind = Events.off;</div><div class="line"> </div><div class="line">    <span class="comment">// Backbone.Model 数据对象模型</span></div><div class="line">    <span class="comment">// --------------</span></div><div class="line"> </div><div class="line">    <span class="comment">// Model是Backbone中所有数据对象模型的基类, 用于创建一个数据模型</span></div><div class="line">    <span class="comment">// @param &#123;Object&#125; attributes 指定创建模型时的初始化数据</span></div><div class="line">    <span class="comment">// @param &#123;Object&#125; options</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * @format options</div><div class="line">     * &#123;</div><div class="line">     *     parse: &#123;Boolean&#125;,</div><div class="line">     *     collection: &#123;Collection&#125;</div><div class="line">     * &#125;</div><div class="line">     */</div><div class="line">    <span class="keyword">var</span> Model = Backbone.Model = <span class="function"><span class="keyword">function</span>(<span class="params">attributes, options</span>) </span>&#123;</div><div class="line">        <span class="comment">// defaults变量用于存储模型的默认数据</span></div><div class="line">        <span class="keyword">var</span> defaults;</div><div class="line">        <span class="comment">// 如果没有指定attributes参数, 则设置attributes为空对象</span></div><div class="line">        attributes || ( attributes = &#123;&#125;);</div><div class="line">        <span class="comment">// 设置attributes默认数据的解析方法, 例如默认数据是从服务器获取(或原始数据是XML格式), 为了兼容set方法所需的数据格式, 可使用parse方法进行解析</span></div><div class="line">        <span class="keyword">if</span>(options &amp;&amp; options.parse)</div><div class="line">            attributes = <span class="keyword">this</span>.parse(attributes);</div><div class="line">        <span class="keyword">if</span>( defaults = getValue(<span class="keyword">this</span>, <span class="string">'defaults'</span>)) &#123;</div><div class="line">            <span class="comment">// 如果Model在定义时设置了defaults默认数据, 则初始化数据使用defaults与attributes参数合并后的数据(attributes中的数据会覆盖defaults中的同名数据)</span></div><div class="line">            attributes = _.extend(&#123;&#125;, defaults, attributes);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 显式指定模型所属的Collection对象(在调用Collection的add, push等将模型添加到集合中的方法时, 会自动设置模型所属的Collection对象)</span></div><div class="line">        <span class="keyword">if</span>(options &amp;&amp; options.collection)</div><div class="line">            <span class="keyword">this</span>.collection = options.collection;</div><div class="line">        <span class="comment">// attributes属性存储了当前模型的JSON对象化数据, 创建模型时默认为空</span></div><div class="line">        <span class="keyword">this</span>.attributes = &#123;&#125;;</div><div class="line">        <span class="comment">// 定义_escapedAttributes缓存对象, 它将缓存通过escape方法处理过的数据</span></div><div class="line">        <span class="keyword">this</span>._escapedAttributes = &#123;&#125;;</div><div class="line">        <span class="comment">// 为每一个模型配置一个唯一标识</span></div><div class="line">        <span class="keyword">this</span>.cid = _.uniqueId(<span class="string">'c'</span>);</div><div class="line">        <span class="comment">// 定义一系列用于记录数据状态的对象, 具体含义请参考对象定义时的注释</span></div><div class="line">        <span class="keyword">this</span>.changed = &#123;&#125;;</div><div class="line">        <span class="keyword">this</span>._silent = &#123;&#125;;</div><div class="line">        <span class="keyword">this</span>._pending = &#123;&#125;;</div><div class="line">        <span class="comment">// 创建实例时设置初始化数据, 首次设置使用silent参数, 不会触发change事件</span></div><div class="line">        <span class="keyword">this</span>.set(attributes, &#123;</div><div class="line">            <span class="attr">silent</span> : <span class="literal">true</span></div><div class="line">        &#125;);</div><div class="line">        <span class="comment">// 上面已经设置了初始化数据, changed, _silent, _pending对象的状态可能已经发生变化, 这里重新进行初始化</span></div><div class="line">        <span class="keyword">this</span>.changed = &#123;&#125;;</div><div class="line">        <span class="keyword">this</span>._silent = &#123;&#125;;</div><div class="line">        <span class="keyword">this</span>._pending = &#123;&#125;;</div><div class="line">        <span class="comment">// _previousAttributes变量存储模型数据的一个副本</span></div><div class="line">        <span class="comment">// 用于在change事件中获取模型数据被改变之前的状态, 可通过previous或previousAttributes方法获取上一个状态的数据</span></div><div class="line">        <span class="keyword">this</span>._previousAttributes = _.clone(<span class="keyword">this</span>.attributes);</div><div class="line">        <span class="comment">// 调用initialize初始化方法</span></div><div class="line">        <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 使用extend方法为Model原型定义一系列属性和方法</span></div><div class="line">    _.extend(Model.prototype, Events, &#123;</div><div class="line"> </div><div class="line">        <span class="comment">// changed属性记录了每次调用set方法时, 被改变数据的key集合</span></div><div class="line">        changed : <span class="literal">null</span>,</div><div class="line"> </div><div class="line">        <span class="comment">// // 当指定silent属性时, 不会触发change事件, 被改变的数据会记录下来, 直到下一次触发change事件</span></div><div class="line">        <span class="comment">// _silent属性用来记录使用silent时的被改变的数据</span></div><div class="line">        _silent : <span class="literal">null</span>,</div><div class="line"> </div><div class="line">        <span class="attr">_pending</span> : <span class="literal">null</span>,</div><div class="line"> </div><div class="line">        <span class="comment">// 每个模型的唯一标识属性(默认为"id", 通过修改idAttribute可自定义id属性名)</span></div><div class="line">        <span class="comment">// 如果在设置数据时包含了id属性, 则id将会覆盖模型的id</span></div><div class="line">        <span class="comment">// id用于在Collection集合中查找和标识模型, 与后台接口通信时也会以id作为一条记录的标识</span></div><div class="line">        idAttribute : <span class="string">'id'</span>,</div><div class="line"> </div><div class="line">        <span class="comment">// 模型初始化方法, 在模型被构造结束后自动调用</span></div><div class="line">        initialize : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 返回当前模型中数据的一个副本(JSON对象格式)</span></div><div class="line">        toJSON : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> _.clone(<span class="keyword">this</span>.attributes);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 根据attr属性名, 获取模型中的数据值</span></div><div class="line">        get : <span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.attributes[attr];</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 根据attr属性名, 获取模型中的数据值, 数据值包含的HTML特殊字符将被转换为HTML实体, 包含 &amp; &lt; &gt; " ' \</span></div><div class="line">        <span class="comment">// 通过 _.escape方法实现</span></div><div class="line">        <span class="built_in">escape</span> : <span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> html;</div><div class="line">            <span class="comment">// 从_escapedAttributes缓存对象中查找数据, 如果数据已经被缓存则直接返回</span></div><div class="line">            <span class="keyword">if</span>( html = <span class="keyword">this</span>._escapedAttributes[attr])</div><div class="line">                <span class="keyword">return</span> html;</div><div class="line">            <span class="comment">// _escapedAttributes缓存对象中没有找到数据</span></div><div class="line">            <span class="comment">// 则先从模型中获取数据</span></div><div class="line">            <span class="keyword">var</span> val = <span class="keyword">this</span>.get(attr);</div><div class="line">            <span class="comment">// 将数据中的HTML使用 _.escape方法转换为实体, 并缓存到_escapedAttributes对象, 便于下次直接获取</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._escapedAttributes[attr] = _.escape(val == <span class="literal">null</span> ? <span class="string">''</span> : <span class="string">''</span> + val);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 检查模型中是否存在某个属性, 当该属性的值被转换为Boolean类型后值为false, 则认为不存在</span></div><div class="line">        <span class="comment">// 如果值为false, null, undefined, 0, NaN, 或空字符串时, 均会被转换为false</span></div><div class="line">        has : <span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.get(attr) != <span class="literal">null</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 设置模型中的数据, 如果key值不存在, 则作为新的属性添加到模型, 如果key值已经存在, 则修改为新的值</span></div><div class="line">        set : <span class="function"><span class="keyword">function</span>(<span class="params">key, value, options</span>) </span>&#123;</div><div class="line">            <span class="comment">// attrs变量中记录需要设置的数据对象</span></div><div class="line">            <span class="keyword">var</span> attrs, attr, val;</div><div class="line"> </div><div class="line">            <span class="comment">// 参数形式允许key-value对象形式, 或通过key, value两个参数进行单独设置</span></div><div class="line">            <span class="comment">// 如果key是一个对象, 则认定为使用对象形式设置, 第二个参数将被视为options参数</span></div><div class="line">            <span class="keyword">if</span>(_.isObject(key) || key == <span class="literal">null</span>) &#123;</div><div class="line">                attrs = key;</div><div class="line">                options = value;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 通过key, value两个参数单独设置, 将数据放到attrs对象中方便统一处理</span></div><div class="line">                attrs = &#123;&#125;;</div><div class="line">                attrs[key] = value;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">// options配置项必须是一个对象, 如果没有设置options则默认值为一个空对象</span></div><div class="line">            options || ( options = &#123;&#125;);</div><div class="line">            <span class="comment">// 没有设置参数时不执行任何动作</span></div><div class="line">            <span class="keyword">if</span>(!attrs)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">            <span class="comment">// 如果被设置的数据对象属于Model类的一个实例, 则将Model对象的attributes数据对象赋给attrs</span></div><div class="line">            <span class="comment">// 一般在复制一个Model对象的数据到另一个Model对象时, 会执行该动作</span></div><div class="line">            <span class="keyword">if</span>( attrs <span class="keyword">instanceof</span> Model)</div><div class="line">                attrs = attrs.attributes;</div><div class="line">            <span class="comment">// 如果options配置对象中设置了unset属性, 则将attrs数据对象中的所有属性重置为undefined</span></div><div class="line">            <span class="comment">// 一般在复制一个Model对象的数据到另一个Model对象时, 但仅仅需要复制Model中的数据而不需要复制值时执行该操作</span></div><div class="line">            <span class="keyword">if</span>(options.unset)</div><div class="line">                <span class="keyword">for</span>(attr <span class="keyword">in</span> attrs)</div><div class="line">                attrs[attr] =</div><div class="line">                <span class="keyword">void</span> <span class="number">0</span>;</div><div class="line"> </div><div class="line">            <span class="comment">// 对当前数据进行验证, 如果验证未通过则停止执行</span></div><div class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>._validate(attrs, options))</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"> </div><div class="line">            <span class="comment">// 如果设置的id属性名被包含在数据集合中, 则将id覆盖到模型的id属性</span></div><div class="line">            <span class="comment">// 这是为了确保在自定义id属性名后, 访问模型的id属性时, 也能正确访问到id</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.idAttribute <span class="keyword">in</span> attrs)</div><div class="line">                <span class="keyword">this</span>.id = attrs[<span class="keyword">this</span>.idAttribute];</div><div class="line"> </div><div class="line">            <span class="keyword">var</span> changes = options.changes = &#123;&#125;;</div><div class="line">            <span class="comment">// now记录当前模型中的数据对象</span></div><div class="line">            <span class="keyword">var</span> now = <span class="keyword">this</span>.attributes;</div><div class="line">            <span class="comment">// escaped记录当前模型中通过escape缓存过的数据</span></div><div class="line">            <span class="keyword">var</span> escaped = <span class="keyword">this</span>._escapedAttributes;</div><div class="line">            <span class="comment">// prev记录模型中数据被改变之前的值</span></div><div class="line">            <span class="keyword">var</span> prev = <span class="keyword">this</span>._previousAttributes || &#123;&#125;;</div><div class="line"> </div><div class="line">            <span class="comment">// 遍历需要设置的数据对象</span></div><div class="line">            <span class="keyword">for</span>(attr <span class="keyword">in</span> attrs) &#123;</div><div class="line">                <span class="comment">// attr存储当前属性名称, val存储当前属性的值</span></div><div class="line">                val = attrs[attr];</div><div class="line"> </div><div class="line">                <span class="comment">// 如果当前数据在模型中不存在, 或已经发生变化, 或在options中指定了unset属性删除, 则删除该数据被换存在_escapedAttributes中的数据</span></div><div class="line">                <span class="keyword">if</span>(!_.isEqual(now[attr], val) || (options.unset &amp;&amp; _.has(now, attr))) &#123;</div><div class="line">                    <span class="comment">// 仅删除通过escape缓存过的数据, 这是为了保证缓存中的数据与模型中的真实数据保持同步</span></div><div class="line">                    <span class="keyword">delete</span> escaped[attr];</div><div class="line">                    <span class="comment">// 如果指定了silent属性, 则此次set方法调用不会触发change事件, 因此将被改变的数据记录到_silent属性中, 便于下一次触发change事件时, 通知事件监听函数此数据已经改变</span></div><div class="line">                    <span class="comment">// 如果没有指定silent属性, 则直接设置changes属性中当前数据为已改变状态</span></div><div class="line">                    (options.silent ? <span class="keyword">this</span>._silent : changes)[attr] = <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line"> </div><div class="line">                <span class="comment">// 如果在options中设置了unset, 则从模型中删除该数据(包括key)</span></div><div class="line">                <span class="comment">// 如果没有指定unset属性, 则认为将新增或修改数据, 向模型的数据对象中加入新的数据</span></div><div class="line">                options.unset ?</div><div class="line">                <span class="keyword">delete</span> now[attr] : now[attr] = val;</div><div class="line"> </div><div class="line">                <span class="comment">// 如果模型中的数据与新的数据不一致, 则表示该数据已发生变化</span></div><div class="line">                <span class="keyword">if</span>(!_.isEqual(prev[attr], val) || (_.has(now, attr) != _.has(prev, attr))) &#123;</div><div class="line">                    <span class="comment">// 在changed属性中记录当前属性已经发生变化的状态</span></div><div class="line">                    <span class="keyword">this</span>.changed[attr] = val;</div><div class="line">                    <span class="keyword">if</span>(!options.silent)</div><div class="line">                        <span class="keyword">this</span>._pending[attr] = <span class="literal">true</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 如果数据没有发生变化, 则从changed属性中移除已变化状态</span></div><div class="line">                    <span class="keyword">delete</span> <span class="keyword">this</span>.changed[attr];</div><div class="line">                    <span class="keyword">delete</span> <span class="keyword">this</span>._pending[attr];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">// 调用change方法, 将触发change事件绑定的函数</span></div><div class="line">            <span class="keyword">if</span>(!options.silent)</div><div class="line">                <span class="keyword">this</span>.change(options);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 从当前模型中删除指定的数据(属性也将被同时删除)</span></div><div class="line">        unset : <span class="function"><span class="keyword">function</span>(<span class="params">attr, options</span>) </span>&#123;</div><div class="line">            (options || ( options = &#123;&#125;)).unset = <span class="literal">true</span>;</div><div class="line">            <span class="comment">// 通过options.unset配置项告知set方法进行删除操作</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.set(attr, <span class="literal">null</span>, options);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 清除当前模型中的所有数据和属性</span></div><div class="line">        clear : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">            (options || ( options = &#123;&#125;)).unset = <span class="literal">true</span>;</div><div class="line">            <span class="comment">// 克隆一个当前模型的属性副本, 并通过options.unset配置项告知set方法执行删除操作</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.set(_.clone(<span class="keyword">this</span>.attributes), options);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 从服务器获取默认的模型数据, 获取数据后使用set方法将数据填充到模型, 因此如果获取到的数据与当前模型中的数据不一致, 将会触发change事件</span></div><div class="line">        fetch : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 确保options是一个新的对象, 随后将改变options中的属性</span></div><div class="line">            options = options ? _.clone(options) : &#123;&#125;;</div><div class="line">            <span class="keyword">var</span> model = <span class="keyword">this</span>;</div><div class="line">            <span class="comment">// 在options中可以指定获取数据成功后的自定义回调函数</span></div><div class="line">            <span class="keyword">var</span> success = options.success;</div><div class="line">            <span class="comment">// 当获取数据成功后填充数据并调用自定义成功回调函数</span></div><div class="line">            options.success = <span class="function"><span class="keyword">function</span>(<span class="params">resp, status, xhr</span>) </span>&#123;</div><div class="line">                <span class="comment">// 通过parse方法将服务器返回的数据进行转换</span></div><div class="line">                <span class="comment">// 通过set方法将转换后的数据填充到模型中, 因此可能会触发change事件(当数据发生变化时)</span></div><div class="line">                <span class="comment">// 如果填充数据时验证失败, 则不会调用自定义success回调函数</span></div><div class="line">                <span class="keyword">if</span>(!model.set(model.parse(resp, xhr), options))</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                <span class="comment">// 调用自定义的success回调函数</span></div><div class="line">                <span class="keyword">if</span>(success)</div><div class="line">                    success(model, resp);</div><div class="line">            &#125;;</div><div class="line">            <span class="comment">// 请求发生错误时通过wrapError处理error事件</span></div><div class="line">            options.error = Backbone.wrapError(options.error, model, options);</div><div class="line">            <span class="comment">// 调用sync方法从服务器获取数据</span></div><div class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>.sync || Backbone.sync).call(<span class="keyword">this</span>, <span class="string">'read'</span>, <span class="keyword">this</span>, options);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 保存模型中的数据到服务器</span></div><div class="line">        save : <span class="function"><span class="keyword">function</span>(<span class="params">key, value, options</span>) </span>&#123;</div><div class="line">            <span class="comment">// attrs存储需要保存到服务器的数据对象</span></div><div class="line">            <span class="keyword">var</span> attrs, current;</div><div class="line"> </div><div class="line">            <span class="comment">// 支持设置单个属性的方式 key: value</span></div><div class="line">            <span class="comment">// 支持对象形式的批量设置方式 &#123;key: value&#125;</span></div><div class="line">            <span class="keyword">if</span>(_.isObject(key) || key == <span class="literal">null</span>) &#123;</div><div class="line">                <span class="comment">// 如果key是一个对象, 则认为是通过对象方式设置</span></div><div class="line">                <span class="comment">// 此时第二个参数被认为是options</span></div><div class="line">                attrs = key;</div><div class="line">                options = value;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 如果是通过key: value形式设置单个属性, 则直接设置attrs</span></div><div class="line">                attrs = &#123;&#125;;</div><div class="line">                attrs[key] = value;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 配置对象必须是一个新的对象</span></div><div class="line">            options = options ? _.clone(options) : &#123;&#125;;</div><div class="line"> </div><div class="line">            <span class="comment">// 如果在options中设置了wait选项, 则被改变的数据将会被提前验证, 且服务器没有响应新数据(或响应失败)时, 本地数据会被还原为修改前的状态</span></div><div class="line">            <span class="comment">// 如果没有设置wait选项, 则无论服务器是否设置成功, 本地数据均会被修改为最新状态</span></div><div class="line">            <span class="keyword">if</span>(options.wait) &#123;</div><div class="line">                <span class="comment">// 对需要保存的数据提前进行验证</span></div><div class="line">                <span class="keyword">if</span>(!<span class="keyword">this</span>._validate(attrs, options))</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                <span class="comment">// 记录当前模型中的数据, 用于在将数据发送到服务器后, 将数据进行还原</span></div><div class="line">                <span class="comment">// 如果服务器响应失败或没有返回数据, 则可以保持修改前的状态</span></div><div class="line">                current = _.clone(<span class="keyword">this</span>.attributes);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">// silentOptions在options对象中加入了silent(不对数据进行验证)</span></div><div class="line">            <span class="comment">// 当使用wait参数时使用silentOptions配置项, 因为在上面已经对数据进行过验证</span></div><div class="line">            <span class="comment">// 如果没有设置wait参数, 则仍然使用原始的options配置项</span></div><div class="line">            <span class="keyword">var</span> silentOptions = _.extend(&#123;&#125;, options, &#123;</div><div class="line">                <span class="attr">silent</span> : <span class="literal">true</span></div><div class="line">            &#125;);</div><div class="line">            <span class="comment">// 将修改过最新的数据保存到模型中, 便于在sync方法中获取模型数据保存到服务器</span></div><div class="line">            <span class="keyword">if</span>(attrs &amp;&amp; !<span class="keyword">this</span>.set(attrs, options.wait ? silentOptions : options)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="keyword">var</span> model = <span class="keyword">this</span>;</div><div class="line">            <span class="comment">// 在options中可以指定保存数据成功后的自定义回调函数</span></div><div class="line">            <span class="keyword">var</span> success = options.success;</div><div class="line">            <span class="comment">// 服务器响应成功后执行success</span></div><div class="line">            options.success = <span class="function"><span class="keyword">function</span>(<span class="params">resp, status, xhr</span>) </span>&#123;</div><div class="line">                <span class="comment">// 获取服务器响应最新状态的数据</span></div><div class="line">                <span class="keyword">var</span> serverAttrs = model.parse(resp, xhr);</div><div class="line">                <span class="comment">// 如果使用了wait参数, 则优先将修改后的数据状态直接设置到模型</span></div><div class="line">                <span class="keyword">if</span>(options.wait) &#123;</div><div class="line">                    <span class="keyword">delete</span> options.wait;</div><div class="line">                    serverAttrs = _.extend(attrs || &#123;&#125;, serverAttrs);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 将最新的数据状态设置到模型中</span></div><div class="line">                <span class="comment">// 如果调用set方法时验证失败, 则不会调用自定义的success回调函数</span></div><div class="line">                <span class="keyword">if</span>(!model.set(serverAttrs, options))</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                <span class="keyword">if</span>(success) &#123;</div><div class="line">                    <span class="comment">// 调用响应成功后自定义的success回调函数</span></div><div class="line">                    success(model, resp);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 如果没有指定自定义回调, 则默认触发sync事件</span></div><div class="line">                    model.trigger(<span class="string">'sync'</span>, model, resp, options);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            <span class="comment">// 请求发生错误时通过wrapError处理error事件</span></div><div class="line">            options.error = Backbone.wrapError(options.error, model, options);</div><div class="line">            <span class="comment">// 将模型中的数据保存到服务器</span></div><div class="line">            <span class="comment">// 如果当前模型是一个新建的模型(没有id), 则使用create方法(新增), 否则认为是update方法(修改)</span></div><div class="line">            <span class="keyword">var</span> method = <span class="keyword">this</span>.isNew() ? <span class="string">'create'</span> : <span class="string">'update'</span>;</div><div class="line">            <span class="keyword">var</span> xhr = (<span class="keyword">this</span>.sync || Backbone.sync).call(<span class="keyword">this</span>, method, <span class="keyword">this</span>, options);</div><div class="line">            <span class="comment">// 如果设置了options.wait, 则将数据还原为修改前的状态</span></div><div class="line">            <span class="comment">// 此时保存的请求还没有得到响应, 因此如果响应失败, 模型中将保持修改前的状态, 如果服务器响应成功, 则会在success中设置模型中的数据为最新状态</span></div><div class="line">            <span class="keyword">if</span>(options.wait)</div><div class="line">                <span class="keyword">this</span>.set(current, silentOptions);</div><div class="line">            <span class="keyword">return</span> xhr;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 删除模型, 模型将同时从所属的Collection集合中被删除</span></div><div class="line">        <span class="comment">// 如果模型是在客户端新建的, 则直接从客户端删除</span></div><div class="line">        <span class="comment">// 如果模型数据同时存在服务器, 则同时会删除服务器端的数据</span></div><div class="line">        destroy : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 配置项必须是一个新的对象</span></div><div class="line">            options = options ? _.clone(options) : &#123;&#125;;</div><div class="line">            <span class="keyword">var</span> model = <span class="keyword">this</span>;</div><div class="line">            <span class="comment">// 在options中可以指定删除数据成功后的自定义回调函数</span></div><div class="line">            <span class="keyword">var</span> success = options.success;</div><div class="line">            <span class="comment">// 删除数据成功调用, 触发destroy事件, 如果模型存在于Collection集合中, 集合将监听destroy事件并在触发时从集合中移除该模型</span></div><div class="line">            <span class="comment">// 删除模型时, 模型中的数据并没有被清空, 但模型已经从集合中移除, 因此当没有任何地方引用该模型时, 会被自动从内存中释放</span></div><div class="line">            <span class="comment">// 建议在删除模型时, 将模型对象的引用变量设置为null</span></div><div class="line">            <span class="keyword">var</span> triggerDestroy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                model.trigger(<span class="string">'destroy'</span>, model, model.collection, options);</div><div class="line">            &#125;;</div><div class="line">            <span class="comment">// 如果该模型是一个客户端新建的模型, 则直接调用triggerDestroy从集合中将模型移除</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isNew()) &#123;</div><div class="line">                triggerDestroy();</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">// 当从服务器删除数据成功时</span></div><div class="line">            options.success = <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</div><div class="line">                <span class="comment">// 如果在options对象中配置wait项, 则表示本地内存中的模型数据, 会在服务器数据被删除成功后再删除</span></div><div class="line">                <span class="comment">// 如果服务器响应失败, 则本地数据不会被删除</span></div><div class="line">                <span class="keyword">if</span>(options.wait)</div><div class="line">                    triggerDestroy();</div><div class="line">                <span class="keyword">if</span>(success) &#123;</div><div class="line">                    <span class="comment">// 调用自定义的成功回调函数</span></div><div class="line">                    success(model, resp);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 如果没有自定义回调, 则默认触发sync事件</span></div><div class="line">                    model.trigger(<span class="string">'sync'</span>, model, resp, options);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            <span class="comment">// 请求发生错误时通过wrapError处理error事件</span></div><div class="line">            options.error = Backbone.wrapError(options.error, model, options);</div><div class="line">            <span class="comment">// 通过sync方法发送删除数据的请求</span></div><div class="line">            <span class="keyword">var</span> xhr = (<span class="keyword">this</span>.sync || Backbone.sync).call(<span class="keyword">this</span>, <span class="string">'delete'</span>, <span class="keyword">this</span>, options);</div><div class="line">            <span class="comment">// 如果没有在options对象中配置wait项, 则会先删除本地数据, 再发送请求删除服务器数据</span></div><div class="line">            <span class="comment">// 此时无论服务器删除是否成功, 本地模型数据已被删除</span></div><div class="line">            <span class="keyword">if</span>(!options.wait)</div><div class="line">                triggerDestroy();</div><div class="line">            <span class="keyword">return</span> xhr;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 获取模型在服务器接口中对应的url, 在调用save, fetch, destroy等与服务器交互的方法时, 将使用该方法获取url</span></div><div class="line">        <span class="comment">// 生成的url类似于"PATHINFO"模式, 服务器对模型的操作只有一个url, 对于修改和删除操作会在url后追加模型id便于标识</span></div><div class="line">        <span class="comment">// 如果在模型中定义了urlRoot, 服务器接口应为[urlRoot/id]形式</span></div><div class="line">        <span class="comment">// 如果模型所属的Collection集合定义了url方法或属性, 则使用集合中的url形式: [collection.url/id]</span></div><div class="line">        <span class="comment">// 在访问服务器url时会在url后面追加上模型的id, 便于服务器标识一条记录, 因此模型中的id需要与服务器记录对应</span></div><div class="line">        <span class="comment">// 如果无法获取模型或集合的url, 将调用urlError方法抛出一个异常</span></div><div class="line">        <span class="comment">// 如果服务器接口并没有按照"PATHINFO"方式进行组织, 可以通过重载url方法实现与服务器的无缝交互</span></div><div class="line">        url : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 定义服务器对应的url路径</span></div><div class="line">            <span class="keyword">var</span> base = getValue(<span class="keyword">this</span>, <span class="string">'urlRoot'</span>) || getValue(<span class="keyword">this</span>.collection, <span class="string">'url'</span>) || urlError();</div><div class="line">            <span class="comment">// 如果当前模型是客户端新建的模型, 则不存在id属性, 服务器url直接使用base</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isNew())</div><div class="line">                <span class="keyword">return</span> base;</div><div class="line">            <span class="comment">// 如果当前模型具有id属性, 可能是调用了save或destroy方法, 将在base后面追加模型的id</span></div><div class="line">            <span class="comment">// 下面将判断base最后一个字符是否是"/", 生成的url格式为[base/id]</span></div><div class="line">            <span class="keyword">return</span> base + (base.charAt(base.length - <span class="number">1</span>) == <span class="string">'/'</span> ? <span class="string">''</span> : <span class="string">'/'</span>) + <span class="built_in">encodeURIComponent</span>(<span class="keyword">this</span>.id);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// parse方法用于解析从服务器获取的数据, 返回一个能够被set方法解析的模型数据</span></div><div class="line">        <span class="comment">// 一般parse方法会根据服务器返回的数据进行重载, 以便构建与服务器的无缝连接</span></div><div class="line">        <span class="comment">// 当服务器返回的数据结构与set方法所需的数据结构不一致(例如服务器返回XML格式数据时), 可使用parse方法进行转换</span></div><div class="line">        parse : <span class="function"><span class="keyword">function</span>(<span class="params">resp, xhr</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> resp;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 创建一个新的模型, 它具有和当前模型相同的数据</span></div><div class="line">        clone : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="keyword">this</span>.attributes);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 检查当前模型是否是客户端创建的新模型</span></div><div class="line">        <span class="comment">// 检查方式是根据模型是否存在id标识, 客户端创建的新模型没有id标识</span></div><div class="line">        <span class="comment">// 因此服务器响应的模型数据中必须包含id标识, 标识的属性名默认为"id", 也可以通过修改idAttribute属性自定义标识</span></div><div class="line">        isNew : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.id == <span class="literal">null</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 数据被更新时触发change事件绑定的函数</span></div><div class="line">        <span class="comment">// 当set方法被调用, 会自动调用change方法, 如果在set方法被调用时指定了silent配置, 则需要手动调用change方法</span></div><div class="line">        change : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">            <span class="comment">// options必须是一个对象</span></div><div class="line">            options || ( options = &#123;&#125;);</div><div class="line">            <span class="comment">// this._changing相关的逻辑有些问题</span></div><div class="line">            <span class="comment">// this._changing在方法最后被设置为false, 因此方法上面changing变量的值始终为false(第一次为undefined)</span></div><div class="line">            <span class="comment">// 作者的初衷应该是想用该变量标示change方法是否执行完毕, 对于浏览器端单线程的脚本来说没有意义, 因为该方法被执行时会阻塞其它脚本</span></div><div class="line">            <span class="comment">// changing获取上一次执行的状态, 如果上一次脚本没有执行完毕, 则值为true</span></div><div class="line">            <span class="keyword">var</span> changing = <span class="keyword">this</span>._changing;</div><div class="line">            <span class="comment">// 开始执行标识, 执行过程中值始终为true, 执行完毕后this._changing被修改为false</span></div><div class="line">            <span class="keyword">this</span>._changing = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">            <span class="comment">// 将非本次改变的数据状态添加到_pending对象中</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> <span class="keyword">this</span>._silent)</div><div class="line">            <span class="keyword">this</span>._pending[attr] = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">            <span class="comment">// changes对象包含了当前数据上一次执行change事件至今, 已被改变的所有数据</span></div><div class="line">            <span class="comment">// 如果之前使用silent未触发change事件, 则本次会被放到changes对象中</span></div><div class="line">            <span class="keyword">var</span> changes = _.extend(&#123;&#125;, options.changes, <span class="keyword">this</span>._silent);</div><div class="line">            <span class="comment">// 重置_silent对象</span></div><div class="line">            <span class="keyword">this</span>._silent = &#123;&#125;;</div><div class="line">            <span class="comment">// 遍历changes对象, 分别针对每一个属性触发单独的change事件</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> changes) &#123;</div><div class="line">                <span class="comment">// 将Model对象, 属性值, 配置项作为参数以此传递给事件的监听函数</span></div><div class="line">                <span class="keyword">this</span>.trigger(<span class="string">'change:'</span> + attr, <span class="keyword">this</span>, <span class="keyword">this</span>.get(attr), options);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">// 如果方法处于执行中, 则停止执行</span></div><div class="line">            <span class="keyword">if</span>(changing)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line"> </div><div class="line">            <span class="comment">// 触发change事件, 任意数据被改变后, 都会依次触发"change:属性"事件和"change"事件</span></div><div class="line">            <span class="keyword">while</span>(!_.isEmpty(<span class="keyword">this</span>._pending)) &#123;</div><div class="line">                <span class="keyword">this</span>._pending = &#123;&#125;;</div><div class="line">                <span class="comment">// 触发change事件, 并将Model实例和配置项作为参数传递给监听函数</span></div><div class="line">                <span class="keyword">this</span>.trigger(<span class="string">'change'</span>, <span class="keyword">this</span>, options);</div><div class="line">                <span class="comment">// 遍历changed对象中的数据, 并依次将已改变数据的状态从changed中移除</span></div><div class="line">                <span class="comment">// 在此之后如果调用hasChanged检查数据状态, 将得到false(未改变)</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> <span class="keyword">this</span>.changed) &#123;</div><div class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>._pending[attr] || <span class="keyword">this</span>._silent[attr])</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    <span class="comment">// 移除changed中数据的状态</span></div><div class="line">                    <span class="keyword">delete</span> <span class="keyword">this</span>.changed[attr];</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// change事件执行完毕, _previousAttributes属性将记录当前模型最新的数据副本</span></div><div class="line">                <span class="comment">// 因此如果需要获取数据的上一个状态, 一般只通过在触发的change事件中通过previous或previousAttributes方法获取</span></div><div class="line">                <span class="keyword">this</span>._previousAttributes = _.clone(<span class="keyword">this</span>.attributes);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">// 执行完毕标识</span></div><div class="line">            <span class="keyword">this</span>._changing = <span class="literal">false</span>;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 检查某个数据是否在上一次执行change事件后被改变过</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 一般在change事件中配合previous或previousAttributes方法使用, 如:</div><div class="line">         * if(model.hasChanged('attr')) &#123;</div><div class="line">         *     var attrPrev = model.previous('attr');</div><div class="line">         * &#125;</div><div class="line">         */</div><div class="line">        hasChanged : <span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span>(!<span class="built_in">arguments</span>.length)</div><div class="line">                <span class="keyword">return</span> !_.isEmpty(<span class="keyword">this</span>.changed);</div><div class="line">            <span class="keyword">return</span> _.has(<span class="keyword">this</span>.changed, attr);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 获取当前模型中的数据与上一次数据中已经发生变化的数据集合</span></div><div class="line">        <span class="comment">// (一般在使用silent属性时没有调用change方法, 因此数据会被临时抱存在changed属性中, 上一次的数据可通过previousAttributes方法获取)</span></div><div class="line">        <span class="comment">// 如果传递了diff集合, 将使用上一次模型数据与diff集合中的数据进行比较, 返回不一致的数据集合</span></div><div class="line">        <span class="comment">// 如果比较结果中没有差异, 则返回false</span></div><div class="line">        changedAttributes : <span class="function"><span class="keyword">function</span>(<span class="params">diff</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果没有指定diff, 将返回当前模型较上一次状态已改变的数据集合, 这些数据已经被存在changed属性中, 因此返回changed集合的一个副本</span></div><div class="line">            <span class="keyword">if</span>(!diff)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.hasChanged() ? _.clone(<span class="keyword">this</span>.changed) : <span class="literal">false</span>;</div><div class="line">            <span class="comment">// 指定了需要进行比较的diff集合, 将返回上一次的数据与diff集合的比较结果</span></div><div class="line">            <span class="comment">// old变量存储了上一个状态的模型数据</span></div><div class="line">            <span class="keyword">var</span> val, changed = <span class="literal">false</span>, old = <span class="keyword">this</span>._previousAttributes;</div><div class="line">            <span class="comment">// 遍历diff集合, 并将每一项与上一个状态的集合进行比较</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> diff) &#123;</div><div class="line">                <span class="comment">// 将比较结果不一致的数据临时存储到changed变量</span></div><div class="line">                <span class="keyword">if</span>(_.isEqual(old[attr], ( val = diff[attr])))</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                (changed || (changed = &#123;&#125;))[attr] = val;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 返回比较结果</span></div><div class="line">            <span class="keyword">return</span> changed;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 在模型触发的change事件中, 获取某个属性被改变前上一个状态的数据, 一般用于进行数据比较或回滚</span></div><div class="line">        <span class="comment">// 该方法一般在change事件中调用, change事件被触发后, _previousAttributes属性存放最新的数据</span></div><div class="line">        previous : <span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</div><div class="line">            <span class="comment">// attr指定需要获取上一个状态的属性名称</span></div><div class="line">            <span class="keyword">if</span>(!<span class="built_in">arguments</span>.length || !<span class="keyword">this</span>._previousAttributes)</div><div class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._previousAttributes[attr];</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 在模型触发change事件中, 获取所有属性上一个状态的数据集合</span></div><div class="line">        <span class="comment">// 该方法类似于previous()方法, 一般在change事件中调用, 用于数据比较或回滚</span></div><div class="line">        previousAttributes : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 将上一个状态的数据对象克隆为一个新对象并返回</span></div><div class="line">            <span class="keyword">return</span> _.clone(<span class="keyword">this</span>._previousAttributes);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// Check if the model is currently in a valid state. It's only possible to</span></div><div class="line">        <span class="comment">// get into an *invalid* state if you're using silent changes.</span></div><div class="line">        <span class="comment">// 验证当前模型中的数据是否能通过validate方法验证, 调用前请确保定义了validate方法</span></div><div class="line">        isValid : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> !<span class="keyword">this</span>.validate(<span class="keyword">this</span>.attributes);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 数据验证方法, 在调用set, save, add等数据更新方法时, 被自动执行</span></div><div class="line">        <span class="comment">// 验证失败会触发模型对象的"error"事件, 如果在options中指定了error处理函数, 则只会执行options.error函数</span></div><div class="line">        <span class="comment">// @param &#123;Object&#125; attrs 数据模型的attributes属性, 存储模型的对象化数据</span></div><div class="line">        <span class="comment">// @param &#123;Object&#125; options 配置项</span></div><div class="line">        <span class="comment">// @return &#123;Boolean&#125; 验证通过返回true, 不通过返回false</span></div><div class="line">        _validate : <span class="function"><span class="keyword">function</span>(<span class="params">attrs, options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果在调用set, save, add等数据更新方法时设置了options.silent属性, 则忽略验证</span></div><div class="line">            <span class="comment">// 如果Model中没有添加validate方法, 则忽略验证</span></div><div class="line">            <span class="keyword">if</span>(options.silent || !<span class="keyword">this</span>.validate)</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="comment">// 获取对象中所有的属性值, 并放入validate方法中进行验证</span></div><div class="line">            <span class="comment">// validate方法包含2个参数, 分别为模型中的数据集合与配置对象, 如果验证通过则不返回任何数据(默认为undefined), 验证失败则返回带有错误信息数据</span></div><div class="line">            attrs = _.extend(&#123;&#125;, <span class="keyword">this</span>.attributes, attrs);</div><div class="line">            <span class="keyword">var</span> error = <span class="keyword">this</span>.validate(attrs, options);</div><div class="line">            <span class="comment">// 验证通过</span></div><div class="line">            <span class="keyword">if</span>(!error)</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="comment">// 验证未通过</span></div><div class="line">            <span class="comment">// 如果配置对象中设置了error错误处理方法, 则调用该方法并将错误数据和配置对象传递给该方法</span></div><div class="line">            <span class="keyword">if</span>(options &amp;&amp; options.error) &#123;</div><div class="line">                options.error(<span class="keyword">this</span>, error, options);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 如果对模型绑定了error事件监听, 则触发绑定事件</span></div><div class="line">                <span class="keyword">this</span>.trigger(<span class="string">'error'</span>, <span class="keyword">this</span>, error, options);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 返回验证未通过标识</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    <span class="comment">// Backbone.Collection 数据模型集合相关</span></div><div class="line">    <span class="comment">// -------------------</span></div><div class="line"> </div><div class="line">    <span class="comment">// Collection集合存储一系列相同类的数据模型, 并提供相关方法对模型进行操作</span></div><div class="line">    <span class="keyword">var</span> Collection = Backbone.Collection = <span class="function"><span class="keyword">function</span>(<span class="params">models, options</span>) </span>&#123;</div><div class="line">        <span class="comment">// 配置对象</span></div><div class="line">        options || ( options = &#123;&#125;);</div><div class="line">        <span class="comment">// 在配置参数中设置集合的模型类</span></div><div class="line">        <span class="keyword">if</span>(options.model)</div><div class="line">            <span class="keyword">this</span>.model = options.model;</div><div class="line">        <span class="comment">// 如果设置了comparator属性, 则集合中的数据将按照comparator方法中的排序算法进行排序(在add方法中会自动调用)</span></div><div class="line">        <span class="keyword">if</span>(options.comparator)</div><div class="line">            <span class="keyword">this</span>.comparator = options.comparator;</div><div class="line">        <span class="comment">// 实例化时重置集合的内部状态(第一次调用时可理解为定义状态)</span></div><div class="line">        <span class="keyword">this</span>._reset();</div><div class="line">        <span class="comment">// 调用自定义初始化方法, 如果需要一般会重载initialize方法</span></div><div class="line">        <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">        <span class="comment">// 如果指定了models数据, 则调用reset方法将数据添加到集合中</span></div><div class="line">        <span class="comment">// 首次调用时设置了silent参数, 因此不会触发"reset"事件</span></div><div class="line">        <span class="keyword">if</span>(models)</div><div class="line">            <span class="keyword">this</span>.reset(models, &#123;</div><div class="line">                <span class="attr">silent</span> : <span class="literal">true</span>,</div><div class="line">                <span class="attr">parse</span> : options.parse</div><div class="line">            &#125;);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 通过extend方法定义集合类原型方法</span></div><div class="line">    _.extend(Collection.prototype, Events, &#123;</div><div class="line"> </div><div class="line">        <span class="comment">// 定义集合的模型类, 模型类必须是一个Backbone.Model的子类</span></div><div class="line">        <span class="comment">// 在使用集合相关方法(如add, create等)时, 允许传入数据对象, 集合方法会根据定义的模型类自动创建对应的实例</span></div><div class="line">        <span class="comment">// 集合中存储的数据模型应该都是同一个模型类的实例</span></div><div class="line">        model : Model,</div><div class="line"> </div><div class="line">        <span class="comment">// 初始化方法, 该方法在集合实例被创建后自动调用</span></div><div class="line">        <span class="comment">// 一般会在定义集合类时重载该方法</span></div><div class="line">        initialize : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 返回一个数组, 包含了集合中每个模型的数据对象</span></div><div class="line">        toJSON : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 通过Undersocre的map方法将集合中每一个模型的toJSON结果组成一个数组, 并返回</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.map(<span class="function"><span class="keyword">function</span>(<span class="params">model</span>) </span>&#123;</div><div class="line">                <span class="comment">// 依次调用每个模型对象的toJSON方法, 该方法默认将返回模型的数据对象(复制的副本)</span></div><div class="line">                <span class="comment">// 如果需要返回字符串等其它形式, 可以重载toJSON方法</span></div><div class="line">                <span class="keyword">return</span> model.toJSON(options);</div><div class="line">            &#125;);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 向集合中添加一个或多个模型对象</span></div><div class="line">        <span class="comment">// 默认会触发"add"事件, 如果在options中设置了silent属性, 可以关闭此次事件触发</span></div><div class="line">        <span class="comment">// 传入的models可以是一个或一系列的模型对象(Model类的实例), 如果在集合中设置了model属性, 则允许直接传入数据对象(如 &#123;name: 'test'&#125;), 将自动将数据对象实例化为model指向的模型对象</span></div><div class="line">        add : <span class="function"><span class="keyword">function</span>(<span class="params">models, options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 局部变量定义</span></div><div class="line">            <span class="keyword">var</span> i, index, length, model, cid, id, cids = &#123;&#125;, ids = &#123;&#125;, dups = [];</div><div class="line">            options || ( options = &#123;&#125;);</div><div class="line">            <span class="comment">// models必须是一个数组, 如果只传入了一个模型, 则将其转换为数组</span></div><div class="line">            models = _.isArray(models) ? models.slice() : [models];</div><div class="line"> </div><div class="line">            <span class="comment">// 遍历需要添加的模型列表, 遍历过程中, 将执行以下操作:</span></div><div class="line">            <span class="comment">// - 将数据对象转化模型对象</span></div><div class="line">            <span class="comment">// - 建立模型与集合之间的引用</span></div><div class="line">            <span class="comment">// - 记录无效和重复的模型, 并在后面进行过滤</span></div><div class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>, length = models.length; i &lt; length; i++) &#123;</div><div class="line">                <span class="comment">// 将数据对象转换为模型对象, 简历模型与集合的引用, 并存储到model(同时models中对应的模型已经被替换为模型对象)</span></div><div class="line">                <span class="keyword">if</span>(!( model = models[i] = <span class="keyword">this</span>._prepareModel(models[i], options))) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Can't add an invalid model to a collection"</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 当前模型的cid和id</span></div><div class="line">                cid = model.cid;</div><div class="line">                id = model.id;</div><div class="line">                <span class="comment">// dups数组中记录了无效或重复的模型索引(models数组中的索引), 并在下一步进行过滤删除</span></div><div class="line">                <span class="comment">// 如果cids, ids变量中已经存在了该模型的索引, 则认为是同一个模型在传入的models数组中声明了多次</span></div><div class="line">                <span class="comment">// 如果_byCid, _byId对象中已经存在了该模型的索引, 则认为同一个模型在当前集合中已经存在</span></div><div class="line">                <span class="comment">// 对于上述两种情况, 将模型的索引记录到dups进行过滤删除</span></div><div class="line">                <span class="keyword">if</span>(cids[cid] || <span class="keyword">this</span>._byCid[cid] || ((id != <span class="literal">null</span>) &amp;&amp; (ids[id] || <span class="keyword">this</span>._byId[id]))) &#123;</div><div class="line">                    dups.push(i);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 将models中已经遍历过的模型记录下来, 用于在下一次循环时进行重复检查</span></div><div class="line">                cids[cid] = ids[id] = model;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">// 从models中删除无效或重复的模型, 保留目前集合中真正需要添加的模型列表</span></div><div class="line">            i = dups.length;</div><div class="line">            <span class="keyword">while</span>(i--) &#123;</div><div class="line">                models.splice(dups[i], <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">// 遍历需要添加的模型, 监听模型事件并记录_byCid, _byId列表, 用于在调用get和getByCid方法时作为索引</span></div><div class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>, length = models.length; i &lt; length; i++) &#123;</div><div class="line">                <span class="comment">// 监听模型中的所有事件, 并执行_onModelEvent方法</span></div><div class="line">                <span class="comment">// _onModelEvent方法中会对模型抛出的add, remove, destroy和change事件进行处理, 以便模型与集合中的状态保持同步</span></div><div class="line">                ( model = models[i]).on(<span class="string">'all'</span>, <span class="keyword">this</span>._onModelEvent, <span class="keyword">this</span>);</div><div class="line">                <span class="comment">// 将模型根据cid记录到_byCid对象, 便于根据cid进行查找</span></div><div class="line">                <span class="keyword">this</span>._byCid[model.cid] = model;</div><div class="line">                <span class="comment">// 将模型根据id记录到_byId对象, 便于根据id进行查找</span></div><div class="line">                <span class="keyword">if</span>(model.id != <span class="literal">null</span>)</div><div class="line">                    <span class="keyword">this</span>._byId[model.id] = model;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">// 改变集合的length属性, length属性记录了当前集合中模型的数量</span></div><div class="line">            <span class="keyword">this</span>.length += length;</div><div class="line">            <span class="comment">// 设置新模型列表插入到集合中的位置, 如果在options中设置了at参数, 则在集合的at位置插入</span></div><div class="line">            <span class="comment">// 默认将插入到集合的末尾</span></div><div class="line">            <span class="comment">// 如果设置了comparator自定义排序方法, 则设置at后还将按照comparator中的方法进行排序, 因此最终的顺序可能并非在at指定的位置</span></div><div class="line">            index = options.at != <span class="literal">null</span> ? options.at : <span class="keyword">this</span>.models.length;</div><div class="line">            splice.apply(<span class="keyword">this</span>.models, [index, <span class="number">0</span>].concat(models));</div><div class="line">            <span class="comment">// 如果设置了comparator方法, 则将数据按照comparator中的算法进行排序</span></div><div class="line">            <span class="comment">// 自动排序使用silent属性阻止触发reset事件</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.comparator)</div><div class="line">                <span class="keyword">this</span>.sort(&#123;</div><div class="line">                    <span class="attr">silent</span> : <span class="literal">true</span></div><div class="line">                &#125;);</div><div class="line">            <span class="comment">// 依次对每个模型对象触发"add"事件, 如果设置了silent属性, 则阻止事件触发</span></div><div class="line">            <span class="keyword">if</span>(options.silent)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">            <span class="comment">// 遍历新增加的模型列表</span></div><div class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>, length = <span class="keyword">this</span>.models.length; i &lt; length; i++) &#123;</div><div class="line">                <span class="keyword">if</span>(!cids[( model = <span class="keyword">this</span>.models[i]).cid])</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                options.index = i;</div><div class="line">                <span class="comment">// 触发模型的"add"事件, 因为集合监听了模型的"all"事件, 因此在_onModelEvent方法中, 集合也将触发"add"事件</span></div><div class="line">                <span class="comment">// 详细信息可参考Collection.prototype._onModelEvent方法</span></div><div class="line">                model.trigger(<span class="string">'add'</span>, model, <span class="keyword">this</span>, options);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 从集合中移除模型对象(支持移除多个模型)</span></div><div class="line">        <span class="comment">// 传入的models可以是需要移除的模型对象, 或模型的cid和模型的id</span></div><div class="line">        <span class="comment">// 移除模型并不会调用模型的destroy方法</span></div><div class="line">        <span class="comment">// 如果没有设置options.silent参数, 将触发模型的remove事件, 同时将触发集合的remove事件(集合通过_onModelEvent方法监听了模型的所有事件)</span></div><div class="line">        remove : <span class="function"><span class="keyword">function</span>(<span class="params">models, options</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> i, l, index, model;</div><div class="line">            <span class="comment">// options默认为空对象</span></div><div class="line">            options || ( options = &#123;&#125;);</div><div class="line">            <span class="comment">// models必须是数组类型, 当只移除一个模型时, 将其放入一个数组</span></div><div class="line">            models = _.isArray(models) ? models.slice() : [models];</div><div class="line">            <span class="comment">// 遍历需要移除的模型列表</span></div><div class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>, l = models.length; i &lt; l; i++) &#123;</div><div class="line">                <span class="comment">// 所传入的models列表中可以是需要移除的模型对象, 或模型的cid和模型的id</span></div><div class="line">                <span class="comment">// (在getByCid和get方法中, 可通过cid, id来获取模型, 如果传入的是一个模型对象, 则返回模型本身)</span></div><div class="line">                model = <span class="keyword">this</span>.getByCid(models[i]) || <span class="keyword">this</span>.get(models[i]);</div><div class="line">                <span class="comment">// 没有获取到模型</span></div><div class="line">                <span class="keyword">if</span>(!model)</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                <span class="comment">// 从_byId列表中移除模型的id引用</span></div><div class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>._byId[model.id];</div><div class="line">                <span class="comment">// 从_byCid列表中移除模型的cid引用</span></div><div class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>._byCid[model.cid];</div><div class="line">                <span class="comment">// indexOf是Underscore对象中的方法, 这里通过indexOf方法获取模型在集合中首次出现的位置</span></div><div class="line">                index = <span class="keyword">this</span>.indexOf(model);</div><div class="line">                <span class="comment">// 从集合列表中移除该模型</span></div><div class="line">                <span class="keyword">this</span>.models.splice(index, <span class="number">1</span>);</div><div class="line">                <span class="comment">// 重置当前集合的length属性(记录集合中模型的数量)</span></div><div class="line">                <span class="keyword">this</span>.length--;</div><div class="line">                <span class="comment">// 如果没有设置silent属性, 则触发模型的remove事件</span></div><div class="line">                <span class="keyword">if</span>(!options.silent) &#123;</div><div class="line">                    <span class="comment">// 将当前模型在集合中的位置添加到options对象并传递给remove监听事件, 以便在事件函数中可以使用</span></div><div class="line">                    options.index = index;</div><div class="line">                    model.trigger(<span class="string">'remove'</span>, model, <span class="keyword">this</span>, options);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 解除模型与集合的关系, 包括集合中对模型的引用和事件监听</span></div><div class="line">                <span class="keyword">this</span>._removeReference(model);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 向集合的末尾添加模型对象</span></div><div class="line">        <span class="comment">// 如果集合类中定义了comparator排序方法, 则通过push方法添加的模型将按照comparator定义的算法进行排序, 因此模型顺序可能会被改变</span></div><div class="line">        push : <span class="function"><span class="keyword">function</span>(<span class="params">model, options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 通过_prepareModel方法将model实例化为模型对象, 这句代码是多余的, 因为在下面调用的add方法中还会通过_prepareModel获取一次模型</span></div><div class="line">            model = <span class="keyword">this</span>._prepareModel(model, options);</div><div class="line">            <span class="comment">// 调用add方法将模型添加到集合中(默认添加到集合末尾)</span></div><div class="line">            <span class="keyword">this</span>.add(model, options);</div><div class="line">            <span class="keyword">return</span> model;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 移除集合中最后一个模型对象</span></div><div class="line">        pop : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 获取集合中最后一个模型</span></div><div class="line">            <span class="keyword">var</span> model = <span class="keyword">this</span>.at(<span class="keyword">this</span>.length - <span class="number">1</span>);</div><div class="line">            <span class="comment">// 通过remove方法移除该模型</span></div><div class="line">            <span class="keyword">this</span>.remove(model, options);</div><div class="line">            <span class="keyword">return</span> model;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 向集合的第一个位置插入模型</span></div><div class="line">        <span class="comment">// 如果集合类中定义了comparator排序方法, 则通过unshift方法添加的模型将按照comparator定义的算法进行排序, 因此模型顺序可能会被改变</span></div><div class="line">        unshift : <span class="function"><span class="keyword">function</span>(<span class="params">model, options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 通过_prepareModel方法将model实例化为模型对象</span></div><div class="line">            model = <span class="keyword">this</span>._prepareModel(model, options);</div><div class="line">            <span class="comment">// 调用add方法将模型插入到集合的第一个位置(设置at为0)</span></div><div class="line">            <span class="comment">// 如果定义了comparator排序方法, 集合的顺序将被重排</span></div><div class="line">            <span class="keyword">this</span>.add(model, _.extend(&#123;</div><div class="line">                <span class="attr">at</span> : <span class="number">0</span></div><div class="line">            &#125;, options));</div><div class="line">            <span class="keyword">return</span> model;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 移除并返回集合中的第一个模型对象</span></div><div class="line">        shift : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 获得集合中的第一个模型</span></div><div class="line">            <span class="keyword">var</span> model = <span class="keyword">this</span>.at(<span class="number">0</span>);</div><div class="line">            <span class="comment">// 从集合中删除该模型</span></div><div class="line">            <span class="keyword">this</span>.remove(model, options);</div><div class="line">            <span class="comment">// 返回模型对象</span></div><div class="line">            <span class="keyword">return</span> model;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 根据id从集合中查找模型并返回</span></div><div class="line">        get : <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span>(id == <span class="literal">null</span>)</div><div class="line">                <span class="keyword">return</span></div><div class="line">                <span class="keyword">void</span> <span class="number">0</span>;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._byId[id.id != <span class="literal">null</span> ? id.id : id];</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 根据cid从集合中查找模型并返回</span></div><div class="line">        getByCid : <span class="function"><span class="keyword">function</span>(<span class="params">cid</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> cid &amp;&amp; <span class="keyword">this</span>._byCid[cid.cid || cid];</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 根据索引(下标, 从0开始)从集合中查找模型并返回</span></div><div class="line">        at : <span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.models[index];</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 对集合中的模型根据值进行筛选</span></div><div class="line">        <span class="comment">// attrs是一个筛选对象, 如 &#123;name: 'Jack'&#125;, 将返回集合中所有name为"Jack"的模型(数组)</span></div><div class="line">        where : <span class="function"><span class="keyword">function</span>(<span class="params">attrs</span>) </span>&#123;</div><div class="line">            <span class="comment">// attrs不能为空值</span></div><div class="line">            <span class="keyword">if</span>(_.isEmpty(attrs))</div><div class="line">                <span class="keyword">return</span> [];</div><div class="line">            <span class="comment">// 通过filter方法对集合中的模型进行筛选</span></div><div class="line">            <span class="comment">// filter方法是Underscore中的方法, 用于将遍历集合中的元素, 并将能通过处理器验证(返回值为true)的元素作为数组返回</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="keyword">function</span>(<span class="params">model</span>) </span>&#123;</div><div class="line">                <span class="comment">// 遍历attrs对象中的验证规则</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> attrs) &#123;</div><div class="line">                    <span class="comment">// 将attrs中的验证规则与集合中的模型进行匹配</span></div><div class="line">                    <span class="keyword">if</span>(attrs[key] !== model.get(key))</div><div class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 对集合中的模型按照comparator属性指定的方法进行排序</span></div><div class="line">        <span class="comment">// 如果没有在options中设置silent参数, 则排序后将触发reset事件</span></div><div class="line">        sort : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">            <span class="comment">// options默认是一个对象</span></div><div class="line">            options || ( options = &#123;&#125;);</div><div class="line">            <span class="comment">// 调用sort方法必须指定了comparator属性(排序算法方法), 否则将抛出一个错误</span></div><div class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.comparator)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Cannot sort a set without a comparator'</span>);</div><div class="line">            <span class="comment">// boundComparator存储了绑定当前集合上下文对象的comparator排序算法方法</span></div><div class="line">            <span class="keyword">var</span> boundComparator = _.bind(<span class="keyword">this</span>.comparator, <span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.comparator.length == <span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">this</span>.models = <span class="keyword">this</span>.sortBy(boundComparator);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 调用Array.prototype.sort通过comparator算法对数据进行自定义排序</span></div><div class="line">                <span class="keyword">this</span>.models.sort(boundComparator);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果没有指定silent参数, 则触发reset事件</span></div><div class="line">            <span class="keyword">if</span>(!options.silent)</div><div class="line">                <span class="keyword">this</span>.trigger(<span class="string">'reset'</span>, <span class="keyword">this</span>, options);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 将集合中所有模型的attr属性值存放到一个数组并返回</span></div><div class="line">        pluck : <span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</div><div class="line">            <span class="comment">// map是Underscore中的方法, 用于遍历一个集合, 并将所有处理器的返回值作为一个数组返回</span></div><div class="line">            <span class="keyword">return</span> _.map(<span class="keyword">this</span>.models, <span class="function"><span class="keyword">function</span>(<span class="params">model</span>) </span>&#123;</div><div class="line">                <span class="comment">// 返回当前模型的attr属性值</span></div><div class="line">                <span class="keyword">return</span> model.get(attr);</div><div class="line">            &#125;);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 替换集合中的所有模型数据(models)</span></div><div class="line">        <span class="comment">// 该操作将删除集合中当前的所有数据和状态, 并重新将数据设置为models</span></div><div class="line">        <span class="comment">// models应该是一个数组, 可以包含一系列Model模型对象, 或原始对象(将在add方法中自动创建为模型对象)</span></div><div class="line">        reset : <span class="function"><span class="keyword">function</span>(<span class="params">models, options</span>) </span>&#123;</div><div class="line">            <span class="comment">// models是进行替换的模型(或数据)数组</span></div><div class="line">            models || ( models = []);</div><div class="line">            <span class="comment">// options默认是一个空对象</span></div><div class="line">            options || ( options = &#123;&#125;);</div><div class="line">            <span class="comment">// 遍历当前集合中的模型, 依次删除并解除它们与集合的引用关系</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="keyword">this</span>.models.length; i &lt; l; i++) &#123;</div><div class="line">                <span class="keyword">this</span>._removeReference(<span class="keyword">this</span>.models[i]);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 删除集合数据并重置状态</span></div><div class="line">            <span class="keyword">this</span>._reset();</div><div class="line">            <span class="comment">// 通过add方法将新的模型数据添加到集合</span></div><div class="line">            <span class="comment">// 这里通过exnted方法将配置项覆盖到一个新的对象, 该对象默认silent为true, 因此不会触发"add"事件</span></div><div class="line">            <span class="comment">// 如果在调用reset方法时没有设置silent属性则会触发reset事件, 如果设置为true则不会触发任何事件, 如果设置为false, 将依次触发"add"和"reset"事件</span></div><div class="line">            <span class="keyword">this</span>.add(models, _.extend(&#123;</div><div class="line">                <span class="attr">silent</span> : <span class="literal">true</span></div><div class="line">            &#125;, options));</div><div class="line">            <span class="comment">// 如果在调用reset方法时没有设置silent属性, 则触发reset事件</span></div><div class="line">            <span class="keyword">if</span>(!options.silent)</div><div class="line">                <span class="keyword">this</span>.trigger(<span class="string">'reset'</span>, <span class="keyword">this</span>, options);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 从服务器获取集合的初始化数据</span></div><div class="line">        <span class="comment">// 如果在options中设置参数add=true, 则获取到的数据会被追加到集合中, 否则将以服务器返回的数据替换集合中的当前数据</span></div><div class="line">        fetch : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 复制options对象, 因为options对象在后面会被修改用于临时存储数据</span></div><div class="line">            options = options ? _.clone(options) : &#123;&#125;;</div><div class="line">            <span class="keyword">if</span>(options.parse === <span class="literal">undefined</span>)</div><div class="line">                options.parse = <span class="literal">true</span>;</div><div class="line">            <span class="comment">// collection记录当前集合对象, 用于在success回调函数中使用</span></div><div class="line">            <span class="keyword">var</span> collection = <span class="keyword">this</span>;</div><div class="line">            <span class="comment">// 自定义回调函数, 数据请求成功后并添加完成后, 会调用自定义success函数</span></div><div class="line">            <span class="keyword">var</span> success = options.success;</div><div class="line">            <span class="comment">// 当从服务器请求数据成功时执行options.success, 该函数中将解析并添加数据</span></div><div class="line">            options.success = <span class="function"><span class="keyword">function</span>(<span class="params">resp, status, xhr</span>) </span>&#123;</div><div class="line">                <span class="comment">// 通过parse方法对服务器返回的数据进行解析, 如果需要自定义数据结构, 可以重载parse方法</span></div><div class="line">                <span class="comment">// 如果在options中设置add=true, 则调用add方法将数据添加到集合, 否则将通过reset方法将集合中的数据替换为服务器的返回数据</span></div><div class="line">                collection[options.add ? <span class="string">'add'</span> : <span class="string">'reset'</span>](collection.parse(resp, xhr), options);</div><div class="line">                <span class="comment">// 如果设置了自定义成功回调, 则执行</span></div><div class="line">                <span class="keyword">if</span>(success)</div><div class="line">                    success(collection, resp);</div><div class="line">            &#125;;</div><div class="line">            <span class="comment">// 当服务器返回状态错误时, 通过wrapError方法处理错误事件</span></div><div class="line">            options.error = Backbone.wrapError(options.error, collection, options);</div><div class="line">            <span class="comment">// 调用Backbone.sync方法发送请求从服务器获取数据</span></div><div class="line">            <span class="comment">// 如果需要的数据并不是从服务器获取, 或获取方式不使用AJAX, 可以重载Backbone.sync方法</span></div><div class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>.sync || Backbone.sync).call(<span class="keyword">this</span>, <span class="string">'read'</span>, <span class="keyword">this</span>, options);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 向集合中添加并创建一个模型, 同时将该模型保存到服务器</span></div><div class="line">        <span class="comment">// 如果是通过数据对象来创建模型, 需要在集合中声明model属性对应的模型类</span></div><div class="line">        <span class="comment">// 如果在options中声明了wait属性, 则会在服务器创建成功后再将模型添加到集合, 否则先将模型添加到集合, 再保存到服务器(无论保存是否成功)</span></div><div class="line">        create : <span class="function"><span class="keyword">function</span>(<span class="params">model, options</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> coll = <span class="keyword">this</span>;</div><div class="line">            <span class="comment">// 定义options对象</span></div><div class="line">            options = options ? _.clone(options) : &#123;&#125;;</div><div class="line">            <span class="comment">// 通过_prepareModel获取模型类的实例</span></div><div class="line">            model = <span class="keyword">this</span>._prepareModel(model, options);</div><div class="line">            <span class="comment">// 模型创建失败</span></div><div class="line">            <span class="keyword">if</span>(!model)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            <span class="comment">// 如果没有声明wait属性, 则通过add方法将模型添加到集合中</span></div><div class="line">            <span class="keyword">if</span>(!options.wait)</div><div class="line">                coll.add(model, options);</div><div class="line">            <span class="comment">// success存储保存到服务器成功之后的自定义回调函数(通过options.success声明)</span></div><div class="line">            <span class="keyword">var</span> success = options.success;</div><div class="line">            <span class="comment">// 监听模型数据保存成功后的回调函数</span></div><div class="line">            options.success = <span class="function"><span class="keyword">function</span>(<span class="params">nextModel, resp, xhr</span>) </span>&#123;</div><div class="line">                <span class="comment">// 如果声明了wait属性, 则在只有在服务器保存成功后才会将模型添加到集合中</span></div><div class="line">                <span class="keyword">if</span>(options.wait)</div><div class="line">                    coll.add(nextModel, options);</div><div class="line">                <span class="comment">// 如果声明了自定义成功回调, 则执行自定义函数, 否则将默认触发模型的sync事件</span></div><div class="line">                <span class="keyword">if</span>(success) &#123;</div><div class="line">                    success(nextModel, resp);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    nextModel.trigger(<span class="string">'sync'</span>, model, resp, options);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            <span class="comment">// 调用模型的save方法, 将模型数据保存到服务器</span></div><div class="line">            model.save(<span class="literal">null</span>, options);</div><div class="line">            <span class="keyword">return</span> model;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 数据解析方法, 用于将服务器数据解析为模型和集合可用的结构化数据</span></div><div class="line">        <span class="comment">// 默认将返回resp本身, 这需要与服务器定义Backbone支持的数据格式, 如果需要自定义数据格式, 可以重载parse方法</span></div><div class="line">        parse : <span class="function"><span class="keyword">function</span>(<span class="params">resp, xhr</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> resp;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// chain用于构建集合数据的链式操作, 它将集合中的数据转换为一个Underscore对象, 并使用Underscore的chain方法转换为链式结构</span></div><div class="line">        <span class="comment">// 关于chain方法的转换方式, 可参考Underscore中chain方法的注释</span></div><div class="line">        chain : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> _(<span class="keyword">this</span>.models).chain();</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 删除所有集合元素并重置集合中的数据状态</span></div><div class="line">        _reset : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 删除集合元素</span></div><div class="line">            <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">            <span class="keyword">this</span>.models = [];</div><div class="line">            <span class="comment">// 重置集合状态</span></div><div class="line">            <span class="keyword">this</span>._byId = &#123;&#125;;</div><div class="line">            <span class="keyword">this</span>._byCid = &#123;&#125;;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 将模型添加到集合中之前的一些准备工作</span></div><div class="line">        <span class="comment">// 包括将数据实例化为一个模型对象, 和将集合引用到模型的collection属性</span></div><div class="line">        _prepareModel : <span class="function"><span class="keyword">function</span>(<span class="params">model, options</span>) </span>&#123;</div><div class="line">            options || ( options = &#123;&#125;);</div><div class="line">            <span class="comment">// 检查model是否是一个模型对象(即Model类的实例)</span></div><div class="line">            <span class="keyword">if</span>(!( model <span class="keyword">instanceof</span> Model)) &#123;</div><div class="line">                <span class="comment">// 传入的model是模型数据对象, 而并非模型对象</span></div><div class="line">                <span class="comment">// 将数据作为参数传递给Model, 以创建一个新的模型对象</span></div><div class="line">                <span class="keyword">var</span> attrs = model;</div><div class="line">                <span class="comment">// 设置模型引用的集合</span></div><div class="line">                options.collection = <span class="keyword">this</span>;</div><div class="line">                <span class="comment">// 将数据转化为模型</span></div><div class="line">                model = <span class="keyword">new</span> <span class="keyword">this</span>.model(attrs, options);</div><div class="line">                <span class="comment">// 对模型中的数据进行验证</span></div><div class="line">                <span class="keyword">if</span>(!model._validate(model.attributes, options))</div><div class="line">                    model = <span class="literal">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!model.collection) &#123;</div><div class="line">                <span class="comment">// 如果传入的是一个模型对象但没有建立与集合的引用, 则设置模型的collection属性为当前集合</span></div><div class="line">                model.collection = <span class="keyword">this</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> model;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 解绑某个模型与集合的关系, 包括对集合的引用和事件监听</span></div><div class="line">        <span class="comment">// 一般在调用remove方法删除模型或调用reset方法重置状态时自动调用</span></div><div class="line">        _removeReference : <span class="function"><span class="keyword">function</span>(<span class="params">model</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果模型引用了当前集合, 则移除该引用(必须确保所有对模型的引用已经解除, 否则模型可能无法从内存中释放)</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == model.collection) &#123;</div><div class="line">                <span class="keyword">delete</span> model.collection;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 取消集合中监听的所有模型事件</span></div><div class="line">            model.off(<span class="string">'all'</span>, <span class="keyword">this</span>._onModelEvent, <span class="keyword">this</span>);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 在向集合中添加模型时被自动调用</span></div><div class="line">        <span class="comment">// 用于监听集合中模型的事件, 当模型在触发事件(add, remove, destroy, change事件)时集合进行相关处理</span></div><div class="line">        _onModelEvent : <span class="function"><span class="keyword">function</span>(<span class="params">event, model, collection, options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 添加和移除模型的事件, 必须确保模型所属的集合为当前集合对象</span></div><div class="line">            <span class="keyword">if</span>((event == <span class="string">'add'</span> || event == <span class="string">'remove'</span>) &amp;&amp; collection != <span class="keyword">this</span>)</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="comment">// 模型触发销毁事件时, 从集合中移除</span></div><div class="line">            <span class="keyword">if</span>(event == <span class="string">'destroy'</span>) &#123;</div><div class="line">                <span class="keyword">this</span>.remove(model, options);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 当模型的id被修改时, 集合修改_byId中存储对模型的引用, 保持与模型id的同步, 便于使用get()方法获取模型对象</span></div><div class="line">            <span class="keyword">if</span>(model &amp;&amp; event === <span class="string">'change:'</span> + model.idAttribute) &#123;</div><div class="line">                <span class="comment">// 获取模型在改变之前的id, 并根据此id从集合的_byId列表中移除</span></div><div class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>._byId[model.previous(model.idAttribute)];</div><div class="line">                <span class="comment">// 以模型新的id作为key, 在_byId列表中存放对模型的引用</span></div><div class="line">                <span class="keyword">this</span>._byId[model.id] = model;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 在集合中触发模型对应的事件, 无论模型触发任何事件, 集合都会触发对应的事件</span></div><div class="line">            <span class="comment">// (例如当模型被添加到集合中时, 会触发模型的"add"事件, 同时也会在此方法中触发集合的"add"事件)</span></div><div class="line">            <span class="comment">// 这对于监听并处理集合中模型状态的变化非常有效</span></div><div class="line">            <span class="comment">// 在监听的集合事件中, 触发对应事件的模型会被作为参数传递给集合的监听函数</span></div><div class="line">            <span class="keyword">this</span>.trigger.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    <span class="comment">// 定义Underscore中的集合操作的相关方法</span></div><div class="line">    <span class="comment">// 将Underscore中一系列集合操作方法复制到Collection集合类的原型对象中</span></div><div class="line">    <span class="comment">// 这样就可以直接通过集合对象调用Underscore相关的集合方法</span></div><div class="line">    <span class="comment">// 这些方法在调用时所操作的集合数据是当前Collection对象的models数据</span></div><div class="line">    <span class="keyword">var</span> methods = [<span class="string">'forEach'</span>, <span class="string">'each'</span>, <span class="string">'map'</span>, <span class="string">'reduce'</span>, <span class="string">'reduceRight'</span>, <span class="string">'find'</span>, <span class="string">'detect'</span>, <span class="string">'filter'</span>, <span class="string">'select'</span>, <span class="string">'reject'</span>, <span class="string">'every'</span>, <span class="string">'all'</span>, <span class="string">'some'</span>, <span class="string">'any'</span>, <span class="string">'include'</span>, <span class="string">'contains'</span>, <span class="string">'invoke'</span>, <span class="string">'max'</span>, <span class="string">'min'</span>, <span class="string">'sortBy'</span>, <span class="string">'sortedIndex'</span>, <span class="string">'toArray'</span>, <span class="string">'size'</span>, <span class="string">'first'</span>, <span class="string">'initial'</span>, <span class="string">'rest'</span>, <span class="string">'last'</span>, <span class="string">'without'</span>, <span class="string">'indexOf'</span>, <span class="string">'shuffle'</span>, <span class="string">'lastIndexOf'</span>, <span class="string">'isEmpty'</span>, <span class="string">'groupBy'</span>];</div><div class="line"> </div><div class="line">    <span class="comment">// 遍历已经定义的方法列表</span></div><div class="line">    _.each(methods, <span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</div><div class="line">        <span class="comment">// 将方法复制到Collection集合类的原型对象</span></div><div class="line">        Collection.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 调用时直接使用Underscore的方法, 上下文对象保持为Underscore对象</span></div><div class="line">            <span class="comment">// 需要注意的是这里传递给Underscore方法的集合参数是 this.models, 因此在使用这些方法时, 所操作的集合对象是当前Collection对象的models数据</span></div><div class="line">            <span class="keyword">return</span> _[method].apply(_, [<span class="keyword">this</span>.models].concat(_.toArray(<span class="built_in">arguments</span>)));</div><div class="line">        &#125;;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// Backbone.Router URL路由器</span></div><div class="line">    <span class="comment">// -------------------</span></div><div class="line"> </div><div class="line">    <span class="comment">// 通过继承Backbone.Router类实现自定义的路由器</span></div><div class="line">    <span class="comment">// 路由器允许定义路由规则, 通过URL片段进行导航, 并将每一个规则对应到一个方法, 当URL匹配某个规则时会自动执行该方法</span></div><div class="line">    <span class="comment">// 路由器通过URL进行导航, 导航方式分为pushState, Hash, 和监听方式(详细可参考Backbone.History类)</span></div><div class="line">    <span class="comment">// 在创建Router实例时, 通过options.routes来设置某个路由规则对应的监听方法</span></div><div class="line">    <span class="comment">// options.routes中的路由规则按照 &#123;规则名称: 方法名称&#125;进行组织, 每一个路由规则所对应的方法, 都必须是在Router实例中的已经声明的方法</span></div><div class="line">    <span class="comment">// options.routes定义的路由规则按照先后顺序进行匹配, 如果当前URL能被多个规则匹配, 则只会执行第一个匹配的事件方法</span></div><div class="line">    <span class="keyword">var</span> Router = Backbone.Router = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">        <span class="comment">// options默认是一个空对象</span></div><div class="line">        options || ( options = &#123;&#125;);</div><div class="line">        <span class="comment">// 如果在options中设置了routes对象(路由规则), 则赋给当前实例的routes属性</span></div><div class="line">        <span class="comment">// routes属性记录了路由规则与事件方法的绑定关系, 当URL与某一个规则匹配时, 会自动调用关联的事件方法</span></div><div class="line">        <span class="keyword">if</span>(options.routes)</div><div class="line">            <span class="keyword">this</span>.routes = options.routes;</div><div class="line">        <span class="comment">// 解析和绑定路由规则</span></div><div class="line">        <span class="keyword">this</span>._bindRoutes();</div><div class="line">        <span class="comment">// 调用自定义的初始化方法</span></div><div class="line">        <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 定义用于将字符串形式的路由规则, 转换为可执行的正则表达式规则时的查找条件</span></div><div class="line">    <span class="comment">// (字符串形式的路由规则, 通过\w+进行匹配, 因此只支持字母数字和下划线组成的字符串)</span></div><div class="line">    <span class="comment">// 匹配一个URL片段中(以/"斜线"为分隔)的动态路由规则</span></div><div class="line">    <span class="comment">// 如: (topic/:id) 匹配 (topic/1228), 监听事件function(id) &#123; // id为1228 &#125;</span></div><div class="line">    <span class="keyword">var</span> namedParam = <span class="regexp">/:\w+/g</span>;</div><div class="line">    <span class="comment">// 匹配整个URL片段中的动态路由规则</span></div><div class="line">    <span class="comment">// 如: (topic*id) 匹配 (url#/topic1228), 监听事件function(id) &#123; // id为1228 &#125;</span></div><div class="line">    <span class="keyword">var</span> splatParam = <span class="regexp">/\*\w+/g</span>;</div><div class="line">    <span class="comment">// 匹配URL片段中的特殊字符, 并在字符前加上转义符, 防止特殊字符在被转换为正则表达式后变成元字符</span></div><div class="line">    <span class="comment">// 如: (abc)^[,.] 将被转换为 \(abc\)\^\[\,\.\]</span></div><div class="line">    <span class="keyword">var</span> escapeRegExp = <span class="regexp">/[-[\]&#123;&#125;()+?.,\\^$|#\s]/g</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// 向Router类的原型对象中扩展属性和方法</span></div><div class="line">    _.extend(Router.prototype, Events, &#123;</div><div class="line"> </div><div class="line">        <span class="comment">// 自定义初始化方法, 在路由器Router实例化后被自动调用</span></div><div class="line">        initialize : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 将一个路由规则绑定给一个监听事件, 当URL片段匹配该规则时, 会自动调用触发该事件</span></div><div class="line">        route : <span class="function"><span class="keyword">function</span>(<span class="params">route, name, callback</span>) </span>&#123;</div><div class="line">            <span class="comment">// 创建history实例, Backbone.history是一个单例对象, 只在第一次创建路由器对象时被实例化</span></div><div class="line">            Backbone.history || (Backbone.history = <span class="keyword">new</span> History);</div><div class="line">            <span class="comment">// 检查route规则名称是否为一个字符串(当手动调用route方法创建路由规则时, 允许传递一个正则表达式或字符串作为规则)</span></div><div class="line">            <span class="comment">// 在构造Router实例时传入options.routes中的规则, 都应该是一个字符串(因为在_bindRoutes方法中将routes配置中的key作为路由规则)</span></div><div class="line">            <span class="comment">// 如果传入的是字符串类型的路由规则, 通过_routeToRegExp方法将其转换为一个正则表达式, 用于匹配URL片段</span></div><div class="line">            <span class="keyword">if</span>(!_.isRegExp(route))</div><div class="line">                route = <span class="keyword">this</span>._routeToRegExp(route);</div><div class="line">            <span class="comment">// 如果没有设置callback(事件方法), 则根据name从当前Router实例中获取与name同名的方法</span></div><div class="line">            <span class="comment">// 这是因为在手动调用route方法时可能不会传递callback方法, 但必须传递name事件名称, 并在Router实例中已经定义了该方法</span></div><div class="line">            <span class="keyword">if</span>(!callback)</div><div class="line">                callback = <span class="keyword">this</span>[name];</div><div class="line">            <span class="comment">// 调用history实例的route方法, 该方法会将转换后的正则表达式规则, 和监听事件方法绑定到history.handlers列表中, 以便history进行路由和控制</span></div><div class="line">            <span class="comment">// 当history实例匹配到对应的路由规则而调用该事件时, 会将URL片段作为字符串(即fragment参数)传递给该事件方法</span></div><div class="line">            <span class="comment">// 这里并没有直接将监听事件传递给history的route方法, 而是使用bind方法封装了另一个函数, 该函数的执行上下文为当前Router对象</span></div><div class="line">            Backbone.history.route(route, _.bind(<span class="function"><span class="keyword">function</span>(<span class="params">fragment</span>) </span>&#123;</div><div class="line">                <span class="comment">// 调用_extractParameters方法获取匹配到的规则中的参数</span></div><div class="line">                <span class="keyword">var</span> args = <span class="keyword">this</span>._extractParameters(route, fragment);</div><div class="line">                <span class="comment">// 调用callback路由监听事件, 并将参数传递给监听事件</span></div><div class="line">                callback &amp;&amp; callback.apply(<span class="keyword">this</span>, args);</div><div class="line">                <span class="comment">// 触发route:name事件, name为调用route时传递的事件名称</span></div><div class="line">                <span class="comment">// 如果对当前Router实例使用on方法绑定了route:name事件, 则会收到该事件的触发通知</span></div><div class="line">                <span class="keyword">this</span>.trigger.apply(<span class="keyword">this</span>, [<span class="string">'route:'</span> + name].concat(args));</div><div class="line">                <span class="comment">// 触发history实例中绑定的route事件, 当路由器匹配到任何规则时, 均会触发该事件</span></div><div class="line">                Backbone.history.trigger(<span class="string">'route'</span>, <span class="keyword">this</span>, name, args);</div><div class="line">                <span class="comment">/**</span></div><div class="line">                 * 事件绑定如:</div><div class="line">                 * var router = new MyRouter();</div><div class="line">                 * router.on('route:routename', function(param) &#123;</div><div class="line">                 *     // 绑定到Router实例中某个规则的事件, 当匹配到该规则时触发</div><div class="line">                 * &#125;);</div><div class="line">                 * Backbone.history.on('route', function(router, name, args) &#123;</div><div class="line">                 *     // 绑定到history实例中的事件, 当匹配到任何规则时触发</div><div class="line">                 * &#125;);</div><div class="line">                 * Backbone.history.start();</div><div class="line">                 */</div><div class="line">            &#125;, <span class="keyword">this</span>));</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 通过调用history.navigate方法, 手动设置跳转到URL</span></div><div class="line">        navigate : <span class="function"><span class="keyword">function</span>(<span class="params">fragment, options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 代理到history实例的navigate方法</span></div><div class="line">            Backbone.history.navigate(fragment, options);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 解析当前实例定义的路由(this.routes)规则, 并调用route方法将每一个规则绑定到对应的方法</span></div><div class="line">        _bindRoutes : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果在创建对象时没有设置routes规则, 则不进行解析和绑定</span></div><div class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.routes)</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="comment">// routes变量以二维数组的形式存储倒序排列的路由规则</span></div><div class="line">            <span class="comment">// 如[['', 'homepage'], ['controller:name', 'toController']]</span></div><div class="line">            <span class="keyword">var</span> routes = [];</div><div class="line">            <span class="comment">// 遍历routes配置</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> route <span class="keyword">in</span> <span class="keyword">this</span>.routes) &#123;</div><div class="line">                <span class="comment">// 将路由规则放入一个新的数组, 按照[规则名称, 绑定方法]组织</span></div><div class="line">                <span class="comment">// 将该数组通过unshift方法放置到routes顶部, 实现倒序排列</span></div><div class="line">                <span class="comment">// 这里将routes中的规则倒序排列, 在后面调用route方法时会再次调用unshift将顺序倒过来, 以保证最终的顺序是按照routes配置中定义的顺序来执行的</span></div><div class="line">                <span class="comment">// 倒换两次顺序后, 会重新恢复最初调用前的顺序, 之所以这样做, 是因为用户可以手动调用route方法动态添加路由规则, 而手动添加的路由规则会被添加到列表的第一个, 因此要在route方法中使用unshift来插入规则</span></div><div class="line">                <span class="comment">// 而构造Router实例时自动添加的规则, 为了保持定义顺序, 因此在此处将定义的规则倒序排列</span></div><div class="line">                routes.unshift([route, <span class="keyword">this</span>.routes[route]]);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 循环完毕, 此时routes中存储了倒序排列的路由规则</span></div><div class="line"> </div><div class="line">            <span class="comment">// 循环路由规则, 并依次调用route方法, 将规则名称绑定到具体的事件函数</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, l = routes.length; i &lt; l; i++) &#123;</div><div class="line">                <span class="comment">// 调用route方法, 并分别传递(规则名称, 事件函数名, 事件函数对象)</span></div><div class="line">                <span class="keyword">this</span>.route(routes[i][<span class="number">0</span>], routes[i][<span class="number">1</span>], <span class="keyword">this</span>[routes[i][<span class="number">1</span>]]);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 将字符串形式的路由规则转换为正则表达式对象</span></div><div class="line">        <span class="comment">// (在route方法中检查到字符串类型的路由规则后, 会自动调用该方法进行转换)</span></div><div class="line">        _routeToRegExp : <span class="function"><span class="keyword">function</span>(<span class="params">route</span>) </span>&#123;</div><div class="line">            <span class="comment">// 为字符串中特殊字符添加转义符, 防止特殊字符在被转换为正则表达式后变成元字符(这些特殊字符包括-[\]&#123;&#125;()+?.,\\^$|#\s)</span></div><div class="line">            <span class="comment">// 将字符串中以/"斜线"为分隔的动态路由规则转换为([^\/]+), 在正则中表示以/"斜线"开头的多个字符</span></div><div class="line">            <span class="comment">// 将字符串中的*"星号"动态路由规则转换为(.*?), 在正则中表示0或多个任意字符(这里使用了非贪婪模式, 因此你可以使用例如这样的组合路由规则: *list/:id, 将匹配 orderlist/123 , 同时会将"order"和"123"作为参数传递给事件方法 )</span></div><div class="line">            <span class="comment">// 请注意namedParam和splatParam替换后的正则表达式都是用()括号将匹配的内容包含起来, 这是为了方便取出匹配的内容作为参数传递给事件方法</span></div><div class="line">            <span class="comment">// 请注意namedParam和splatParam匹配的字符串 :str, *str中的str字符串是无意义的, 它们会在下面替换后被忽略, 但一般写作和监听事件方法的参数同名, 以便进行标识</span></div><div class="line">            route = route.replace(escapeRegExp, <span class="string">'\\$&amp;'</span>).replace(namedParam, <span class="string">'([^\/]+)'</span>).replace(splatParam, <span class="string">'(.*?)'</span>);</div><div class="line">            <span class="comment">// 将转换后的字符串创建为正则表达式对象并返回</span></div><div class="line">            <span class="comment">// 这个正则表达式将根据route字符串中的规则, 用于匹配URL片段</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^'</span> + route + <span class="string">'$'</span>);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 传入一个路由规则(正则表达式)和URL片段(字符串)进行匹配, 并返回从匹配的字符串中获取参数</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 例如路由规则为 'teams/:type/:id', 对应的正则表达式会被转换为/^teams/([^/]+)/([^/]+)$/ , (对路由规则转换为正则表达式的过程可参考_routeToRegExp方法)</div><div class="line">         * URL片段为 'teams/35/1228'</div><div class="line">         * 则通过exec执行后的结果为 ["teams/35/1228", "35", "1228"]</div><div class="line">         * 数组中的一个元素是URL片段字符串本身, 从第二个开始则依次为路由规则表达式中的参数</div><div class="line">         */</div><div class="line">        _extractParameters : <span class="function"><span class="keyword">function</span>(<span class="params">route, fragment</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> route.exec(fragment).slice(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    <span class="comment">// Backbone.History 路由器管理</span></div><div class="line">    <span class="comment">// ----------------</span></div><div class="line"> </div><div class="line">    <span class="comment">// History类提供路由管理相关操作, 包括监听URL的变化, (通过popstate和onhashchange事件进行监听, 对于不支持事件的浏览器通过setInterval心跳监控)</span></div><div class="line">    <span class="comment">// 提供路由规则与当前URL的匹配验证, 和触发相关的监听事件</span></div><div class="line">    <span class="comment">// History一般不会被直接调用, 在第一次实例化Router对象时, 将自动创建一个History的单例(通过Backbone.history访问)</span></div><div class="line">    <span class="keyword">var</span> History = Backbone.History = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// handlers属性记录了当前所有路由对象中已经设置的规则和监听列表</span></div><div class="line">        <span class="comment">// 形式如: [&#123;route: route, callback: callback&#125;], route记录了正则表达式规则, callback记录了匹配规则时的监听事件</span></div><div class="line">        <span class="comment">// 当history对象监听到URL发生变化时, 会自动与handlers中定义的规则进行匹配, 并调用监听事件</span></div><div class="line">        <span class="keyword">this</span>.handlers = [];</div><div class="line">        <span class="comment">// 将checkUrl方法的上下文对象绑定到history对象, 因为checkUrl方法被作为popstate和onhashchange事件或setInterval的回调函数, 在执行回调时, 上下文对象会被改变</span></div><div class="line">        <span class="comment">// checkUrl方法用于在监听到URL发生变化时检查并调用loadUrl方法</span></div><div class="line">        _.bindAll(<span class="keyword">this</span>, <span class="string">'checkUrl'</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 定义用于匹配URL片段中首字符是否为"#"或"/"的正则</span></div><div class="line">    <span class="keyword">var</span> routeStripper = <span class="regexp">/^[#\/]/</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// 定义用于匹配从userAgent中获取的字符串是否包含IE浏览器的标识, 用于判断当前浏览器是否为IE</span></div><div class="line">    <span class="keyword">var</span> isExplorer = <span class="regexp">/msie [\w.]+/</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// 记录当前history单例对象是否已经被初始化过(调用start方法)</span></div><div class="line">    History.started = <span class="literal">false</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// 向History类的原型对象中添加方法, 这些方法可以通过History的实例调用(即Backbone.history对象)</span></div><div class="line">    _.extend(History.prototype, Events, &#123;</div><div class="line"> </div><div class="line">        <span class="comment">// 当用户使用低版本的IE浏览器(不支持onhashchange事件)时, 通过心跳监听路由状态的变化</span></div><div class="line">        <span class="comment">// interval属性设置心跳频率(毫秒), 该频率如果太低可能会导致延迟, 如果太高可能会消耗CPU资源(需要考虑用户使用低端浏览器时的设备配置)</span></div><div class="line">        interval : <span class="number">50</span>,</div><div class="line"> </div><div class="line">        <span class="comment">// 获取location中Hash字符串(锚点#后的片段)</span></div><div class="line">        getHash : <span class="function"><span class="keyword">function</span>(<span class="params">windowOverride</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果传入了一个window对象, 则从该对象中获取, 否则默认从当前window对象中获取</span></div><div class="line">            <span class="keyword">var</span> loc = windowOverride ? windowOverride.location : <span class="built_in">window</span>.location;</div><div class="line">            <span class="comment">// 将锚点(#)后的字符串提取出来并返回</span></div><div class="line">            <span class="keyword">var</span> match = loc.href.match(<span class="regexp">/#(.*)$/</span>);</div><div class="line">            <span class="comment">// 如果没有找到匹配的内容, 则返回空字符串</span></div><div class="line">            <span class="keyword">return</span> match ? match[<span class="number">1</span>] : <span class="string">''</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 根据当前设置的路由方式, 处理并返回当前URL中的路由片段</span></div><div class="line">        getFragment : <span class="function"><span class="keyword">function</span>(<span class="params">fragment, forcePushState</span>) </span>&#123;</div><div class="line">            <span class="comment">// fragment是通过getHash或从URL中已经提取的待处理路由片段(如 #/id/1288)</span></div><div class="line">            <span class="keyword">if</span>(fragment == <span class="literal">null</span>) &#123;<span class="comment">// 如果没有传递fragment, 则根据当前路由方式进行提取</span></div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>._hasPushState || forcePushState) &#123;</div><div class="line">                    <span class="comment">// 使用了pushState方式进行路由</span></div><div class="line">                    <span class="comment">// fragment记录当前域名后的URL路径</span></div><div class="line">                    fragment = <span class="built_in">window</span>.location.pathname;</div><div class="line">                    <span class="comment">// search记录当前页面后的参数内容</span></div><div class="line">                    <span class="keyword">var</span> search = <span class="built_in">window</span>.location.search;</div><div class="line">                    <span class="comment">// 将路径和参数合并在一起, 作为待处理的路由片段</span></div><div class="line">                    <span class="keyword">if</span>(search)</div><div class="line">                        fragment += search;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 使用了hash方式进行路由</span></div><div class="line">                    <span class="comment">// 通过getHash方法获取当前锚点(#)后的字符串作为路由片段</span></div><div class="line">                    fragment = <span class="keyword">this</span>.getHash();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 根据配置项中设置的root参数, 则从路由片段取出root路径之后的内容</span></div><div class="line">            <span class="keyword">if</span>(!fragment.indexOf(<span class="keyword">this</span>.options.root))</div><div class="line">                fragment = fragment.substr(<span class="keyword">this</span>.options.root.length);</div><div class="line">            <span class="comment">// 如果URL片段首字母为"#"或"/", 则去除该字符</span></div><div class="line">            <span class="comment">// 返回处理之后的URL片段</span></div><div class="line">            <span class="keyword">return</span> fragment.replace(routeStripper, <span class="string">''</span>);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 初始化History实例, 该方法只会被调用一次, 应该在创建并初始化Router对象之后被自动调用</span></div><div class="line">        <span class="comment">// 该方法作为整个路由的调度器, 它将针对不同浏览器监听URL片段的变化, 负责验证并通知到监听函数</span></div><div class="line">        start : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果history对象已经被初始化过, 则抛出错误</span></div><div class="line">            <span class="keyword">if</span>(History.started)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Backbone.history has already been started"</span>);</div><div class="line">            <span class="comment">// 设置history对象的初始化状态</span></div><div class="line">            History.started = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">            <span class="comment">// 设置配置项, 使用调用start方法时传递的options配置项覆盖默认配置</span></div><div class="line">            <span class="keyword">this</span>.options = _.extend(&#123;&#125;, &#123;</div><div class="line">                <span class="comment">// root属性设置URL导航中的路由根目录</span></div><div class="line">                <span class="comment">// 如果使用pushState方式进行路由, 则root目录之后的地址会根据不同的路由产生不同的地址(这可能会定位到不同的页面, 因此需要确保服务器支持)</span></div><div class="line">                <span class="comment">// 如果使用Hash锚点的方式进行路由, 则root表示URL后锚点(#)的位置</span></div><div class="line">                root : <span class="string">'/'</span></div><div class="line">            &#125;, <span class="keyword">this</span>.options, options);</div><div class="line">            <span class="comment">/**</span></div><div class="line">             * history针对不同浏览器特性, 实现了3种方式的监听:</div><div class="line">             * - 对于支持HTML5中popstate事件的浏览器, 通过popstate事件进行监听</div><div class="line">             * - 对于不支持popstate的浏览器, 使用onhashchange事件进行监听(通过改变hash(锚点)设置的URL在被载入时会触发onhashchange事件)</div><div class="line">             * - 对于不支持popstate和onhashchange事件的浏览器, 通过保持心跳监听</div><div class="line">             *</div><div class="line">             * 关于HTML5中popstate事件的相关方法:</div><div class="line">             * - pushState可以将指定的URL添加一个新的history实体到浏览器历史里</div><div class="line">             * - replaceState方法可以将当前的history实体替换为指定的URL</div><div class="line">             * 使用pushState和replaceState方法时仅替换当前URL, 而并不会真正转到这个URL(当使用后退或前进按钮时, 也不会跳转到该URL)</div><div class="line">             * (这两个方法可以解决在AJAX单页应用中浏览器前进, 后退操作的问题)</div><div class="line">             * 当使用pushState或replaceState方法替换的URL, 在被载入时会触发onpopstate事件</div><div class="line">             * 浏览器支持情况:</div><div class="line">             * Chrome 5, Firefox 4.0, IE 10, Opera 11.5, Safari 5.0</div><div class="line">             *</div><div class="line">             * 注意:</div><div class="line">             * - history.start方法默认使用Hash方式进行导航</div><div class="line">             * - 如果需要启用pushState方式进行导航, 需要在调用start方法时, 手动传入配置options.pushState</div><div class="line">             *   (设置前请确保浏览器支持pushState特性, 否则将默认转换为Hash方式)</div><div class="line">             * - 当使用pushState方式进行导航时, URL可能会从options.root指定的根目录后发生变化, 这可能会导航到不同页面, 因此请确保服务器已经支持pushState方式的导航</div><div class="line">             */</div><div class="line">            <span class="comment">// _wantsHashChange属性记录是否希望使用hash(锚点)的方式来记录和导航路由器</span></div><div class="line">            <span class="comment">// 除非在options配置项中手动设置hashChange为false, 否则默认将使用hash锚点的方式</span></div><div class="line">            <span class="comment">// (如果手动设置了options.pushState为true, 且浏览器支持pushState特性, 则会使用pushState方式)</span></div><div class="line">            <span class="keyword">this</span>._wantsHashChange = <span class="keyword">this</span>.options.hashChange !== <span class="literal">false</span>;</div><div class="line">            <span class="comment">// _wantsPushState属性记录是否希望使用pushState方式来记录和导航路由器</span></div><div class="line">            <span class="comment">// pushState是HTML5中为window.history添加的新特性, 如果没有手动声明options.pushState为true, 则默认将使用hash方式</span></div><div class="line">            <span class="keyword">this</span>._wantsPushState = !!<span class="keyword">this</span>.options.pushState;</div><div class="line">            <span class="comment">// _hasPushState属性记录浏览器是否支持pushState特性</span></div><div class="line">            <span class="comment">// 如果在options中设置了pushState(即希望使用pushState方式), 则检查浏览器是否支持该特性</span></div><div class="line">            <span class="keyword">this</span>._hasPushState = !!(<span class="keyword">this</span>.options.pushState &amp;&amp; <span class="built_in">window</span>.history &amp;&amp; <span class="built_in">window</span>.history.pushState);</div><div class="line">            <span class="comment">// 获取当前URL中的路由字符串</span></div><div class="line">            <span class="keyword">var</span> fragment = <span class="keyword">this</span>.getFragment();</div><div class="line">            <span class="comment">// documentMode是IE浏览器的独有属性, 用于标识当前浏览器使用的渲染模式</span></div><div class="line">            <span class="keyword">var</span> docMode = <span class="built_in">document</span>.documentMode;</div><div class="line">            <span class="comment">// oldIE用于检查当前浏览器是否为低版本的IE浏览器(即IE 7.0以下版本)</span></div><div class="line">            <span class="comment">// 这句代码可理解为: 当前浏览器为IE, 但不支持documentMode属性, 或documentMode属性返回的渲染模式为IE7.0以下</span></div><div class="line">            <span class="keyword">var</span> oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) &amp;&amp; (!docMode || docMode &lt;= <span class="number">7</span>));</div><div class="line"> </div><div class="line">            <span class="keyword">if</span>(oldIE) &#123;</div><div class="line">                <span class="comment">// 如果用户使用低版本的IE浏览器, 不支持popstate和onhashchange事件</span></div><div class="line">                <span class="comment">// 向DOM中插入一个隐藏的iframe, 并通过改变和心跳监听该iframe的URL实现路由</span></div><div class="line">                <span class="keyword">this</span>.iframe = $(<span class="string">'&lt;iframe src="javascript:0" tabindex="-1" /&gt;'</span>).hide().appendTo(<span class="string">'body'</span>)[<span class="number">0</span>].contentWindow;</div><div class="line">                <span class="comment">// 通过navigate将iframe设置到当前的URL片段, 这并不会真正加载到一个页面, 因为fragment并非一个完整的URL</span></div><div class="line">                <span class="keyword">this</span>.navigate(fragment);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">// 开始监听路由状态变化</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>._hasPushState) &#123;</div><div class="line">                <span class="comment">// 如果使用了pushState方式路由, 且浏览器支持该特性, 则将popstate事件监听到checkUrl方法</span></div><div class="line">                $(<span class="built_in">window</span>).bind(<span class="string">'popstate'</span>, <span class="keyword">this</span>.checkUrl);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>._wantsHashChange &amp;&amp; (<span class="string">'onhashchange'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &amp;&amp; !oldIE) &#123;</div><div class="line">                <span class="comment">// 如果使用Hash方式进行路由, 且浏览器支持onhashchange事件, 则将hashchange事件监听到checkUrl方法</span></div><div class="line">                $(<span class="built_in">window</span>).bind(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.checkUrl);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>._wantsHashChange) &#123;</div><div class="line">                <span class="comment">// 对于低版本的浏览器, 通过setInterval方法心跳监听checkUrl方法, interval属性标识心跳频率</span></div><div class="line">                <span class="keyword">this</span>._checkUrlInterval = setInterval(<span class="keyword">this</span>.checkUrl, <span class="keyword">this</span>.interval);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">// 记录当前的URL片段</span></div><div class="line">            <span class="keyword">this</span>.fragment = fragment;</div><div class="line">            <span class="comment">// 验证当前是否处于根路径(即options.root中所配置的路径)</span></div><div class="line">            <span class="keyword">var</span> loc = <span class="built_in">window</span>.location;</div><div class="line">            <span class="keyword">var</span> atRoot = loc.pathname == <span class="keyword">this</span>.options.root;</div><div class="line"> </div><div class="line">            <span class="comment">// 如果用户通过pushState方式的URL访问到当前地址, 但用户此时所使用的浏览器并不支持pushState特性</span></div><div class="line">            <span class="comment">// (这可能是某个用户通过pushState方式访问该应用, 然后将地址分享给其他用户, 而其他用户的浏览器并不支持该特性)</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>._wantsHashChange &amp;&amp; <span class="keyword">this</span>._wantsPushState &amp;&amp; !<span class="keyword">this</span>._hasPushState &amp;&amp; !atRoot) &#123;</div><div class="line">                <span class="comment">// 获取当前pushState方式中的URL片段, 并通过Hash方式重新打开页面</span></div><div class="line">                <span class="keyword">this</span>.fragment = <span class="keyword">this</span>.getFragment(<span class="literal">null</span>, <span class="literal">true</span>);</div><div class="line">                <span class="comment">// 例如hashState方式的URL为 /root/topic/12001, 重新打开的Hash方式的URL则为 /root#topic/12001</span></div><div class="line">                <span class="built_in">window</span>.location.replace(<span class="keyword">this</span>.options.root + <span class="string">'#'</span> + <span class="keyword">this</span>.fragment);</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"> </div><div class="line">                <span class="comment">// 如果用户通过Hash方式的URL访问到当前地址, 但调用Backbone.history.start方法时设置了pushState(希望通过pushState方式进行路由)</span></div><div class="line">                <span class="comment">// 且用户浏览器支持pushState特性, 则将当前URL替换为pushState方式(注意, 这里使用replaceState方式进行替换URL, 而页面不会被刷新)</span></div><div class="line">                <span class="comment">// 以下分支条件可理解为: 如果我们希望使用pushState方式进行路由, 且浏览器支持该特性, 同时用户还使用了Hash方式打开当前页面</span></div><div class="line">                <span class="comment">// (这可能是某个用户使用Hash方式浏览到一个URL, 并将URL分享给另一个浏览器支持pushState特性的用户, 当该用户访问时会执行此分支)</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>._wantsPushState &amp;&amp; <span class="keyword">this</span>._hasPushState &amp;&amp; atRoot &amp;&amp; loc.hash) &#123;</div><div class="line">                <span class="comment">// 获取URL中的Hash片段, 并清除字符串首个"#"或"/"</span></div><div class="line">                <span class="keyword">this</span>.fragment = <span class="keyword">this</span>.getHash().replace(routeStripper, <span class="string">''</span>);</div><div class="line">                <span class="comment">// 使用replaceState方法将当前浏览器的URL替换为pushState支持的方式, 即: 协议//主机地址/URL路径/Hash参数, 例如:</span></div><div class="line">                <span class="comment">// 当用户访问Hash方式的URL为 /root/#topic/12001, 将被替换为 /root/topic/12001</span></div><div class="line">                <span class="comment">// 注:</span></div><div class="line">                <span class="comment">// pushState和replaceState方法的参数有3个, 分别是state, title, url</span></div><div class="line">                <span class="comment">// -state: 用于存储插入或修改的history实体信息</span></div><div class="line">                <span class="comment">// -title: 用于设置浏览器标题(属于保留参数, 目前浏览器还没有实现该特性)</span></div><div class="line">                <span class="comment">// -url: 设置history实体的URL地址(可以是绝对或相对路径, 但无法设置跨域URL)</span></div><div class="line">                <span class="built_in">window</span>.history.replaceState(&#123;&#125;, <span class="built_in">document</span>.title, loc.protocol + <span class="string">'//'</span> + loc.host + <span class="keyword">this</span>.options.root + <span class="keyword">this</span>.fragment);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">// 一般调用start方法时会自动调用loadUrl, 匹配当前URL片段对应的路由规则, 调用该规则的方法</span></div><div class="line">            <span class="comment">// 如果设置了silent属性为true, 则loadUrl方法不会被调用</span></div><div class="line">            <span class="comment">// 这种情况一般出现在调用了stop方法重置history对象状态后, 再次调用start方法启动(实际上此时并非为页面初始化, 因此会设置silent属性)</span></div><div class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.options.silent) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.loadUrl();</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 停止history对路由的监控, 并将状态恢复为未监听状态</span></div><div class="line">        <span class="comment">// 调用stop方法之后, 可重新调用start方法开始监听, stop方法一般用户在调用start方法之后, 需要重新设置start方法的参数, 或用于单元测试</span></div><div class="line">        stop : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 解除对浏览器路由的onpopstate和onhashchange事件的监听</span></div><div class="line">            $(<span class="built_in">window</span>).unbind(<span class="string">'popstate'</span>, <span class="keyword">this</span>.checkUrl).unbind(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.checkUrl);</div><div class="line">            <span class="comment">// 停止对于低版本的IE浏览器的心跳监控</span></div><div class="line">            clearInterval(<span class="keyword">this</span>._checkUrlInterval);</div><div class="line">            <span class="comment">// 恢复started状态, 便于下次重新调用start方法</span></div><div class="line">            History.started = <span class="literal">false</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 向handlers中绑定一个路由规则(参数route, 类型为正则表达式)与事件(参数callback)的映射关系(该方法由Router的实例自动调用)</span></div><div class="line">        route : <span class="function"><span class="keyword">function</span>(<span class="params">route, callback</span>) </span>&#123;</div><div class="line">            <span class="comment">// 将route和callback插入到handlers列表的第一个位置</span></div><div class="line">            <span class="comment">// 这是为了确保最后调用route时传入的规则被优先进行匹配</span></div><div class="line">            <span class="keyword">this</span>.handlers.unshift(&#123;</div><div class="line">                <span class="comment">// 路由规则(正则)</span></div><div class="line">                route : route,</div><div class="line">                <span class="comment">// 匹配规则时执行的方法</span></div><div class="line">                callback : callback</div><div class="line">            &#125;);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 检查当前的URL相对上一次的状态是否发生了变化</span></div><div class="line">        <span class="comment">// 如果发生变化, 则记录新的URL状态, 并调用loadUrl方法触发新URL与匹配路由规则的方法</span></div><div class="line">        <span class="comment">// 该方法在onpopstate和onhashchange事件被触发后自动调用, 或者在低版本的IE浏览器中由setInterval心跳定时调用</span></div><div class="line">        checkUrl : <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">            <span class="comment">// 获取当前的URL片段</span></div><div class="line">            <span class="keyword">var</span> current = <span class="keyword">this</span>.getFragment();</div><div class="line">            <span class="comment">// 对低版本的IE浏览器, 将从iframe中获取最新的URL片段并赋给current变量</span></div><div class="line">            <span class="keyword">if</span>(current == <span class="keyword">this</span>.fragment &amp;&amp; <span class="keyword">this</span>.iframe)</div><div class="line">                current = <span class="keyword">this</span>.getFragment(<span class="keyword">this</span>.getHash(<span class="keyword">this</span>.iframe));</div><div class="line">            <span class="comment">// 如果当前URL与上一次的状态没有发生任何变化, 则停止执行</span></div><div class="line">            <span class="keyword">if</span>(current == <span class="keyword">this</span>.fragment)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            <span class="comment">// 执行到这里, URL已经发生改变, 调用navigate方法将URL设置为当前URL</span></div><div class="line">            <span class="comment">// 这里在自动调用navigate方法时, 并没有传递options参数, 因此不会触发navigate方法中的loadUrl方法</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.iframe)</div><div class="line">                <span class="keyword">this</span>.navigate(current);</div><div class="line">            <span class="comment">// 调用loadUrl方法, 检查匹配的规则, 并执行规则绑定的方法</span></div><div class="line">            <span class="comment">// 如果调用this.loadUrl方法没有成功, 则试图在调用loadUrl方法时, 将重新获取的当前Hash传递给该方法</span></div><div class="line">            <span class="keyword">this</span>.loadUrl() || <span class="keyword">this</span>.loadUrl(<span class="keyword">this</span>.getHash());</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 根据当前URL, 与handler路由列表中的规则进行匹配</span></div><div class="line">        <span class="comment">// 如果URL符合某一个规则, 则执行这个规则所对应的方法, 函数将返回true</span></div><div class="line">        <span class="comment">// 如果没有找到合适的规则, 将返回false</span></div><div class="line">        <span class="comment">// loadUrl方法一般在页面初始化时调用start方法会被自动调用(除非设置了silent参数为true)</span></div><div class="line">        <span class="comment">// - 或当用户改变URL后, 由checkUrl监听到URL发生变化时被调用</span></div><div class="line">        <span class="comment">// - 或当调用navigate方法手动导航到某个URL时被调用</span></div><div class="line">        loadUrl : <span class="function"><span class="keyword">function</span>(<span class="params">fragmentOverride</span>) </span>&#123;</div><div class="line">            <span class="comment">// 获取当前URL片段</span></div><div class="line">            <span class="keyword">var</span> fragment = <span class="keyword">this</span>.fragment = <span class="keyword">this</span>.getFragment(fragmentOverride);</div><div class="line">            <span class="comment">// 调用Undersocre的any方法, 将URL片段与handlers中的所有规则依次进行匹配</span></div><div class="line">            <span class="keyword">var</span> matched = _.any(<span class="keyword">this</span>.handlers, <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>) </span>&#123;</div><div class="line">                <span class="comment">// 如果handlers中的规则与当前URL片段匹配, 则执行该归额对应的方法, 并返回true</span></div><div class="line">                <span class="keyword">if</span>(handler.route.test(fragment)) &#123;</div><div class="line">                    handler.callback(fragment);</div><div class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="comment">// matched是any方法的返回值, 如果匹配到规则则返回true, 没有匹配到返回false</span></div><div class="line">            <span class="keyword">return</span> matched;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 导航到指定的URL</span></div><div class="line">        <span class="comment">// 如果在options中设置了trigger, 将触发导航的URL与对应路由规则的事件</span></div><div class="line">        <span class="comment">// 如果在options中设置了replace, 将使用需要导航的URL替换当前的URL在history中的位置</span></div><div class="line">        navigate : <span class="function"><span class="keyword">function</span>(<span class="params">fragment, options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果没有调用start方法, 或已经调用stop方法, 则无法导航</span></div><div class="line">            <span class="keyword">if</span>(!History.started)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            <span class="comment">// 如果options参数不是一个对象, 而是true值, 则默认trigger配置项为true(即触发导航的URL与对应路由规则的事件)</span></div><div class="line">            <span class="keyword">if</span>(!options || options === <span class="literal">true</span>)</div><div class="line">                options = &#123;</div><div class="line">                    <span class="attr">trigger</span> : options</div><div class="line">                &#125;;</div><div class="line">            <span class="comment">// 将传递的fragment(URL片段)去掉首字符的"#"或"/"</span></div><div class="line">            <span class="keyword">var</span> frag = (fragment || <span class="string">''</span>).replace(routeStripper, <span class="string">''</span>);</div><div class="line">            <span class="comment">// 如果当前URL与需要导航的URL没有变化, 则不继续执行</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.fragment == frag)</div><div class="line">                <span class="keyword">return</span>;</div><div class="line"> </div><div class="line">            <span class="comment">// 如果当前支持并使用了pushState方式进行导航</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>._hasPushState) &#123;</div><div class="line">                <span class="comment">// 构造一个完整的URL, 如果当前URL片段中没有包含根路径, 则使用根路径连接URL片段</span></div><div class="line">                <span class="keyword">if</span>(frag.indexOf(<span class="keyword">this</span>.options.root) != <span class="number">0</span>)</div><div class="line">                    frag = <span class="keyword">this</span>.options.root + frag;</div><div class="line">                <span class="comment">// 设置新的URL</span></div><div class="line">                <span class="keyword">this</span>.fragment = frag;</div><div class="line">                <span class="comment">// 如果在options选项中设置了replace属性, 则将新的URL替换到history中的当前URL, 否则默认将新的URL追加到history中</span></div><div class="line">                <span class="built_in">window</span>.history[options.replace ? <span class="string">'replaceState'</span> : <span class="string">'pushState'</span>](&#123;&#125;, <span class="built_in">document</span>.title, frag);</div><div class="line"> </div><div class="line">                <span class="comment">// 如果使用hash方式进行导航</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>._wantsHashChange) &#123;</div><div class="line">                <span class="comment">// 设置新的hash</span></div><div class="line">                <span class="keyword">this</span>.fragment = frag;</div><div class="line">                <span class="comment">// 调用_updateHash方法更新当前URL为新的hash, 并将options中的replace配置传递给_updateHash方法(在该方法中实现替换或追加新的hash)</span></div><div class="line">                <span class="keyword">this</span>._updateHash(<span class="built_in">window</span>.location, frag, options.replace);</div><div class="line">                <span class="comment">// 对于低版本的IE浏览器, 当Hash发生变化时, 更新iframe URL中的Hash</span></div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.iframe &amp;&amp; (frag != <span class="keyword">this</span>.getFragment(<span class="keyword">this</span>.getHash(<span class="keyword">this</span>.iframe)))) &#123;</div><div class="line">                    <span class="comment">// 如果使用了replace参数替换当前URL, 则直接将iframe替换为新的文档</span></div><div class="line">                    <span class="comment">// 调用document.open打开一个新的文档, 以擦除当前文档中的内容(这里调用close方法是为了关闭文档的状态)</span></div><div class="line">                    <span class="comment">// open和close方法之间没有使用write或writeln方法输出内容, 因此这是一个空文档</span></div><div class="line">                    <span class="keyword">if</span>(!options.replace)</div><div class="line">                        <span class="keyword">this</span>.iframe.document.open().close();</div><div class="line">                    <span class="comment">// 调用_updateHash方法更新iframe中的URL</span></div><div class="line">                    <span class="keyword">this</span>._updateHash(<span class="keyword">this</span>.iframe.location, frag, options.replace);</div><div class="line">                &#125;</div><div class="line"> </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 如果在调用start方法时, 手动设置hashChange参数为true, 不希望使用pushState和hash方式导航</span></div><div class="line">                <span class="comment">// 则直接将页面跳转到新的URL</span></div><div class="line">                <span class="built_in">window</span>.location.assign(<span class="keyword">this</span>.options.root + fragment);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果在options配置项中设置了trigger属性, 则调用loadUrl方法查找路由规则, 并执行规则对应的事件</span></div><div class="line">            <span class="comment">// 在URL发生变化时, 通过checkUrl方法监听到的状态, 会在checkUrl方法中自动调用loadUrl方法</span></div><div class="line">            <span class="comment">// 在手动调用navigate方法时, 如果需要触发路由事件, 则需要传递trigger参数</span></div><div class="line">            <span class="keyword">if</span>(options.trigger)</div><div class="line">                <span class="keyword">this</span>.loadUrl(fragment);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 更新或设置当前URL中的Has串, _updateHash方法在使用hash方式导航时被自动调用(navigate方法中)</span></div><div class="line">        <span class="comment">// location是需要更新hash的window.location对象</span></div><div class="line">        <span class="comment">// fragment是需要更新的hash串</span></div><div class="line">        <span class="comment">// 如果需要将新的hash替换到当前URL, 可以设置replace为true</span></div><div class="line">        _updateHash : <span class="function"><span class="keyword">function</span>(<span class="params">location, fragment, replace</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果设置了replace为true, 则使用location.replace方法替换当前的URL</span></div><div class="line">            <span class="comment">// 使用replace方法替换URL后, 新的URL将占有原有URL在history历史中的位置</span></div><div class="line">            <span class="keyword">if</span>(replace) &#123;</div><div class="line">                <span class="comment">// 将当前URL与hash组合为一个完整的URL并替换</span></div><div class="line">                location.replace(location.toString().replace(<span class="regexp">/(javascript:|#).*$/</span>, <span class="string">''</span>) + <span class="string">'#'</span> + fragment);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 没有使用替换方式, 直接设置location.hash为新的hash串</span></div><div class="line">                location.hash = fragment;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    <span class="comment">// Backbone.View 视图相关</span></div><div class="line">    <span class="comment">// -------------</span></div><div class="line"> </div><div class="line">    <span class="comment">// 视图类用于创建与数据低耦合的界面控制对象, 通过将视图的渲染方法绑定到数据模型的change事件, 当数据发生变化时会通知视图进行渲染</span></div><div class="line">    <span class="comment">// 视图对象中的el用于存储当前视图所需要操作的DOM最父层元素, 这主要是为了提高元素的查找和操作效率, 其优点包括:</span></div><div class="line">    <span class="comment">// - 查找或操作元素时, 将操作的范围限定在el元素内, 不需要再整个文档树中搜索</span></div><div class="line">    <span class="comment">// - 在为元素绑定事件时, 可以方便地将事件绑定到el元素(默认也会绑定到el元素)或者是其子元素</span></div><div class="line">    <span class="comment">// - 在设计模式中, 将一个视图相关的元素, 事件, 和逻辑限定在该视图的范围中, 降低视图与视图间的耦合(至少在逻辑上是这样)</span></div><div class="line">    <span class="keyword">var</span> View = Backbone.View = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">        <span class="comment">// 为每一个视图对象创建一个唯一标识, 前缀为"view"</span></div><div class="line">        <span class="keyword">this</span>.cid = _.uniqueId(<span class="string">'view'</span>);</div><div class="line">        <span class="comment">// 设置初始化配置</span></div><div class="line">        <span class="keyword">this</span>._configure(options || &#123;&#125;);</div><div class="line">        <span class="comment">// 设置或创建视图中的元素</span></div><div class="line">        <span class="keyword">this</span>._ensureElement();</div><div class="line">        <span class="comment">// 调用自定义的初始化方法</span></div><div class="line">        <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">        <span class="comment">// 解析options中设置的events事件列表, 并将事件绑定到视图中的元素</span></div><div class="line">        <span class="keyword">this</span>.delegateEvents();</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 定义用于解析events参数中事件名称和元素的正则</span></div><div class="line">    <span class="keyword">var</span> delegateEventSplitter = <span class="regexp">/^(\S+)\s*(.*)$/</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// viewOptions列表记录一些列属性名, 在构造视图对象时, 如果传递的配置项中包含这些名称, 则将属性复制到对象本身</span></div><div class="line">    <span class="keyword">var</span> viewOptions = [<span class="string">'model'</span>, <span class="string">'collection'</span>, <span class="string">'el'</span>, <span class="string">'id'</span>, <span class="string">'attributes'</span>, <span class="string">'className'</span>, <span class="string">'tagName'</span>];</div><div class="line"> </div><div class="line">    <span class="comment">// 向视图类的原型对象中添加一些方法</span></div><div class="line">    _.extend(View.prototype, Events, &#123;</div><div class="line"> </div><div class="line">        <span class="comment">// 如果在创建视图对象时, 没有设置指定的el元素, 则会通过make方法创建一个元素, tagName为创建元素的默认标签</span></div><div class="line">        <span class="comment">// 也可以通过在options中自定义tagName来覆盖默认的"div"标签</span></div><div class="line">        tagName : <span class="string">'div'</span>,</div><div class="line"> </div><div class="line">        <span class="comment">// 每个视图中都具有一个$选择器方法, 该方法与jQuery或Zepto类似, 通过传递一个表达式来获取元素</span></div><div class="line">        <span class="comment">// 但该方法只会在视图对象的$el元素范围内进行查找, 因此会提高匹配效率</span></div><div class="line">        $ : <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$el.find(selector);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 初始化方法, 在对象被实例化后自动调用</span></div><div class="line">        initialize : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// render方法与initialize方法类似, 默认没有实现任何逻辑</span></div><div class="line">        <span class="comment">// 一般会重载该方法, 以实现对视图中元素的渲染</span></div><div class="line">        render : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 返回当前视图对象, 以支持方法的链式操作</span></div><div class="line">            <span class="comment">// 因此如果重载了该方法, 建议在方法最后也返回视图对象(this)</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 移除当前视图的$el元素</span></div><div class="line">        remove : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 通过调用jQuery或Zepto的remove方法, 因此在第三方库中会同时移除该元素绑定的所有事件和数据</span></div><div class="line">            <span class="keyword">this</span>.$el.remove();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 根据传入的标签名称, 属性和内容, 创建并返回一个DOM元素</span></div><div class="line">        <span class="comment">// 该方法用于在内部创建this.el时自动调用</span></div><div class="line">        make : <span class="function"><span class="keyword">function</span>(<span class="params">tagName, attributes, content</span>) </span>&#123;</div><div class="line">            <span class="comment">// 根据tagName创建元素</span></div><div class="line">            <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(tagName);</div><div class="line">            <span class="comment">// 设置元素属性</span></div><div class="line">            <span class="keyword">if</span>(attributes)</div><div class="line">                $(el).attr(attributes);</div><div class="line">            <span class="comment">// 设置元素内容</span></div><div class="line">            <span class="keyword">if</span>(content)</div><div class="line">                $(el).html(content);</div><div class="line">            <span class="comment">// 返回元素</span></div><div class="line">            <span class="keyword">return</span> el;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 为视图对象设置标准的$el及el属性, 该方法在对象创建时被自动调用</span></div><div class="line">        <span class="comment">// $el是通过jQuery或Zepto创建的对象, el是标准的DOM对象</span></div><div class="line">        setElement : <span class="function"><span class="keyword">function</span>(<span class="params">element, delegate</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果已经存在了$el属性(可能是手动调用了setElement方法切换视图的元素), 则取消之前对$el绑定的events事件(详细参考undelegateEvents方法)</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.$el)</div><div class="line">                <span class="keyword">this</span>.undelegateEvents();</div><div class="line">            <span class="comment">// 将元素创建为jQuery或Zepto对象, 并存放在$el属性中</span></div><div class="line">            <span class="keyword">this</span>.$el = ( element <span class="keyword">instanceof</span> $) ? element : $(element);</div><div class="line">            <span class="comment">// this.el存放标准的DOM对象</span></div><div class="line">            <span class="keyword">this</span>.el = <span class="keyword">this</span>.$el[<span class="number">0</span>];</div><div class="line">            <span class="comment">// 如果设置了delegate参数, 则为元素绑定视图中events参数设置的事件</span></div><div class="line">            <span class="comment">// 在视图类的构造函数中, 已经调用了delegateEvents方法进行绑定, 因此在初始化的_ensureElement方法中调用setElement方法时没有传递delegate参数</span></div><div class="line">            <span class="comment">// 在手动调用setElemen方法设置视图元素时, 允许传递delegate绑定事件</span></div><div class="line">            <span class="keyword">if</span>(delegate !== <span class="literal">false</span>)</div><div class="line">                <span class="keyword">this</span>.delegateEvents();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 为视图元素绑定事件</span></div><div class="line">        <span class="comment">// events参数配置了需要绑定事件的集合, 格式如('事件名称 元素选择表达式' : '事件方法名称/或事件函数'):</span></div><div class="line">        <span class="comment">// &#123;</span></div><div class="line">        <span class="comment">//     'click #title': 'edit',</span></div><div class="line">        <span class="comment">//     'click .save': 'save'</span></div><div class="line">        <span class="comment">//     'click span': function() &#123;&#125;</span></div><div class="line">        <span class="comment">// &#125;</span></div><div class="line">        <span class="comment">// 该方法在视图对象初始化时会被自动调用, 并将对象中的events属性作为events参数(事件集合)</span></div><div class="line">        delegateEvents : <span class="function"><span class="keyword">function</span>(<span class="params">events</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果没有手动传递events参数, 则从视图对象获取events属性作为事件集合</span></div><div class="line">            <span class="keyword">if</span>(!(events || ( events = getValue(<span class="keyword">this</span>, <span class="string">'events'</span>))))</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="comment">// 取消当前已经绑定过的events事件</span></div><div class="line">            <span class="keyword">this</span>.undelegateEvents();</div><div class="line">            <span class="comment">// 遍历需要绑定的事件列表</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> events) &#123;</div><div class="line">                <span class="comment">// 获取需要绑定的方法(允许是方法名称或函数)</span></div><div class="line">                <span class="keyword">var</span> method = events[key];</div><div class="line">                <span class="comment">// 如果是方法名称, 则从对象中获取该函数对象, 因此该方法名称必须是视图对象中已定义的方法</span></div><div class="line">                <span class="keyword">if</span>(!_.isFunction(method))</div><div class="line">                    method = <span class="keyword">this</span>[events[key]];</div><div class="line">                <span class="comment">// 对无效的方法抛出一个错误</span></div><div class="line">                <span class="keyword">if</span>(!method)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Method "'</span> + events[key] + <span class="string">'" does not exist'</span>);</div><div class="line">                <span class="comment">// 解析事件表达式(key), 从表达式中解析出事件的名字和需要操作的元素</span></div><div class="line">                <span class="comment">// 例如 'click #title'将被解析为 'click' 和 '#title' 两部分, 均存放在match数组中</span></div><div class="line">                <span class="keyword">var</span> match = key.match(delegateEventSplitter);</div><div class="line">                <span class="comment">// eventName为解析后的事件名称</span></div><div class="line">                <span class="comment">// selector为解析后的事件元素选择器表达式</span></div><div class="line">                <span class="keyword">var</span> eventName = match[<span class="number">1</span>], selector = match[<span class="number">2</span>];</div><div class="line">                <span class="comment">// bind方法是Underscore中用于绑定函数上下文的方法</span></div><div class="line">                <span class="comment">// 这里将method事件方法的上下文绑定到当前视图对象, 因此在事件被触发后, 事件方法中的this始终指向视图对象本身</span></div><div class="line">                method = _.bind(method, <span class="keyword">this</span>);</div><div class="line">                <span class="comment">// 设置事件名称, 在事件名称后追加标识, 用于传递给jQuery或Zepto的事件绑定方法</span></div><div class="line">                eventName += <span class="string">'.delegateEvents'</span> + <span class="keyword">this</span>.cid;</div><div class="line">                <span class="comment">// 通过jQuery或Zepto绑定事件</span></div><div class="line">                <span class="keyword">if</span>(selector === <span class="string">''</span>) &#123;</div><div class="line">                    <span class="comment">// 如果没有设置子元素选择器, 则通过bind方法将事件和方法绑定到当前$el元素本身</span></div><div class="line">                    <span class="keyword">this</span>.$el.bind(eventName, method);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 如果当前设置了子元素选择器表达式, 则通过delegate方式绑定</span></div><div class="line">                    <span class="comment">// 该方法将查找当前$el元素下的子元素, 并将于selector表达式匹配的元素进行事件绑定</span></div><div class="line">                    <span class="comment">// 如果该选择器的元素不属于当前$el的子元素, 则事件绑定无效</span></div><div class="line">                    <span class="keyword">this</span>.$el.delegate(selector, eventName, method);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 取消视图中当前元素绑定的events事件, 该方法一般不会被使用</span></div><div class="line">        <span class="comment">// 除非调用delegateEvents方法重新为视图中的元素绑定事件, 在重新绑定之前会清除当前的事件</span></div><div class="line">        <span class="comment">// 或通过setElement方法重新设置试图的el元素, 也会清除当前元素的事件</span></div><div class="line">        undelegateEvents : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.$el.unbind(<span class="string">'.delegateEvents'</span> + <span class="keyword">this</span>.cid);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 在实例化视图对象时设置初始配置</span></div><div class="line">        <span class="comment">// 将传递的配置覆盖到对象的options中</span></div><div class="line">        <span class="comment">// 将配置中与viewOptions列表相同的配置复制到对象本身, 作为对象的属性</span></div><div class="line">        _configure : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果对象本身设置了默认配置, 则使用传递的配置进行合并</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.options)</div><div class="line">                options = _.extend(&#123;&#125;, <span class="keyword">this</span>.options, options);</div><div class="line">            <span class="comment">// 遍历viewOptions列表</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, l = viewOptions.length; i &lt; l; i++) &#123;</div><div class="line">                <span class="comment">// attr依次为viewOptions中的属性名</span></div><div class="line">                <span class="keyword">var</span> attr = viewOptions[i];</div><div class="line">                <span class="comment">// 将options配置中与viewOptions相同的配置复制到对象本身, 作为对象的属性</span></div><div class="line">                <span class="keyword">if</span>(options[attr])</div><div class="line">                    <span class="keyword">this</span>[attr] = options[attr];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 设置对象的options配置</span></div><div class="line">            <span class="keyword">this</span>.options = options;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 每一个视图对象都应该有一个el元素, 作为渲染的元素</span></div><div class="line">        <span class="comment">// 在构造视图时, 可以设置对象的el属性来指定一个元素</span></div><div class="line">        <span class="comment">// 如果设置的el是一个字符串或DOM对象, 则通过$方法将其创建为一个jQuery或Zepto对象</span></div><div class="line">        <span class="comment">// 如果没有设置el属性, 则根据传递的tagName, id和className, 调用mak方法创建一个元素</span></div><div class="line">        <span class="comment">// (新创建的元素不会被添加到文档树中, 而始终存储在内存, 当处理完毕需要渲染到页面时, 一般会在重写的render方法, 或自定义方法中, 访问this.el将其追加到文档)</span></div><div class="line">        <span class="comment">// (如果我们需要向页面添加一个目前还没有的元素, 并且需要为其添加一些子元素, 属性, 样式或事件时, 可以通过该方式先将元素创建到内存, 在完成所有操作之后再手动渲染到文档, 可以提高渲染效率)</span></div><div class="line">        _ensureElement : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果没有设置el属性, 则创建默认元素</span></div><div class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.el) &#123;</div><div class="line">                <span class="comment">// 从对象获取attributes属性, 作为新创建元素的默认属性列表</span></div><div class="line">                <span class="keyword">var</span> attrs = getValue(<span class="keyword">this</span>, <span class="string">'attributes'</span>) || &#123;&#125;;</div><div class="line">                <span class="comment">// 设置新元素的id</span></div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.id)</div><div class="line">                    attrs.id = <span class="keyword">this</span>.id;</div><div class="line">                <span class="comment">// 设置新元素的class</span></div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.className)</div><div class="line">                    attrs[<span class="string">'class'</span>] = <span class="keyword">this</span>.className;</div><div class="line">                <span class="comment">// 通过make方法创建元素, 并调用setElement方法将元素设置为视图所使用的标准元素</span></div><div class="line">                <span class="keyword">this</span>.setElement(<span class="keyword">this</span>.make(<span class="keyword">this</span>.tagName, attrs), <span class="literal">false</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 如果设置了el属性, 则直接调用setElement方法将el元素设置为视图的标准元素</span></div><div class="line">                <span class="keyword">this</span>.setElement(<span class="keyword">this</span>.el, <span class="literal">false</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    <span class="comment">// 实现对象继承的函数, 该函数内部使用inherits实现继承, 请参考inherits函数</span></div><div class="line">    <span class="keyword">var</span> extend = <span class="function"><span class="keyword">function</span>(<span class="params">protoProps, classProps</span>) </span>&#123;</div><div class="line">        <span class="comment">// child存储已经实现继承自当前类的子类(Function)</span></div><div class="line">        <span class="comment">// protoProps设置子类原型链中的属性</span></div><div class="line">        <span class="comment">// classProps设置子类的静态属性</span></div><div class="line">        <span class="keyword">var</span> child = inherits(<span class="keyword">this</span>, protoProps, classProps);</div><div class="line">        <span class="comment">// 将extend函数添加到子类, 因此调用子类的extend方法便可实现对子类的继承</span></div><div class="line">        child.extend = <span class="keyword">this</span>.extend;</div><div class="line">        <span class="comment">// 返回实现继承的子类</span></div><div class="line">        <span class="keyword">return</span> child;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 为Model, Collection, Router和View类实现继承机制</span></div><div class="line">    Model.extend = Collection.extend = Router.extend = View.extend = extend;</div><div class="line"> </div><div class="line">    <span class="comment">// Backbone.sync 与服务器异步交互相关</span></div><div class="line">    <span class="comment">// -------------</span></div><div class="line"> </div><div class="line">    <span class="comment">// 定义Backbone中与服务器交互方法和请求type的对应关系</span></div><div class="line">    <span class="keyword">var</span> methodMap = &#123;</div><div class="line">        <span class="string">'create'</span> : <span class="string">'POST'</span>,</div><div class="line">        <span class="string">'update'</span> : <span class="string">'PUT'</span>,</div><div class="line">        <span class="string">'delete'</span> : <span class="string">'DELETE'</span>,</div><div class="line">        <span class="string">'read'</span> : <span class="string">'GET'</span></div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">    <span class="comment">// sync用于在Backbone中操作数据时, 向服务器发送请求同步数据状态, 以建立与服务器之间的无缝连接</span></div><div class="line">    <span class="comment">// sync发送默认通过第三方库(jQuery, Zepto等) $.ajax方法发送请求, 因此如果要调用状态同步相关的方法, 需要第三方库支持</span></div><div class="line">    <span class="comment">// Backbone默认定义了一套与服务器交互的数据格式(JSON)和结构, 服务器响应的数据应该遵循该约定</span></div><div class="line">    <span class="comment">// 如果数据不需要保存在服务器, 或与服务器交互方法, 数据格式结构与约定不一致, 可以通过重载sync方法实现</span></div><div class="line">    <span class="comment">// @param &#123;String&#125; method 在Backbone中执行的CRUD操作名称</span></div><div class="line">    <span class="comment">// @param &#123;Model Obejct&#125; model 需要与服务器同步状态的模型对象</span></div><div class="line">    <span class="comment">// @param &#123;Object&#125; options</span></div><div class="line">    Backbone.sync = <span class="function"><span class="keyword">function</span>(<span class="params">method, model, options</span>) </span>&#123;</div><div class="line">        <span class="comment">// 根据CRUD方法名定义与服务器交互的方法(POST, GET, PUT, DELETE)</span></div><div class="line">        <span class="keyword">var</span> type = methodMap[method];</div><div class="line"> </div><div class="line">        <span class="comment">// options默认为一个空对象</span></div><div class="line">        options || ( options = &#123;&#125;);</div><div class="line"> </div><div class="line">        <span class="comment">// params将作为请求参数对象传递给第三方库的$.ajax方法</span></div><div class="line">        <span class="keyword">var</span> params = &#123;</div><div class="line">            <span class="comment">// 请求类型</span></div><div class="line">            type : type,</div><div class="line">            <span class="comment">// 数据格式默认为json</span></div><div class="line">            dataType : <span class="string">'json'</span></div><div class="line">        &#125;;</div><div class="line"> </div><div class="line">        <span class="comment">// 如果在发送请求时没有在options中设置url地址, 将会通过模型对象的url属性或方法来获取url</span></div><div class="line">        <span class="comment">// 模型所获取url的方式可参考模型的url方法</span></div><div class="line">        <span class="keyword">if</span>(!options.url) &#123;</div><div class="line">            <span class="comment">// 获取请求地址失败时会调用urlError方法抛出一个错误</span></div><div class="line">            params.url = getValue(model, <span class="string">'url'</span>) || urlError();</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// 如果调用create和update方法, 且没有在options中定义请求数据, 将序列化模型中的数据对象传递给服务器</span></div><div class="line">        <span class="keyword">if</span>(!options.data &amp;&amp; model &amp;&amp; (method == <span class="string">'create'</span> || method == <span class="string">'update'</span>)) &#123;</div><div class="line">            <span class="comment">// 定义请求的Content-Type头, 默认为application/json</span></div><div class="line">            params.contentType = <span class="string">'application/json'</span>;</div><div class="line">            <span class="comment">// 序列化模型中的数据, 并作为请求数据传递给服务器</span></div><div class="line">            params.data = <span class="built_in">JSON</span>.stringify(model.toJSON());</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// 对于不支持application/json编码的浏览器, 可以通过设置Backbone.emulateJSON参数为true实现兼容</span></div><div class="line">        <span class="keyword">if</span>(Backbone.emulateJSON) &#123;</div><div class="line">            <span class="comment">// 不支持Backbone.emulateJSON编码的浏览器, 将类型设置为application/x-www-form-urlencoded</span></div><div class="line">            params.contentType = <span class="string">'application/x-www-form-urlencoded'</span>;</div><div class="line">            <span class="comment">// 将需要同步的数据存放在key为"model"参数中发送到服务器</span></div><div class="line">            params.data = params.data ? &#123;</div><div class="line">                <span class="attr">model</span> : params.data</div><div class="line">            &#125; : &#123;&#125;;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// 对于不支持REST方式的浏览器, 可以设置Backbone.emulateHTTP参数为true, 以POST方式发送数据, 并在数据中加入_method参数标识操作名称</span></div><div class="line">        <span class="comment">// 同时也将发送X-HTTP-Method-Override头信息</span></div><div class="line">        <span class="keyword">if</span>(Backbone.emulateHTTP) &#123;</div><div class="line">            <span class="comment">// 如果操作类型为PUT或DELETE</span></div><div class="line">            <span class="keyword">if</span>(type === <span class="string">'PUT'</span> || type === <span class="string">'DELETE'</span>) &#123;</div><div class="line">                <span class="comment">// 将操作名称存放到_method参数发送到服务器</span></div><div class="line">                <span class="keyword">if</span>(Backbone.emulateJSON)</div><div class="line">                    params.data._method = type;</div><div class="line">                <span class="comment">// 实际以POST方式进行提交, 并发送X-HTTP-Method-Override头信息</span></div><div class="line">                params.type = <span class="string">'POST'</span>;</div><div class="line">                params.beforeSend = <span class="function"><span class="keyword">function</span>(<span class="params">xhr</span>) </span>&#123;</div><div class="line">                    xhr.setRequestHeader(<span class="string">'X-HTTP-Method-Override'</span>, type);</div><div class="line">                &#125;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// 对非GET方式的请求, 将不对数据进行转换, 因为传递的数据可能是一个JSON映射</span></div><div class="line">        <span class="keyword">if</span>(params.type !== <span class="string">'GET'</span> &amp;&amp; !Backbone.emulateJSON) &#123;</div><div class="line">            <span class="comment">// 通过设置processData为false来关闭数据转换</span></div><div class="line">            <span class="comment">// processData参数是$.ajax方法中的配置参数, 详细信息可参考jQuery或Zepto相关文档</span></div><div class="line">            params.processData = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// 通过第三方库的$.ajax方法向服务器发送请求同步数据状态</span></div><div class="line">        <span class="comment">// 传递给$.ajax方法的参数使用extend方法将options对象中的参数覆盖到了params对象, 因此在调用sync方法时设置了与params同名的options参数, 将以options为准</span></div><div class="line">        <span class="keyword">return</span> $.ajax(_.extend(params, options));</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 包装一个统一的模型错误处理方法, 会在模型与服务器交互发生错误时被调用</span></div><div class="line">    <span class="comment">// onError是在调用与服务器的交互方法时(如fetch, destory等), options中指定的自定义错误处理函数</span></div><div class="line">    <span class="comment">// originalModel是发生错误的模型或集合对象</span></div><div class="line">    Backbone.wrapError = <span class="function"><span class="keyword">function</span>(<span class="params">onError, originalModel, options</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">model, resp</span>) </span>&#123;</div><div class="line">            resp = model === originalModel ? resp : model;</div><div class="line"> </div><div class="line">            <span class="keyword">if</span>(onError) &#123;</div><div class="line">                <span class="comment">// 如果设置了自定义错误处理方法, 则调用自定义方法</span></div><div class="line">                onError(originalModel, resp, options);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 默认将触发发生错误的模型或集合的error事件</span></div><div class="line">                originalModel.trigger(<span class="string">'error'</span>, originalModel, resp, options);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// Helpers 定义一些供Backbone内部使用的帮助函数</span></div><div class="line">    <span class="comment">// -------</span></div><div class="line"> </div><div class="line">    <span class="comment">// ctor是一个共享的空函数, 用于在调用inherits方法实现继承时, 承载父类的原型链以便设置到子类原型中</span></div><div class="line">    <span class="keyword">var</span> ctor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 实现OOP继承特性</span></div><div class="line">    <span class="comment">// @param &#123;Function&#125; parent 被继承的父类Function</span></div><div class="line">    <span class="comment">// @param &#123;Object&#125; protoProps 扩展子类原型中的属性(或方法)对象</span></div><div class="line">    <span class="comment">// @param &#123;Object&#125; staticProps 扩展子类的静态属性(或方法)对象</span></div><div class="line">    <span class="keyword">var</span> inherits = <span class="function"><span class="keyword">function</span>(<span class="params">parent, protoProps, staticProps</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> child;</div><div class="line"> </div><div class="line">        <span class="comment">// 如果在protoProps中指定了"constructor"属性, 则"constructor"属性被作为子类的构造函数</span></div><div class="line">        <span class="comment">// 如果没有指定构造子类构造函数, 则默认调用父类的构造函数</span></div><div class="line">        <span class="keyword">if</span>(protoProps &amp;&amp; protoProps.hasOwnProperty(<span class="string">'constructor'</span>)) &#123;</div><div class="line">            <span class="comment">// 使用"constructor"属性指定的子类构造函数</span></div><div class="line">            child = protoProps.constructor;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 使用父类的构造函数</span></div><div class="line">            child = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// 将父类中的静态属性复制为子类静态属性</span></div><div class="line">        _.extend(child, parent);</div><div class="line"> </div><div class="line">        <span class="comment">// 将父类原型链设置到子类的原型对象中, 子类以此继承父类原型链中的所有属性</span></div><div class="line">        ctor.prototype = parent.prototype;</div><div class="line">        child.prototype = <span class="keyword">new</span> ctor();</div><div class="line"> </div><div class="line">        <span class="comment">// 将protoProps对象中的属性复制到子类的原型对象, 子类以此拥有protoProps中的属性</span></div><div class="line">        <span class="keyword">if</span>(protoProps)</div><div class="line">            _.extend(child.prototype, protoProps);</div><div class="line"> </div><div class="line">        <span class="comment">// 将staticProps对象中的属性复制到子类的构造函数本身, 将staticProps中的属性作为子类的静态属性</span></div><div class="line">        <span class="keyword">if</span>(staticProps)</div><div class="line">            _.extend(child, staticProps);</div><div class="line"> </div><div class="line">        <span class="comment">// 在复制父类原型链到子类原型时, 子类原型链中的构造函数已经被覆盖, 因此此处重新设置子类的构造函数</span></div><div class="line">        child.prototype.constructor = child;</div><div class="line"> </div><div class="line">        <span class="comment">// 如果子类设置了constructor属性, 则子类构造函数为constructor指定的函数</span></div><div class="line">        <span class="comment">// 如果需要在子类构造函数中调用父类构造函数, 则需要在子类构造函数中手动调用父类的构造函数</span></div><div class="line">        <span class="comment">// 此处将子类的__super__属性指向父类的构造函数, 方便在子类中调用: 子类.__super__.constructor.call(this);</span></div><div class="line">        child.__super__ = parent.prototype;</div><div class="line"> </div><div class="line">        <span class="comment">// 返回子类</span></div><div class="line">        <span class="keyword">return</span> child;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 获取对象prop属性的值, 如果prop属性是一个函数, 则执行并返回该函数的返回值</span></div><div class="line">    <span class="keyword">var</span> getValue = <span class="function"><span class="keyword">function</span>(<span class="params">object, prop</span>) </span>&#123;</div><div class="line">        <span class="comment">// 如果object为空或object不存在prop属性, 则返回null</span></div><div class="line">        <span class="keyword">if</span>(!(object &amp;&amp; object[prop]))</div><div class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">        <span class="comment">// 返回prop属性值, 如果prop是一个函数, 则执行并返回该函数的返回值</span></div><div class="line">        <span class="keyword">return</span> _.isFunction(object[prop]) ? object[prop]() : object[prop];</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 抛出一个Error异常, 在Backbone内部会频繁执行, 因此独立为一个公共函数</span></div><div class="line">    <span class="keyword">var</span> urlError = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'A "url" property or function must be specified'</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;).call(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/03/02/easy-two-way-data-binding-in-javascript/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          JavaScript 实现简单的双向数据绑定（译）
        
      </div>
    </a>
  
  
    <a href="/2016/03/04/setinterval-error-solution/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">setInterval 计时误差解决方案</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="backbone-source-analysis" data-title="Backbone 0.9.2 源码分析" data-url="http://zqianduan.com/2016/03/03/backbone-source-analysis/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"zqianduan"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Jimco
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ccac13d2d4e18f7ac82a7f1c9de98a90";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </div>
</body>
</html>